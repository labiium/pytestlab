{
    ".gitignore": "test/\n__pycache__/\n",
    "pytestlab.json": "{\n    \".gitignore\": \"test/\\n__pycache__/\\n\",\n    \"pytestlab.json\": \"{\\n    \\\".gitignore\\\": \\\"test/\\\\n__pycache__/\\\\n\\\",\\n    \\\"pytestlab.json\\\": \\\"{\\\\n    \\\\\\\".gitignore\\\\\\\": \\\\\\\"test/\\\\\\\\n__pycache__/\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"README.md\\\\\\\": \\\\\\\"# PyTestLab\\\\\\\\n\\\\\\\\nA Python library for test and measurement  automation and measurement data management.\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"setup.py\\\\\\\": \\\\\\\"from setuptools import setup, find_packages\\\\\\\\n\\\\\\\\nsetup(\\\\\\\\n    name='pytestlab',\\\\\\\\n    version='0.0.1',\\\\\\\\n    description='A Python library for instrument automation and measurement data management.',\\\\\\\\n    author='Emmanuel Olowe',\\\\\\\\n    author_email='e.a.olowe@ed.ac.uk',\\\\\\\\n    # url='https://github.com/labiium/PyTestLab',\\\\\\\\n    # packages=find_packages(),\\\\\\\\n    # install_requires=[\\\\\\\\n    #     'numpy',\\\\\\\\n    #     # 'scipy',\\\\\\\\n    #     'pandas',\\\\\\\\n    #     # 'pyvisa',\\\\\\\\n    # ],\\\\\\\\n    classifiers=[\\\\\\\\n        'Development Status :: 3 - Alpha',\\\\\\\\n        'Intended Audience :: Developers',\\\\\\\\n        'License :: OSI Approved :: MIT License',\\\\\\\\n        'Programming Language :: Python :: 3',\\\\\\\\n        'Programming Language :: Python :: 3.6',\\\\\\\\n        'Programming Language :: Python :: 3.7',\\\\\\\\n        'Programming Language :: Python :: 3.8',\\\\\\\\n        'Programming Language :: Python :: 3.9',\\\\\\\\n        'Programming Language :: Python :: 3.10',\\\\\\\\n        'Programming Language :: Python :: 3.11',\\\\\\\\n    ],\\\\\\\\n)\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\description.json\\\\\\\": \\\\\\\"{\\\\\\\\n    \\\\\\\\\\\\\\\"methods\\\\\\\\\\\\\\\": [\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"add_instrument\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Add an instrument to the manager's collection.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"str\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The name of the instrument.\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"instrument\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"object\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The instrument object to be added.\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"remove_instrument\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Remove an instrument from the manager's collection.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"str\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The name of the instrument to be removed.\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"get_instrument\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Get an instrument by name from the manager's collection.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"str\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The name of the instrument to retrieve.\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"list_instruments\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"List all instruments currently added to the manager.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"connect_all_instruments\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Connect all instruments in the manager's collection.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"disconnect_all_instruments\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Disconnect all instruments in the manager's collection.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"is_all_instruments_connected\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Check if all instruments are connected.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"is_instrument_connected\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Check if a specific instrument is connected.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"str\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The name of the instrument to check.\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"measure_voltage\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a voltage measurement.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"voltage\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The voltage to measure.\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"channel\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"int\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The channel number to measure (default: 1).\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"measure_current\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a current measurement.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"current\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The current to measure.\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"channel\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"int\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The channel number to measure (default: 1).\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"measure_power\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a power measurement.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"power\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The power to measure.\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"channel\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"int\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The channel number to measure (default: 1).\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"measure_eye_diagram\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform an Eye Diagram measurement.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"test_pattern\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"str\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The test pattern to use.\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"voltage\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The voltage for the power supply (default: 1.0 V).\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"current\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The current for the power supply (default: 0.5 A).\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"channel\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"int\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The channel number to use (default: 1).\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"eye_duration\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The duration of the eye diagram measurement (default: 0.1 s).\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"perform_s21_measurement\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform an S21 measurement.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"frequency\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The frequency for the measurement.\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"power_level\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The power level for the measurement.\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"channel\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"int\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The channel number to use (default: 1).\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"measurement_time\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"float\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The measurement time (default: 0.1 s).\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"calibrate_power_supply\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Calibrate the power supply.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"calibrate_oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Calibrate the oscilloscope.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"calibrate_vna\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Calibrate the Vector Network Analyzer.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"save_measurement_data\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Save measurement data to a file.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"data\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"dict\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The measurement data to save.\\\\\\\\\\\\\\\"\\\\\\\\n                },\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"file_name\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"str\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The name of the file to save the data to.\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"load_measurement_data\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Load measurement data from a file.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"file_name\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"str\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"The name of the file to load the data from.\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"configure_power_supply\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Configure power supply settings.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"settings\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"dict\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"A dictionary containing power supply settings.\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"configure_oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Configure oscilloscope settings.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"settings\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"dict\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"A dictionary containing oscilloscope settings.\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"configure_vna\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Configure Vector Network Analyzer settings.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": [\\\\\\\\n                {\\\\\\\\n                    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"settings\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"dict\\\\\\\\\\\\\\\",\\\\\\\\n                    \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"A dictionary containing VNA settings.\\\\\\\\\\\\\\\"\\\\\\\\n                }\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"check_instrument_compatibility\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Check if the connected instruments are compatible for the planned measurements.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"perform_full_system_check\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a comprehensive system check before starting measurements.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        },\\\\\\\\n        {\\\\\\\\n            \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"report_system_status\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Generate a report on the status of connected instruments and overall system health.\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"parameters\\\\\\\\\\\\\\\": []\\\\\\\\n        }\\\\\\\\n    ]\\\\\\\\n}\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\digital_multimeter_example.py\\\\\\\": \\\\\\\"from pytestlab.instruments.DigitalMultimeter import DigitalMultimeter\\\\\\\\nimport json\\\\\\\\n# connect to the digital multimeter\\\\\\\\npath_to_description = \\\\\\\\\\\\\\\"/examples/instrument_descriptions/digital_multi_meter.json\\\\\\\\\\\\\\\"\\\\\\\\ndescription = json.load(open(path_to_description, \\\\\\\\\\\\\\\"r\\\\\\\\\\\\\\\"))\\\\\\\\n\\\\\\\\ndigital_multimeter = DigitalMultimeter(description[\\\\\\\\\\\\\\\"visa_resource\\\\\\\\\\\\\\\"], description)\\\\\\\\n\\\\\\\\n# print the id of the digital multimeter\\\\\\\\nprint(digital_multimeter.id())\\\\\\\\n\\\\\\\\n# reset the digital multimeter\\\\\\\\ndigital_multimeter.reset()\\\\\\\\n\\\\\\\\n# set the voltage of channel 1 to 1.5V\\\\\\\\ndigital_multimeter.set_channel_voltage(1, 1.5)\\\\\\\\n\\\\\\\\n# get the voltage of channel 1\\\\\\\\nprint(digital_multimeter.get_channel_voltage(1))\\\\\\\\n\\\\\\\\n\\\\\\\\n# measure the frequency of channel 1\\\\\\\\nprint(digital_multimeter.measure_frequency(1))\\\\\\\\n\\\\\\\\n# close the connection to the digital multimeter\\\\\\\\ndigital_multimeter.close()\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\oscilloscope_jitter_example.py\\\\\\\": \\\\\\\"from pytestlab.instruments.Oscilloscope import Oscilloscope\\\\\\\\nfrom pytestlab.instruments.InstrumentManager import InstrumentManager\\\\\\\\n\\\\\\\\n# connect to the oscilloscope\\\\\\\\noscilloscope = Oscilloscope(\\\\\\\\\\\\\\\"USB0::0x0957::0x1799::MY58100838::INSTR\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n# reset oscilloscope\\\\\\\\noscilloscope.reset()\\\\\\\\n\\\\\\\\nprint(oscilloscope.id())\\\\\\\\n\\\\\\\\n# get the voltage of channel 1\\\\\\\\nprint(oscilloscope.get_channel_voltage(1))\\\\\\\\n\\\\\\\\n# measure the frequency of channel 1\\\\\\\\nprint(oscilloscope.measure_frequency(1))\\\\\\\\n\\\\\\\\n# rms jitter measurement\\\\\\\\nprint(oscilloscope.perform_rms_jitter_measurement(1, 0.5))\\\\\\\\n\\\\\\\\n# peak-to-peak jitter measurement\\\\\\\\nprint(oscilloscope.perform_peak_to_peak_jitter_measurement(1, 0.5))\\\\\\\\n\\\\\\\\n# rise time measurement\\\\\\\\nprint(oscilloscope.perform_rise_time_measurement(1, 0.5))\\\\\\\\n\\\\\\\\n# fall time measurement\\\\\\\\nprint(oscilloscope.perform_fall_time_measurement(1, 0.5))\\\\\\\\n\\\\\\\\n# eye diagram measurement\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\__init__.py\\\\\\\": \\\\\\\"\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\instrument_descrptions\\\\\\\\\\\\\\\\.oscilloscope_description.py\\\\\\\": \\\\\\\"oscilloscope_description = {\\\\\\\\n    \\\\\\\\\\\\\\\"manufacturer\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Keysight\\\\\\\\\\\\\\\",    # Manufacturer name\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Magic Oscilloscope with 2 Channels\\\\\\\\\\\\\\\",    # Model name/number\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\", # Device type\\\\\\\\n    \\\\\\\\\\\\\\\"visa_resource\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"USB0::0x0957::0x1799::MY58100838::INSTR\\\\\\\\\\\\\\\",   # VISA resource string\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,             # Minimum voltage (in volts) supported on Channel 1\\\\\\\\n            \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,              # Maximum voltage (in volts) supported on Channel 1\\\\\\\\n            \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"GND\\\\\\\\\\\\\\\"],   # List of supported input coupling modes\\\\\\\\n            \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,   # Input impedance (in ohms) for Channel 1\\\\\\\\n            \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100],       # List of supported probe attenuation ratios\\\\\\\\n            # Add more channel-specific settings and limitations as needed\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,             # Minimum voltage (in volts) supported on Channel 2\\\\\\\\n            \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,              # Maximum voltage (in volts) supported on Channel 2\\\\\\\\n            \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"GND\\\\\\\\\\\\\\\"],   # List of supported input coupling modes\\\\\\\\n            \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,   # Input impedance (in ohms) for Channel 2\\\\\\\\n            \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100],       # List of supported probe attenuation ratios\\\\\\\\n            # Add more channel-specific settings and limitations as needed\\\\\\\\n        },\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 1e-9,         # Minimum timebase scale (in seconds) supported\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 10.0,         # Maximum timebase scale (in seconds) supported\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"],   # List of supported time units\\\\\\\\n        # Add more timebase-related settings and limitations as needed\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"VIDEO\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"USB\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"RS232\\\\\\\\\\\\\\\"],   # List of supported trigger modes\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\"],          # List of supported trigger slope options\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EXT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EXT/10\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EXT/100\\\\\\\\\\\\\\\"],  # List of supported external trigger inputs\\\\\\\\n        # Add more trigger-related settings and limitations as needed\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"0.5 - 6 GHz\\\\\\\\\\\\\\\",            # Oscilloscope bandwidth (in Hz)\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": [4, 8],             # Number of analog channels supported (upgradeable)\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",           # Oscilloscope sampling rate (in samples per second)\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200Mpts/ch\\\\\\\\\\\\\\\",       # Standard memory per channel (in points)\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\">200,000 wfms/sec\\\\\\\\\\\\\\\",  # Waveform update rate (in waveforms per second)\\\\\\\\n    # Jitter analysis\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Peak-to-Peak\\\\\\\\\\\\\\\"],   # Types of jitter measurement\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Phase Noise\\\\\\\\\\\\\\\"], # List of selectable jitter sources\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,         # Maximum number of cycles or edges that can be analyzed\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256,         # Number of histogram bins for jitter distribution\\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": True,   # Supports modulation analysis or not\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": True,    # Supports real-time jitter analysis or not\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,   # Minimum measurable jitter (in seconds)\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3,    # Maximum measurable jitter (in seconds)\\\\\\\\n        # Add more jitter-related settings and limitations as needed\\\\\\\\n    }\\\\\\\\n    # Add more settings and limitations as needed\\\\\\\\n}\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\instrument_descrptions\\\\\\\\\\\\\\\\digital_multimeter.py\\\\\\\": \\\\\\\"digital_multimeter_description = {\\\\\\\\n    \\\\\\\\\\\\\\\"voltage_channels\\\\\\\\\\\\\\\": [1, 2],   # Supported voltage measurement channels: 1, 2\\\\\\\\n    \\\\\\\\\\\\\\\"current_channels\\\\\\\\\\\\\\\": [1],      # Supported current measurement channels: 1\\\\\\\\n    \\\\\\\\\\\\\\\"voltage_range\\\\\\\\\\\\\\\": 1000,        # Voltage measurement range (in Volts)\\\\\\\\n    \\\\\\\\\\\\\\\"current_range\\\\\\\\\\\\\\\": 10,          # Current measurement range (in Amperes)\\\\\\\\n}\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\instrument_descrptions\\\\\\\\\\\\\\\\digital_power_supply.py\\\\\\\": \\\\\\\"digital_power_supply_description = {\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\\\\\\\\"min_voltage\\\\\\\\\\\\\\\": 0, \\\\\\\\\\\\\\\"max_voltage\\\\\\\\\\\\\\\": 30},   # Channel 1 voltage range: 0 V to 30 V\\\\\\\\n        2: {\\\\\\\\\\\\\\\"min_voltage\\\\\\\\\\\\\\\": 0, \\\\\\\\\\\\\\\"max_voltage\\\\\\\\\\\\\\\": 30},   # Channel 2 voltage range: 0 V to 30 V\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"max_current\\\\\\\\\\\\\\\": 5,   # Maximum current (in Amperes) supported by the power supply\\\\\\\\n}\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\instrument_descrptions\\\\\\\\\\\\\\\\oscilloscope.json\\\\\\\": \\\\\\\"{\\\\\\\\n    \\\\\\\\\\\\\\\"manufacturer\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Keysight\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Magic Oscilloscope with 2 Channels\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"visa_resource\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"USB0::0x0957::0x1799::MY58100838::INSTR\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"1\\\\\\\\\\\\\\\": {\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n            \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n            \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\n                \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\",\\\\\\\\n                \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\",\\\\\\\\n                \\\\\\\\\\\\\\\"GND\\\\\\\\\\\\\\\"\\\\\\\\n            ],\\\\\\\\n            \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1000000,\\\\\\\\n            \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [\\\\\\\\n                1,\\\\\\\\n                10,\\\\\\\\n                100\\\\\\\\n            ]\\\\\\\\n        },\\\\\\\\n        \\\\\\\\\\\\\\\"2\\\\\\\\\\\\\\\": {\\\\\\\\n            \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n            \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n            \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\n                \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\",\\\\\\\\n                \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\",\\\\\\\\n                \\\\\\\\\\\\\\\"GND\\\\\\\\\\\\\\\"\\\\\\\\n            ],\\\\\\\\n            \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1000000,\\\\\\\\n            \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [\\\\\\\\n                1,\\\\\\\\n                10,\\\\\\\\n                100\\\\\\\\n            ]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 1e-9,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 10.0,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\n            \\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"\\\\\\\\n        ]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\n            \\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"VIDEO\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"USB\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"RS232\\\\\\\\\\\\\\\"\\\\\\\\n        ],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\n            \\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\"\\\\\\\\n        ],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\n            \\\\\\\\\\\\\\\"EXT\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"EXT/10\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"EXT/100\\\\\\\\\\\\\\\"\\\\\\\\n        ]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"0.5 - 6 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": [\\\\\\\\n        4,\\\\\\\\n        8\\\\\\\\n    ],\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\">200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\n            \\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"Peak-to-Peak\\\\\\\\\\\\\\\"\\\\\\\\n        ],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\n            \\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\",\\\\\\\\n            \\\\\\\\\\\\\\\"Phase Noise\\\\\\\\\\\\\\\"\\\\\\\\n        ],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1000000,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256,\\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": true,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": true,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n}\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\instrument_descrptions\\\\\\\\\\\\\\\\train.jsonl\\\\\\\": \\\\\\\"  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a frequency measurement on channel 4 with 10 Hz.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a frequency measurement on channel 4. The signal generator will be set to 10 Hz, the output will be enabled, the frequency will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nsignal_generator.set_frequency(10, channel=4)\\\\\\\\\\\\\\\\nsignal_generator.enable_output(channel=4)\\\\\\\\\\\\\\\\nmanager.measure_frequency(10, channel=4)\\\\\\\\\\\\\\\\nsignal_generator.disable_output(channel=4)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a resistance measurement with 100 ohms.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a resistance measurement. The multimeter will be set to measure resistance, a 100-ohm resistor will be connected, and the resistance will be measured.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nmultimeter.set_to_resistance()\\\\\\\\\\\\\\\\nmanager.connect_resistor(100)\\\\\\\\\\\\\\\\nresistance = multimeter.measure_resistance()\\\\\\\\\\\\\\\\nprint('Measured resistance:', resistance)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a jitter measurement on channel 5 with a peak-to-peak value of 10 ns.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a jitter measurement on channel 5. The oscilloscope will be set to measure jitter with a peak-to-peak value of 10 ns.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\noscilloscope.set_to_jitter(channel=5)\\\\\\\\\\\\\\\\nmanager.set_jitter_pp(10, channel=5)\\\\\\\\\\\\\\\\njitter = oscilloscope.measure_jitter()\\\\\\\\\\\\\\\\nprint('Measured jitter:', jitter)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a rise time measurement on channel 1 with 5 ms.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a rise time measurement on channel 1. The oscilloscope will be set to measure rise time with a value of 5 ms.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\noscilloscope.set_to_rise_time(channel=1)\\\\\\\\\\\\\\\\nmanager.set_rise_time(5, channel=1)\\\\\\\\\\\\\\\\nrise_time = oscilloscope.measure_rise_time()\\\\\\\\\\\\\\\\nprint('Measured rise time:', rise_time)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a fall time measurement on channel 2 with 5 ms.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a fall time measurement on channel 2. The oscilloscope will be set to measure fall time with a value of 5 ms.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\noscilloscope.set_to_fall_time(channel=2)\\\\\\\\\\\\\\\\nmanager.set_fall_time(5, channel=2)\\\\\\\\\\\\\\\\nfall_time = oscilloscope.measure_fall_time()\\\\\\\\\\\\\\\\nprint('Measured fall time:', fall_time)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a Bit Error Rate (BER) measurement with a bit sequence 10101010.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a Bit Error Rate (BER) measurement. The bit sequence 10101010 is sent, and the received bit sequence is checked for errors.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nmanager.send_bit_sequence('10101010')\\\\\\\\\\\\\\\\nber = manager.measure_ber('10101010')\\\\\\\\\\\\\\\\nprint('Measured BER:', ber)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a power measurement on channel 3 with 5 Watts.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a power measurement on channel 3. The power meter will be set to 5 Watts, the output will be enabled, the power will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\npower_meter.set_power(5, channel=3)\\\\\\\\\\\\\\\\npower_meter.enable_output(channel=3)\\\\\\\\\\\\\\\\nmanager.measure_power(5, channel=3)\\\\\\\\\\\\\\\\npower_meter.disable_output(channel=3)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform an impedance measurement with 50 Ohms.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs an impedance measurement. The multimeter will be set to measure impedance, a 50-ohm load will be connected, and the impedance will be measured.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nmultimeter.set_to_impedance()\\\\\\\\\\\\\\\\nmanager.connect_load(50)\\\\\\\\\\\\\\\\nimpedance = multimeter.measure_impedance()\\\\\\\\\\\\\\\\nprint('Measured impedance:', impedance)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a voltage peak-to-peak measurement on channel 1 with 5 V.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a voltage peak-to-peak measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the voltage will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\npower_supply.set_voltage(5, channel=1)\\\\\\\\\\\\\\\\npower_supply.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_voltage_pp(5, channel=1)\\\\\\\\\\\\\\\\npower_supply.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a current peak-to-peak measurement on channel 2 with 2 A.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a current peak-to-peak measurement on channel 2. The digital power supply will be set to 2 A, the output will be enabled, the current will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\npower_supply.set_current(2, channel=2)\\\\\\\\\\\\\\\\npower_supply.enable_output(channel=2)\\\\\\\\\\\\\\\\nmanager.measure_current_pp(2, channel=2)\\\\\\\\\\\\\\\\npower_supply.disable_output(channel=2)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a pulse width measurement on channel 1 with 5 ms.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a pulse width measurement on channel 1. The pulse generator will be set to 5 ms, the output will be enabled, the pulse width will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\npulse_generator.set_pulse_width(5, channel=1)\\\\\\\\\\\\\\\\npulse_generator.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_pulse_width(5, channel=1)\\\\\\\\\\\\\\\\npulse_generator.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a phase shift measurement between channels 1 and 2.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a phase shift measurement between channels 1 and 2. The oscilloscope will be set to measure phase shift, and the phase shift will be measured.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\noscilloscope.set_to_phase_shift()\\\\\\\\\\\\\\\\nphase_shift = oscilloscope.measure_phase_shift(channel1=1, channel2=2)\\\\\\\\\\\\\\\\nprint('Measured phase shift:', phase_shift)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a duty cycle measurement on channel 1 with 50%.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a duty cycle measurement on channel 1. The signal generator will be set to a duty cycle of 50%, the output will be enabled, the duty cycle will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nsignal_generator.set_duty_cycle(50, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_duty_cycle(50, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a Signal to Noise Ratio (SNR) measurement with a signal of 5 V and noise of 0.5 V.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a Signal to Noise Ratio (SNR) measurement. The signal of 5 V and noise of 0.5 V is set, and the SNR is measured.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nmanager.set_signal_and_noise(signal=5, noise=0.5)\\\\\\\\\\\\\\\\nsnr = manager.measure_snr()\\\\\\\\\\\\\\\\nprint('Measured SNR:', snr)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a voltage RMS measurement on channel 1 with 5 V.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a voltage RMS measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the RMS voltage will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\npower_supply.set_voltage(5, channel=1)\\\\\\\\\\\\\\\\npower_supply.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_voltage_rms(5, channel=1)\\\\\\\\\\\\\\\\npower_supply.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a current RMS measurement on channel 2 with 2 A.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a current RMS measurement on channel 2. The digital power supply will be set to 2 A, the output will be enabled, the RMS current will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\npower_supply.set_current(2, channel=2)\\\\\\\\\\\\\\\\npower_supply.enable_output(channel=2)\\\\\\\\\\\\\\\\nmanager.measure_current_rms(2, channel=2)\\\\\\\\\\\\\\\\npower_supply.disable_output(channel=2)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a power factor measurement on channel 1.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a power factor measurement on channel 1. The power meter will be set to measure power factor on channel 1.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\npower_meter.set_to_power_factor(channel=1)\\\\\\\\\\\\\\\\npower_factor = power_meter.measure_power_factor()\\\\\\\\\\\\\\\\nprint('Measured power factor:', power_factor)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a Total Harmonic Distortion (THD) measurement on channel 1.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a Total Harmonic Distortion (THD) measurement on channel 1. The spectrum analyzer will be set to measure THD on channel 1.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nspectrum_analyzer.set_to_thd(channel=1)\\\\\\\\\\\\\\\\nthd = spectrum_analyzer.measure_thd()\\\\\\\\\\\\\\\\nprint('Measured THD:', thd)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a signal amplitude measurement on channel 1 with 5 V.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a signal amplitude measurement on channel 1. The signal generator will be set to 5 V, the output will be enabled, the signal amplitude will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nsignal_generator.set_amplitude(5, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_signal_amplitude(5, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a latency measurement between channel 1 and channel 2.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a latency measurement between channel 1 and channel 2. The oscilloscope will be set to measure latency between the two channels.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\noscilloscope.set_to_latency()\\\\\\\\\\\\\\\\nlatency = oscilloscope.measure_latency(channel1=1, channel2=2)\\\\\\\\\\\\\\\\nprint('Measured latency:', latency)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a cross-correlation measurement between channel 1 and channel 2.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a cross-correlation measurement between channel 1 and channel 2. The oscilloscope will be set to measure cross-correlation between the two channels.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\noscilloscope.set_to_cross_correlation()\\\\\\\\\\\\\\\\ncross_correlation = oscilloscope.measure_cross_correlation(channel1=1, channel2=2)\\\\\\\\\\\\\\\\nprint('Measured cross-correlation:', cross_correlation)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform an attenuation measurement on channel 1 with 5 dB.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs an attenuation measurement on channel 1. The signal generator will be set to 5 dB, the output will be enabled, the attenuation will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nsignal_generator.set_attenuation(5, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_attenuation(5, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a bandwidth measurement on channel 1 with 5 MHz.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a bandwidth measurement on channel 1. The signal generator will be set to 5 MHz, the output will be enabled, the bandwidth will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nsignal_generator.set_bandwidth(5, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_bandwidth(5, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a gain measurement on channel 1 with 5 dB.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a gain measurement on channel 1. The signal generator will be set to 5 dB, the output will be enabled, the gain will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nsignal_generator.set_gain(5, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_gain(5, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a frequency response measurement on channel 1 from 1 Hz to 1 MHz.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a frequency response measurement on channel 1. The spectrum analyzer will be set from 1 Hz to 1 MHz, the frequency response will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nspectrum_analyzer.set_frequency_range(1, 1e6, channel=1)\\\\\\\\\\\\\\\\nfrequency_response = spectrum_analyzer.measure_frequency_response(channel=1)\\\\\\\\\\\\\\\\nprint('Measured frequency response:', frequency_response)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a delay measurement between channel 1 and channel 2 with 5 ms.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a delay measurement between channel 1 and channel 2. The oscilloscope will be set to measure delay, and the delay will be measured.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\noscilloscope.set_to_delay()\\\\\\\\\\\\\\\\ndelay = oscilloscope.measure_delay(channel1=1, channel2=2)\\\\\\\\\\\\\\\\nprint('Measured delay:', delay)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a power measurement on channel 1 with 5 W.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a power measurement on channel 1. The digital power supply will be set to 5 W, the output will be enabled, the power will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\npower_supply.set_power(5, channel=1)\\\\\\\\\\\\\\\\npower_supply.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_power(5, channel=1)\\\\\\\\\\\\\\\\npower_supply.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a modulation depth measurement on channel 1 with 50%.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a modulation depth measurement on channel 1. The signal generator will be set to 50%, the output will be enabled, the modulation depth will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nsignal_generator.set_modulation_depth(50, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_modulation_depth(50, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a peak to peak voltage measurement on channel 1 with 5 V.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a peak to peak voltage measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the peak to peak voltage will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\npower_supply.set_voltage(5, channel=1)\\\\\\\\\\\\\\\\npower_supply.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_peak_to_peak_voltage(5, channel=1)\\\\\\\\\\\\\\\\npower_supply.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a duty cycle measurement on channel 1 with 50%.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a duty cycle measurement on channel 1. The signal generator will be set to 50%, the output will be enabled, the duty cycle will be measured, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nsignal_generator.set_duty_cycle(50, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\\\\\\\\\nmanager.measure_duty_cycle(50, channel=1)\\\\\\\\\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Automate a temperature measurement on sensor 1 with 25 C.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command automates a temperature measurement on sensor 1. The digital thermometer will be set to 25 C, the measurement will be taken, and then the output will be disabled.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\nthermometer.set_temperature(25, sensor=1)\\\\\\\\\\\\\\\\nmanager.measure_temperature(25, sensor=1)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  },\\\\\\\\n  {\\\\\\\\n    \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Perform a phase shift measurement between channel 1 and channel 2 with 90 degrees.\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"command_with_explanation\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"This command performs a phase shift measurement between channel 1 and channel 2. The oscilloscope will be set to measure phase shift, and the phase shift will be measured.\\\\\\\\\\\\\\\\n```python\\\\\\\\\\\\\\\\noscilloscope.set_to_phase_shift()\\\\\\\\\\\\\\\\nphase_shift = oscilloscope.measure_phase_shift(channel1=1, channel2=2)\\\\\\\\\\\\\\\\nprint('Measured phase shift:', phase_shift)\\\\\\\\\\\\\\\\n```\\\\\\\\\\\\\\\"\\\\\\\\n  }\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"examples\\\\\\\\\\\\\\\\instrument_descrptions\\\\\\\\\\\\\\\\waveform_generator_description.py\\\\\\\": \\\\\\\"waveform_generator_description = {\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 1, \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 2},   # Channel 1 voltage range: 1 V to 2 V\\\\\\\\n        2: {\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 1, \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 2},   # Channel 2 voltage range: 1 V to 2 V\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"SINE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"SQUARE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TRIANGLE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"RAMP\\\\\\\\\\\\\\\"],  # Supported waveform types\\\\\\\\n}\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\errors.py\\\\\\\": \\\\\\\"class SCPIConnectionError(Exception):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"For SCPI instrument connection errors.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, message=\\\\\\\\\\\\\\\"Failed to connect to the instrument.\\\\\\\\\\\\\\\"):\\\\\\\\n        self.message = message\\\\\\\\n        super().__init__(self.message)\\\\\\\\n\\\\\\\\nclass SCPICommunicationError(Exception):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"For SCPI communication errors.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, message=\\\\\\\\\\\\\\\"Error in SCPI communication.\\\\\\\\\\\\\\\"):\\\\\\\\n        self.message = message\\\\\\\\n        super().__init__(self.message)\\\\\\\\n\\\\\\\\nclass SCPIValueError(ValueError):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"For invalid SCPI values or settings.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, message=\\\\\\\\\\\\\\\"Invalid value for SCPI command.\\\\\\\\\\\\\\\"):\\\\\\\\n        self.message = message\\\\\\\\n        super().__init__(self.message)\\\\\\\\n\\\\\\\\nclass InstrumentNotFoundError(Exception):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"For instrument not found errors.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, name):\\\\\\\\n        super().__init__(f\\\\\\\\\\\\\\\"Instrument {name} not found in the manager's collection.\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n\\\\\\\\nclass IntrumentConfigurationError(Exception):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"For instrument configuration errors.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, message=\\\\\\\\\\\\\\\"Invalid Instrument configuration.\\\\\\\\\\\\\\\"):\\\\\\\\n        self.message = message\\\\\\\\n        super().__init__(self.message)\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\MeasurementDatabase.py\\\\\\\": \\\\\\\"import sqlite3\\\\\\\\nimport time\\\\\\\\nimport numpy as np\\\\\\\\nfrom datetime import datetime\\\\\\\\nfrom dataclasses import dataclass\\\\\\\\nimport matplotlib.pyplot as plt\\\\\\\\n\\\\\\\\n@dataclass\\\\\\\\nclass Preamble:\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"A class to store the preamble data from the oscilloscope channel.\\\\\\\\n\\\\\\\\n    :param format: The format of the data\\\\\\\\n    :param type: The type of the data\\\\\\\\n    :param points: The number of points\\\\\\\\n    :param xinc: The x increment\\\\\\\\n    :param xorg: The x origin\\\\\\\\n    :param xref: The x reference\\\\\\\\n    :param yinc: The y increment\\\\\\\\n    :param yorg: The y origin\\\\\\\\n    :param yref: The y reference\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    format: str\\\\\\\\n    type: str\\\\\\\\n    points: int\\\\\\\\n    xinc: float\\\\\\\\n    xorg: float\\\\\\\\n    xref: float\\\\\\\\n    yinc: float\\\\\\\\n    yorg: float\\\\\\\\n    yref: float\\\\\\\\n\\\\\\\\nclass MeasurementValue:\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"A class to represent a single measurement value and its timestamp.\\\\\\\\n    \\\\\\\\n    Attributes:\\\\\\\\n        value (float): The measurement value.\\\\\\\\n        units (str): The units of the measurement value (e.g. \\\\\\\\\\\\\\\"V\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"A\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Ohm\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Hz\\\\\\\\\\\\\\\").\\\\\\\\n        timestamp (float): The timestamp when the measurement was taken.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    def __init__(self, value, units=\\\\\\\\\\\\\\\"units\\\\\\\\\\\\\\\", timestamp=None):\\\\\\\\n        self.value = float(value)\\\\\\\\n        self.units = units\\\\\\\\n        self.timestamp = timestamp if timestamp else time.time()\\\\\\\\n\\\\\\\\n    def __str__(self):\\\\\\\\n        return f\\\\\\\\\\\\\\\"{self.value}\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def __float__(self):\\\\\\\\n        return self.value\\\\\\\\n    \\\\\\\\nclass MeasurementResult:\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"A class to represent a collection of measurement values.\\\\\\\\n    \\\\\\\\n    Attributes:\\\\\\\\n        values (list): A list of MeasurementValue objects.\\\\\\\\n        units (str): The units of the measurements.\\\\\\\\n        instrument (str): The name of the instrument used for the measurements.\\\\\\\\n        measurement_type (str): The type of measurement.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    def __init__(self, instrument, units, measurement_type, sampling_rate=None, realtime_timestamps=False):\\\\\\\\n        self.values = []\\\\\\\\n        self.units = units\\\\\\\\n        self.instrument = instrument\\\\\\\\n        self.timestamp = time.time()\\\\\\\\n        self.realtime_timestamps = realtime_timestamps\\\\\\\\n        self.measurement_type = measurement_type\\\\\\\\n        self.sampling_rate = sampling_rate\\\\\\\\n\\\\\\\\n    def __str__(self):\\\\\\\\n        string = \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        for value in self.values:\\\\\\\\n            string += f\\\\\\\\\\\\\\\"{value} {self.units}\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        # remove last newline\\\\\\\\n        string = string[:-1]\\\\\\\\n        return string\\\\\\\\n    \\\\\\\\n    def __repr__(self):\\\\\\\\n        return str(self)\\\\\\\\n    \\\\\\\\n    def add(self, value):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Adds a new MeasurementValue to the collection.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        ## append to numpy array\\\\\\\\n        if value.units != self.units and self.units != \\\\\\\\\\\\\\\"units\\\\\\\\\\\\\\\" and value.units != \\\\\\\\\\\\\\\"units\\\\\\\\\\\\\\\":\\\\\\\\n            raise ValueError(\\\\\\\\\\\\\\\"MeasurementValue units must match MeasurementResult units.\\\\\\\\\\\\\\\")\\\\\\\\n        self.values = np.append(self.values, value)\\\\\\\\n\\\\\\\\n    def set_values(self, values):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Sets the MeasurementValues in the collection.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self.values = values\\\\\\\\n\\\\\\\\n    def get(self, index):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Gets the MeasurementValue at a specified index.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        return self.values[index]\\\\\\\\n\\\\\\\\n    def get_all(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Returns all the MeasurementValues in the collection.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        return self.values\\\\\\\\n\\\\\\\\n    def clear(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Clears all the MeasurementValues from the collection.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self.values.clear()\\\\\\\\n    \\\\\\\\n    def plot(self, title=None, xlabel=None, ylabel=None):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Generates a plot of the measurement values.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            title (str, optional): The title of the plot.\\\\\\\\n            xlabel (str, optional): The label for the x-axis.\\\\\\\\n            ylabel (str, optional): The label for the y-axis.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        timestamps = [value.timestamp for value in self.values]\\\\\\\\n        measurements = [value.value for value in self.values]\\\\\\\\n        \\\\\\\\n        plt.figure(figsize=(10, 5))\\\\\\\\n        if self.realtime_timestamps:\\\\\\\\n            plt.plot(timestamps, measurements, marker='o')\\\\\\\\n        else:\\\\\\\\n            plt.plot(measurements, marker='o')\\\\\\\\n        if title:\\\\\\\\n            plt.title(title)\\\\\\\\n        \\\\\\\\n        xlabel = xlabel if xlabel else \\\\\\\\\\\\\\\"Time (s)\\\\\\\\\\\\\\\"\\\\\\\\n        ylabel = ylabel if ylabel else f\\\\\\\\\\\\\\\"Measurement ({self.units})\\\\\\\\\\\\\\\"\\\\\\\\n        \\\\\\\\n        plt.xlabel(xlabel)\\\\\\\\n        plt.ylabel(ylabel)\\\\\\\\n        plt.grid(True)\\\\\\\\n        plt.show()\\\\\\\\n\\\\\\\\n    def perform_fft(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Performs FFT on the measurement values and returns a MeasurementResult object\\\\\\\\n        for the frequency spectrum.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            MeasurementResult: An object with frequencies as its measurement values.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        # check if is a time-domain measurement\\\\\\\\n        if self.measurement_type == \\\\\\\\\\\\\\\"Frequency Spectrum\\\\\\\\\\\\\\\":\\\\\\\\n            raise ValueError(\\\\\\\\\\\\\\\"Cannot perform FFT on Frequency Spectrum measurement.\\\\\\\\\\\\\\\")\\\\\\\\n        if self.sampling_rate is None:\\\\\\\\n            raise ValueError(\\\\\\\\\\\\\\\"Sampling rate must be set to perform FFT.\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        # Extract the measurement values and convert them to a numpy array\\\\\\\\n        data = np.array([value.value for value in self.values])\\\\\\\\n\\\\\\\\n        # Perform the FFT\\\\\\\\n        fft_result = np.fft.fft(data)\\\\\\\\n\\\\\\\\n        # Compute the frequency bins\\\\\\\\n        freq = np.fft.fftfreq(len(fft_result), 1 / self.sampling_rate)\\\\\\\\n\\\\\\\\n        # Calculate the magnitudes\\\\\\\\n        magnitudes = np.abs(fft_result)\\\\\\\\n\\\\\\\\n\\\\\\\\n        # Create a new MeasurementResult for the FFT results\\\\\\\\n        fft_measurement_result = MeasurementResult(\\\\\\\\n            instrument=self.instrument,\\\\\\\\n            units=self.units,\\\\\\\\n            measurement_type=\\\\\\\\\\\\\\\"Frequency Spectrum\\\\\\\\\\\\\\\",\\\\\\\\n            sampling_rate=self.sampling_rate,  #  for reference\\\\\\\\n            realtime_timestamps=self.realtime_timestamps\\\\\\\\n        )\\\\\\\\n\\\\\\\\n        # Populate the FFT MeasurementResult with frequency and magnitude pairs\\\\\\\\n        for f, magnitude in zip(freq, magnitudes):\\\\\\\\n            fft_measurement_value = MeasurementValue(value=magnitude)\\\\\\\\n            # Normally we would set the timestamp to the frequency value\\\\\\\\n            # Misuse the timestamp here for plotting purposes\\\\\\\\n            fft_measurement_value.timestamp = f\\\\\\\\n            fft_measurement_result.add(fft_measurement_value)\\\\\\\\n\\\\\\\\n        return fft_measurement_result\\\\\\\\n    \\\\\\\\n    def __len__(self):\\\\\\\\n        return len(self.values)\\\\\\\\n\\\\\\\\n    def __getitem__(self, index):\\\\\\\\n        return self.values[index]\\\\\\\\n\\\\\\\\n    def __iter__(self):\\\\\\\\n        return iter(self.values)\\\\\\\\n\\\\\\\\n    def __delitem__(self, index):\\\\\\\\n        del self.values[index]\\\\\\\\n\\\\\\\\nclass MeasurementDatabase:\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    A class for managing a SQLite database that stores measurement results.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    def __init__(self, db_path):\\\\\\\\n        self.db_path = db_path\\\\\\\\n        self._create_tables()\\\\\\\\n\\\\\\\\n    def _create_tables(self):\\\\\\\\n        with self._get_connection() as conn:\\\\\\\\n            conn.execute('''\\\\\\\\n                CREATE TABLE IF NOT EXISTS instruments (\\\\\\\\n                    instrument_id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\\\\\n                    name TEXT NOT NULL UNIQUE\\\\\\\\n                )\\\\\\\\n            ''')\\\\\\\\n            conn.execute('''\\\\\\\\n                CREATE TABLE IF NOT EXISTS measurements (\\\\\\\\n                    measurement_id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\\\\\n                    instrument_id INTEGER NOT NULL,\\\\\\\\n                    timestamp TIMESTAMP NOT NULL,\\\\\\\\n                    value REAL NOT NULL,\\\\\\\\n                    units TEXT NOT NULL,\\\\\\\\n                    type TEXT NOT NULL, -- 'reading' or 'fft'\\\\\\\\n                    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id)\\\\\\\\n                )\\\\\\\\n            ''')\\\\\\\\n\\\\\\\\n    def _get_connection(self):\\\\\\\\n        return sqlite3.connect(self.db_path)\\\\\\\\n\\\\\\\\n    def store_reading(self, measurement_result: MeasurementResult):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Stores a time-domain measurement result in the database.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        with self._get_connection() as conn:\\\\\\\\n            # Get or create the instrument_id\\\\\\\\n            instrument_id = self._get_or_create_instrument_id(conn, measurement_result.instrument)\\\\\\\\n\\\\\\\\n            # Store each MeasurementValue\\\\\\\\n            for measurement in measurement_result:\\\\\\\\n                conn.execute('''\\\\\\\\n                    INSERT INTO measurements (instrument_id, timestamp, value, units, type)\\\\\\\\n                    VALUES (?, ?, ?, ?, ?)\\\\\\\\n                ''', (instrument_id, datetime.fromtimestamp(measurement.timestamp),\\\\\\\\n                      measurement.value, measurement_result.units, 'reading'))\\\\\\\\n\\\\\\\\n    def store_fft_result(self, fft_result: MeasurementResult):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Stores an FFT measurement result in the database.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        with self._get_connection() as conn:\\\\\\\\n            # Get or create the instrument_id\\\\\\\\n            instrument_id = self._get_or_create_instrument_id(conn, fft_result.instrument)\\\\\\\\n\\\\\\\\n            # Store each FFT result (frequency, magnitude)\\\\\\\\n            for measurement in fft_result:\\\\\\\\n                # Assuming timestamp field is reused to store frequency\\\\\\\\n                conn.execute('''\\\\\\\\n                    INSERT INTO measurements (instrument_id, timestamp, value, units, type)\\\\\\\\n                    VALUES (?, ?, ?, ?, ?)\\\\\\\\n                ''', (instrument_id, measurement.timestamp, measurement.value,\\\\\\\\n                      fft_result.units, 'fft'))\\\\\\\\n\\\\\\\\n    def _get_or_create_instrument_id(self, conn, instrument_name):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Retrieves the instrument ID for the given name, or creates it if it doesn't exist.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        cursor = conn.execute('SELECT instrument_id FROM instruments WHERE name = ?', (instrument_name,))\\\\\\\\n        result = cursor.fetchone()\\\\\\\\n        if result:\\\\\\\\n            return result[0]\\\\\\\\n        else:\\\\\\\\n            cursor.execute('INSERT INTO instruments (name) VALUES (?)', (instrument_name,))\\\\\\\\n            return cursor.lastrowid\\\\\\\\n\\\\\\\\n    def retrieve_measurements(self, instrument_name, measurement_type):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Retrieves measurements from the database by instrument name and measurement type.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        with self._get_connection() as conn:\\\\\\\\n            cursor = conn.execute('''\\\\\\\\n                SELECT m.timestamp, m.value, m.units\\\\\\\\n                FROM measurements m\\\\\\\\n                JOIN instruments i ON m.instrument_id = i.instrument_id\\\\\\\\n                WHERE i.name = ? AND m.type = ?\\\\\\\\n            ''', (instrument_name, measurement_type))\\\\\\\\n            return cursor.fetchall()\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\utilities.py\\\\\\\": \\\\\\\"import time\\\\\\\\nfrom pytestlab.errors import InstrumentNotFoundError, SCPIConnectionError, SCPICommunicationError, SCPIValueError\\\\\\\\n\\\\\\\\ndef delay(seconds):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Pauses the program for the given number of seconds.\\\\\\\\n    \\\\\\\\n    Args:\\\\\\\\n        seconds (float): Time to pause in seconds.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    time.sleep(seconds)\\\\\\\\n\\\\\\\\ndef validate_visa_resource(visa_resource):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Validates the VISA resource string format.\\\\\\\\n    \\\\\\\\n    Args:\\\\\\\\n        visa_resource (str): The VISA resource string.\\\\\\\\n        \\\\\\\\n    Raises:\\\\\\\\n        ValueError: If the VISA resource string is in an invalid format.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    if not visa_resource.startswith(\\\\\\\\\\\\\\\"TCPIP0::\\\\\\\\\\\\\\\"):\\\\\\\\n        raise ValueError(\\\\\\\\\\\\\\\"Invalid VISA resource format. Please use TCPIP0::<IP_ADDRESS>::INSTR format for LAN instruments.\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\ndef check_connection(instrument):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Checks if the instrument connection is active.\\\\\\\\n    \\\\\\\\n    Args:\\\\\\\\n        instrument (object): The instrument object to check the connection for.\\\\\\\\n        \\\\\\\\n    Raises:\\\\\\\\n        SCPIConnectionError: If unable to connect to the instrument.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    try:\\\\\\\\n        response = instrument._query(\\\\\\\\\\\\\\\"*IDN?\\\\\\\\\\\\\\\")\\\\\\\\n        if response:\\\\\\\\n            print(\\\\\\\\\\\\\\\"Connection to the instrument is active.\\\\\\\\\\\\\\\")\\\\\\\\n    except Exception as e:\\\\\\\\n        raise SCPIConnectionError()\\\\\\\\n\\\\\\\\nclass InstrumentCollection:\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"A class to manage a collection of instruments.\\\\\\\\n    \\\\\\\\n    Attributes:\\\\\\\\n        instruments (dict): A dictionary to store instrument objects by their names.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    def __init__(self):\\\\\\\\n        self.instruments = {}\\\\\\\\n\\\\\\\\n    def add(self, name, instrument):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Adds an instrument to the collection.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self.instruments[name] = instrument\\\\\\\\n\\\\\\\\n    def get(self, name):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Gets an instrument by its name.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if name in self.instruments:\\\\\\\\n            return self.instruments[name]\\\\\\\\n        else:\\\\\\\\n            raise InstrumentNotFoundError(name)\\\\\\\\n\\\\\\\\n    # ... (continue with the remaining methods in the same manner)\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\__init__.py\\\\\\\": \\\\\\\"\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\instruments\\\\\\\\\\\\\\\\AutoInstrument.py\\\\\\\": \\\\\\\"from pytestlab.instruments.Oscilloscope import Oscilloscope, DigitalOscilloscopeWithJitter\\\\\\\\nfrom pytestlab.instruments.DigitalMultimeter import DigitalMultimeter\\\\\\\\nfrom pytestlab.instruments.WaveformGenerator import WaveformGenerator\\\\\\\\nfrom pytestlab.instruments.DigitalPowerSupply import DigitalPowerSupply\\\\\\\\nfrom pytestlab.errors import InstrumentConfigurationError\\\\\\\\n\\\\\\\\ndef AutoInstrument(profile):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    Automatically instantiate and return an instrument object based on a given profile.\\\\\\\\n\\\\\\\\n    Args:\\\\\\\\n        profile (dict): A dictionary profile containing information about the instrument to be created. \\\\\\\\n                            The dictionary should contain a \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\" key with a string value \\\\\\\\n                            specifying the type of the device (\\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"digital_multimeter\\\\\\\\\\\\\\\", \\\\\\\\n                            \\\\\\\\\\\\\\\"waveform_generator\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"digital_power_supply\\\\\\\\\\\\\\\"). \\\\\\\\n                            Additional will be required depending on the device type.\\\\\\\\n                            \\\\\\\\n    Returns:\\\\\\\\n        Object: An instance of the corresponding instrument class, initialized based on the profile.\\\\\\\\n\\\\\\\\n    Raises:\\\\\\\\n        InstrumentConfigurationError: If the device type is not recognized or missing in the profile.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    match profile[\\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\"]:\\\\\\\\n        case \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\":\\\\\\\\n            if profile[\\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\"]:\\\\\\\\n                return DigitalOscilloscopeWithJitter(profile[\\\\\\\\\\\\\\\"visa_resource\\\\\\\\\\\\\\\"], profile)\\\\\\\\n            else:\\\\\\\\n                return Oscilloscope(profile[\\\\\\\\\\\\\\\"visa_resource\\\\\\\\\\\\\\\"], profile)\\\\\\\\n        case \\\\\\\\\\\\\\\"digital_multimeter\\\\\\\\\\\\\\\":\\\\\\\\n            return DigitalMultimeter(profile[\\\\\\\\\\\\\\\"visa_resource\\\\\\\\\\\\\\\"], profile)\\\\\\\\n        case \\\\\\\\\\\\\\\"waveform_generator\\\\\\\\\\\\\\\":\\\\\\\\n            return WaveformGenerator(profile[\\\\\\\\\\\\\\\"visa_resource\\\\\\\\\\\\\\\"], profile)\\\\\\\\n        case \\\\\\\\\\\\\\\"digital_power_supply\\\\\\\\\\\\\\\":\\\\\\\\n            return DigitalPowerSupply(profile[\\\\\\\\\\\\\\\"visa_resource\\\\\\\\\\\\\\\"], profile)\\\\\\\\n        case _:\\\\\\\\n            raise InstrumentConfigurationError()\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\instruments\\\\\\\\\\\\\\\\DigitalMultimeter.py\\\\\\\": \\\\\\\"from pytestlab.instruments.instrument import SCPIInstrument, SCPIConnectionError, SCPICommunicationError\\\\\\\\n\\\\\\\\nclass DigitalMultimeter(SCPIInstrument):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    A class representing a Digital Multimeter that inherits from the SCPIInstrument class.\\\\\\\\n\\\\\\\\n    Provides methods for measuring voltage, current, resistance, frequency, and testing continuity.\\\\\\\\n\\\\\\\\n    Attributes:\\\\\\\\n        visa_resource (str): The VISA address of the device.\\\\\\\\n        description (dict): A dictionary containing additional information about the device, including supported channels.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, visa_resource, description):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Initializes a DigitalMultimeter instance.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            visa_resource (str): The VISA address of the device.\\\\\\\\n            description (dict): A dictionary containing additional information about the device.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        super().__init__(visa_resource)\\\\\\\\n        self.description = description\\\\\\\\n\\\\\\\\n    def measure_voltage(self, channel=1):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Measures the DC voltage on the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int, optional): The channel number. Default is 1.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            float: The measured voltage.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If an invalid channel is specified.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if channel not in self.description[\\\\\\\\\\\\\\\"voltage_channels\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid voltage channel {channel}. Supported voltage channels: {self.description['voltage_channels']}\\\\\\\\\\\\\\\")\\\\\\\\n        voltage = self._query(f\\\\\\\\\\\\\\\"MEASURE:VOLTAGE:DC? (@{channel})\\\\\\\\\\\\\\\")\\\\\\\\n        return float(voltage)\\\\\\\\n\\\\\\\\n    def measure_current(self, channel=1):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Measures the DC current on the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int, optional): The channel number. Default is 1.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            float: The measured current.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If an invalid channel is specified.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if channel not in self.description[\\\\\\\\\\\\\\\"current_channels\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid current channel {channel}. Supported current channels: {self.description['current_channels']}\\\\\\\\\\\\\\\")\\\\\\\\n        current = self._query(f\\\\\\\\\\\\\\\"MEASURE:CURRENT:DC? (@{channel})\\\\\\\\\\\\\\\")\\\\\\\\n        return float(current)\\\\\\\\n\\\\\\\\n    def measure_resistance(self, channel=1):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Measures the resistance on the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int, optional): The channel number. Default is 1.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            float: The measured resistance.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If an invalid channel is specified.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if channel not in self.description[\\\\\\\\\\\\\\\"resistance_channels\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid resistance channel {channel}. Supported resistance channels: {self.description['resistance_channels']}\\\\\\\\\\\\\\\")\\\\\\\\n        resistance = self._query(f\\\\\\\\\\\\\\\"MEASURE:RESISTANCE? (@{channel})\\\\\\\\\\\\\\\")\\\\\\\\n        return float(resistance)\\\\\\\\n\\\\\\\\n    def measure_frequency(self, channel=1):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Measures the frequency on the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int, optional): The channel number. Default is 1.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            float: The measured frequency.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If an invalid channel is specified.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if channel not in self.description[\\\\\\\\\\\\\\\"frequency_channels\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid frequency channel {channel}. Supported frequency channels: {self.description['frequency_channels']}\\\\\\\\\\\\\\\")\\\\\\\\n        frequency = self._query(f\\\\\\\\\\\\\\\"MEASURE:FREQUENCY? (@{channel})\\\\\\\\\\\\\\\")\\\\\\\\n        return float(frequency)\\\\\\\\n\\\\\\\\n    def test_continuity(self, channel=1):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Tests for electrical continuity on the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int, optional): The channel number. Default is 1.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            bool: True if continuity is present, False otherwise.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If an invalid channel is specified.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if channel not in self.description[\\\\\\\\\\\\\\\"continuity_channels\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid continuity channel {channel}. Supported continuity channels: {self.description['continuity_channels']}\\\\\\\\\\\\\\\")\\\\\\\\n        continuity = self._query(f\\\\\\\\\\\\\\\"TEST:CONTINUITY? (@{channel})\\\\\\\\\\\\\\\")\\\\\\\\n        return bool(int(continuity))  # Assuming continuity returns 1 for True and 0 for False\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\instruments\\\\\\\\\\\\\\\\DigitalPowerSupply.py\\\\\\\": \\\\\\\"from pytestlab.instruments.instrument import SCPIInstrument\\\\\\\\nfrom pytestlab.errors import SCPICommunicationError\\\\\\\\n\\\\\\\\nclass DigitalPowerSupply(SCPIInstrument):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    A class representing a Digital Power Supply that inherits from the SCPIInstrument class.\\\\\\\\n\\\\\\\\n    Provides methods for setting voltage and current, and for enabling or disabling the output.\\\\\\\\n\\\\\\\\n    Attributes:\\\\\\\\n        visa_resource (str): The VISA address of the device.\\\\\\\\n        description (dict): A dictionary containing additional information about the device.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, visa_resource, description):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Initializes a DigitalPowerSupply instance.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            visa_resource (str): The VISA address of the device.\\\\\\\\n            description (dict): A dictionary containing additional information about the device.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        super().__init__(visa_resource)\\\\\\\\n        self.description = description\\\\\\\\n\\\\\\\\n    def set_voltage(self, voltage, channel=1):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the voltage for the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            voltage (float): The voltage value to set.\\\\\\\\n            channel (int, optional): The channel number. Default is 1.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_channel_range(channel, voltage, \\\\\\\\\\\\\\\"voltage\\\\\\\\\\\\\\\")\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"VOLTAGE{channel} {voltage}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_current(self, current, channel=1):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the current for the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            current (float): The current value to set.\\\\\\\\n            channel (int, optional): The channel number. Default is 1.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_channel_range(channel, current, \\\\\\\\\\\\\\\"current\\\\\\\\\\\\\\\")\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"CURRENT{channel} {current}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def enable_output(self, channel=1):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Enables the output for the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int, optional): The channel number. Default is 1.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"OUTPUT{channel} ON\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def disable_output(self, channel=1):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Disables the output for the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int, optional): The channel number. Default is 1.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"OUTPUT{channel} OFF\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\instruments\\\\\\\\\\\\\\\\instrument.py\\\\\\\": \\\\\\\"import numpy as np\\\\\\\\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError\\\\\\\\nfrom pyscpi import usbtmc\\\\\\\\nimport time\\\\\\\\n\\\\\\\\nclass SCPIInstrument:\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    A class representing an SCPI-compliant instrument.\\\\\\\\n\\\\\\\\n    Attributes:\\\\\\\\n        visa_resource (str): The VISA resource string that identifies the instrument.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Initialize the SCPIInstrument class.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            visa_resource (str): The VISA resource string to use for the connection.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if visa_resource:\\\\\\\\n            self.visa_resource = visa_resource\\\\\\\\n            self._connect()\\\\\\\\n        elif \\\\\\\\\\\\\\\"vendor_id\\\\\\\\\\\\\\\" in profile and \\\\\\\\\\\\\\\"product_id\\\\\\\\\\\\\\\" in profile:\\\\\\\\n            self.instrument = usbtmc.Instrument(profile[\\\\\\\\\\\\\\\"vendor_id\\\\\\\\\\\\\\\"], profile[\\\\\\\\\\\\\\\"product_id\\\\\\\\\\\\\\\"])\\\\\\\\n        else:\\\\\\\\n            raise ValueError(\\\\\\\\\\\\\\\"Either a VISA resource string or a vendor and product ID must be provided.\\\\\\\\\\\\\\\")\\\\\\\\n        self.profile = profile\\\\\\\\n        self._command_log = []\\\\\\\\n        self.debug_mode = debug_mode\\\\\\\\n\\\\\\\\n    def _connect(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Connect to the instrument using the VISA resource string.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        try:\\\\\\\\n            import pyvisa\\\\\\\\n            self.instrument = pyvisa.ResourceManager().open_resource(self.visa_resource)\\\\\\\\n        except Exception as e:\\\\\\\\n            raise SCPIConnectionError(f\\\\\\\\\\\\\\\"Failed to connect to the instrument: {str(e)}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def _read_to_np(self) -> bytes:\\\\\\\\n        chunk_size = 1024\\\\\\\\n        data = self.instrument.read_raw(chunk_size)\\\\\\\\n        np.frombuffer(data[10:], dtype=np.uint8)\\\\\\\\n        header = data[2:10].decode('utf-8')\\\\\\\\n        data = np.frombuffer(data[10:], dtype=np.uint8)\\\\\\\\n        self._log(header)\\\\\\\\n\\\\\\\\n        hpoints = int(header)\\\\\\\\n\\\\\\\\n        while len(data) < hpoints:\\\\\\\\n            data = np.append(data, np.frombuffer(\\\\\\\\n                self.instrument.read_raw(chunk_size), dtype=np.uint8))\\\\\\\\n\\\\\\\\n        return data[:-1]\\\\\\\\n\\\\\\\\n    def _send_command(self, command):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Send an SCPI command to the instrument.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            command (str): The SCPI command to send.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            SCPICommunicationError: If sending the command fails.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        try:\\\\\\\\n            self.instrument.write(command)\\\\\\\\n            self._command_log.append({\\\\\\\\\\\\\\\"command\\\\\\\\\\\\\\\": command, \\\\\\\\\\\\\\\"success\\\\\\\\\\\\\\\": True, \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"write\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"timestamp\\\\\\\\\\\\\\\":time.time})\\\\\\\\n        except Exception as e:\\\\\\\\n            raise SCPICommunicationError(f\\\\\\\\\\\\\\\"Failed to send command: {str(e)}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def _query(self, query):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Query the instrument and return the response.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            query (str): The SCPI query to send.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            str: The instrument's response to the query.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            SCPICommunicationError: If the query fails.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        try:\\\\\\\\n            response =  self.instrument.query(query)\\\\\\\\n            print(response)\\\\\\\\n            self._command_log.append({\\\\\\\\\\\\\\\"command\\\\\\\\\\\\\\\": query, \\\\\\\\\\\\\\\"success\\\\\\\\\\\\\\\": True, \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"timestamp\\\\\\\\\\\\\\\":time.time})\\\\\\\\n            self.instrument.query(\\\\\\\\\\\\\\\"*OPC?\\\\\\\\\\\\\\\")\\\\\\\\n            return response\\\\\\\\n        except Exception as e:\\\\\\\\n            self._command_log.append({\\\\\\\\\\\\\\\"command\\\\\\\\\\\\\\\": query, \\\\\\\\\\\\\\\"success\\\\\\\\\\\\\\\": False, \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"query\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"timestamp\\\\\\\\\\\\\\\":time.time})\\\\\\\\n            raise SCPICommunicationError(f\\\\\\\\\\\\\\\"Failed to query instrument: {str(e)}\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n    def _wait(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Blocks until all previous commands have been processed by the instrument.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self.instrument.query(\\\\\\\\\\\\\\\"*OPC?\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def _log(self, message):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Log a message.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            message (str): The message to log.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if self.debug_mode:\\\\\\\\n            print(message)\\\\\\\\n\\\\\\\\n    def _history(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Prints history of executed commands\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        for command in self._command_log:\\\\\\\\n            print(command)\\\\\\\\n    def id(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Query the instrument for its identification.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            str: The identification string of the instrument.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        return self._query(\\\\\\\\\\\\\\\"*IDN?\\\\\\\\\\\\\\\")\\\\\\\\n    \\\\\\\\n    def _check_valid_channel(self, selected_channel):\\\\\\\\n        valid_channels = self.profile[\\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\"].keys()\\\\\\\\n        min_limit = min(valid_channels)\\\\\\\\n        max_limit = max(valid_channels)\\\\\\\\n        assert isinstance(selected_channel, int), f\\\\\\\\\\\\\\\"Channel must be an integer. Received: {selected_channel}\\\\\\\\\\\\\\\"\\\\\\\\n        assert selected_channel in valid_channels, f\\\\\\\\\\\\\\\"Invalid Channel Selected: {selected_channel}. Available Channels: {min_limit} to {max_limit}\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def close(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Close the connection to the instrument.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self.instrument.close()\\\\\\\\n\\\\\\\\n    def reset(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Reset the instrument to its default settings.\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._send_command(\\\\\\\\\\\\\\\"*RST\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_channel_voltage(self, channel, voltage):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Set the voltage for a specific channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int or str): The channel for which to set the voltage.\\\\\\\\n            voltage (float): The voltage value to set.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_valid_channel(channel)\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"CHAN{channel}:VOLT {voltage}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def get_channel_voltage(self, channel):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Get the voltage for a specific channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int or str): The channel for which to get the voltage.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            float: The voltage value for the channel.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_valid_channel(channel)\\\\\\\\n        response = self._query(f\\\\\\\\\\\\\\\"CHAN{channel}:VOLT?\\\\\\\\\\\\\\\")\\\\\\\\n        return float(response)\\\\\\\\n\\\\\\\\n    def measure_frequency(self, channel):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Measure the frequency for a specific channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int or str): The channel for which to measure the frequency.\\\\\\\\n\\\\\\\\n        Returns:\\\\\\\\n            float: The measured frequency value for the channel.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_valid_channel(channel)\\\\\\\\n        response = self._query(f\\\\\\\\\\\\\\\"MEAS:FREQ? CHAN{channel}\\\\\\\\\\\\\\\")\\\\\\\\n        return float(response)\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\instruments\\\\\\\\\\\\\\\\InstrumentManager.py\\\\\\\": \\\\\\\"import time\\\\\\\\nfrom pytestlab import InstrumentCollection\\\\\\\\n\\\\\\\\nclass InstrumentManager:\\\\\\\\n    def __init__(self):\\\\\\\\n        self.instrument_collection = InstrumentCollection()\\\\\\\\n\\\\\\\\n    # Instrument management methods\\\\\\\\n    def add_instrument(self, name, instrument):\\\\\\\\n        # Add an instrument to the manager's collection\\\\\\\\n        self.instrument[name] = instrument\\\\\\\\n\\\\\\\\n    def remove_instrument(self, name):\\\\\\\\n        # Remove an instrument from the manager's collection\\\\\\\\n        del self.instruments[name]\\\\\\\\n\\\\\\\\n    def get_instrument(self, name):\\\\\\\\n        # Get an instrument from the manager's collection\\\\\\\\n        return self.instruments[name]\\\\\\\\n\\\\\\\\n    def list_instruments(self):\\\\\\\\n        # List all instruments currently added to the manager\\\\\\\\n        print(self.instrument_collection)\\\\\\\\n\\\\\\\\n    def disconnect_all_instruments(self):\\\\\\\\n        # Disconnect all instruments in the manager's collection\\\\\\\\n        for i in self.instruments:\\\\\\\\n            self.instruments[i].close()\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def is_all_instruments_connected(self):\\\\\\\\n        # Check if all instruments are connected\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def is_instrument_connected(self, name):\\\\\\\\n        # Check if a specific instrument is connected\\\\\\\\n        pass\\\\\\\\n    # Measurement methods\\\\\\\\n    def measure_voltage(self, voltage, channel=1):\\\\\\\\n        # Perform a voltage measurement\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def measure_current(self, current, channel=1):\\\\\\\\n        # Perform a current measurement\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def measure_power(self, power, channel=1):\\\\\\\\n        # Perform a power measurement\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def measure_eye_diagram(self, test_pattern, voltage=1.0, current=0.5, channel=1, eye_duration=0.1):\\\\\\\\n        power_supply = self.instrument_collection[\\\\\\\\\\\\\\\"power_supply\\\\\\\\\\\\\\\"]\\\\\\\\n        oscilloscope = self.instrument_collection[\\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\"]\\\\\\\\n        pattern_generator = self.instrument_collection[\\\\\\\\\\\\\\\"pattern_generator\\\\\\\\\\\\\\\"]\\\\\\\\n\\\\\\\\n        power_supply.set_voltage(voltage, channel)\\\\\\\\n        power_supply.set_current(current, channel)\\\\\\\\n        power_supply.enable_output(channel)\\\\\\\\n\\\\\\\\n        pattern_generator.load_pattern(test_pattern)\\\\\\\\n        pattern_generator.enable_output()\\\\\\\\n\\\\\\\\n        oscilloscope.set_channel(channel)\\\\\\\\n        oscilloscope.start_measurement()\\\\\\\\n\\\\\\\\n        # Wait for the test pattern to stabilize and the oscilloscope to capture data\\\\\\\\n        time.sleep(eye_duration)\\\\\\\\n\\\\\\\\n        oscilloscope.stop_measurement()\\\\\\\\n        data = oscilloscope.get_measurement_data()\\\\\\\\n\\\\\\\\n        power_supply.disable_output()\\\\\\\\n        pattern_generator.disable_output()\\\\\\\\n\\\\\\\\n        #Data needs to be processed to generate Eye Diagram by frontend\\\\\\\\n        # eye_diagram = process_eye_data(data)\\\\\\\\n        return data\\\\\\\\n        # return eye_diagram\\\\\\\\n\\\\\\\\n    def perform_s21_measurement(self, frequency, power_level, channel=1, measurement_time=0.1):\\\\\\\\n        signal_generator = self.instrument_collection[\\\\\\\\\\\\\\\"signal_generator\\\\\\\\\\\\\\\"]\\\\\\\\n        vna = self.instrument_collection[\\\\\\\\\\\\\\\"vna\\\\\\\\\\\\\\\"]\\\\\\\\n\\\\\\\\n        signal_generator.set_frequency(frequency)\\\\\\\\n        signal_generator.set_power_level(power_level)\\\\\\\\n        signal_generator.enable_output()\\\\\\\\n\\\\\\\\n        vna.set_channel(channel)\\\\\\\\n        vna.set_frequency(frequency)\\\\\\\\n        vna.set_power_level(power_level)\\\\\\\\n        vna.set_s_parameter(\\\\\\\\\\\\\\\"S21\\\\\\\\\\\\\\\")\\\\\\\\n        vna.start_measurement()\\\\\\\\n\\\\\\\\n        # Wait for the measurement to stabilize and complete\\\\\\\\n        time.sleep(measurement_time)\\\\\\\\n\\\\\\\\n        s21_result = vna.get_measurement_data(\\\\\\\\\\\\\\\"S21\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        signal_generator.disable_output()\\\\\\\\n        vna.stop_measurement()\\\\\\\\n\\\\\\\\n        return s21_result\\\\\\\\n\\\\\\\\n        \\\\\\\\n    # Calibration methods\\\\\\\\n    def calibrate_power_supply(self):\\\\\\\\n        # Calibrate the power supply\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def calibrate_oscilloscope(self):\\\\\\\\n        # Calibrate the oscilloscope\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def calibrate_vna(self):\\\\\\\\n        # Calibrate the Vector Network Analyzer\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    # Data handling methods\\\\\\\\n    def save_measurement_data(self, data, file_name):\\\\\\\\n        # Save measurement data to a file\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def load_measurement_data(self, file_name):\\\\\\\\n        # Load measurement data from a file\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    # Instrument configuration methods\\\\\\\\n    def configure_power_supply(self, settings):\\\\\\\\n        # Configure power supply settings (e.g., voltage limits, current limits)\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def configure_oscilloscope(self, settings):\\\\\\\\n        # Configure oscilloscope settings (e.g., timebase, trigger settings)\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def configure_vna(self, settings):\\\\\\\\n        # Configure Vector Network Analyzer settings (e.g., frequency range, calibration)\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    # Additional utility methods as needed\\\\\\\\n    def check_instrument_compatibility(self):\\\\\\\\n        # Check if the connected instruments are compatible for the planned measurements\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def perform_full_system_check(self):\\\\\\\\n        # Perform a comprehensive system check before starting measurements\\\\\\\\n        pass\\\\\\\\n\\\\\\\\n    def report_system_status(self):\\\\\\\\n        # Generate a report on the status of connected instruments and overall system health\\\\\\\\n        pass\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\instruments\\\\\\\\\\\\\\\\Oscilloscope.py\\\\\\\": \\\\\\\"import time\\\\\\\\nfrom typing import List\\\\\\\\nfrom pytestlab.instruments.instrument import SCPIInstrument\\\\\\\\nfrom pytestlab.MeasurementDatabase import MeasurementResult, Preamble, MeasurementValue\\\\\\\\nfrom pytestlab.errors import SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\\\\\\\\nimport numpy as np\\\\\\\\nclass Oscilloscope(SCPIInstrument):\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    Provides an interface for controlling and acquiring data from an oscilloscope using SCPI commands.\\\\\\\\n\\\\\\\\n    This class inherits from SCPIInstrument and implements specific methods to interact with \\\\\\\\n    oscilloscope features such as voltage measurement and timebase scaling.\\\\\\\\n\\\\\\\\n    Attributes:\\\\\\\\n    visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\\\\\\\\n    profile (dict): Information about the instrument model.\\\\\\\\n    \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Initialize the Oscilloscope class with the given VISA resource and profile information.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\\\\\\\\n        profile (dict): Information about the instrument model.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        super().__init__(visa_resource=visa_resource, profile=profile, debug_mode=debug_mode)\\\\\\\\n        assert \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\" in self.profile, \\\\\\\\\\\\\\\"Oscilloscope model not specified in profile.\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n    def _read_preamble(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Reads the preamble from the oscilloscope.\\\\\\\\n\\\\\\\\n        :param inst: The instrument object from pyscpi or pyvisa\\\\\\\\n        :param debug: Print debug messages\\\\\\\\n        :return: A Preamble object\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        peram = self._query(':WAVeform:PREamble?')\\\\\\\\n        peram = peram.split(',')\\\\\\\\n        self._log(peram)\\\\\\\\n\\\\\\\\n        pre = Preamble(peram[0], peram[1], int(peram[2]), float(peram[4]), float(\\\\\\\\n            peram[5]), float(peram[6]), float(peram[7]), float(peram[8]), float(peram[9]))\\\\\\\\n\\\\\\\\n        return pre\\\\\\\\n\\\\\\\\n    def _read_wave_data(self, channel: int, points: int) -> np.ndarray:\\\\\\\\n\\\\\\\\n        self._wait()\\\\\\\\n        self._send_command(f':WAVeform:SOURce CHANnel{channel}')\\\\\\\\n        self._query('*OPC?')\\\\\\\\n        self._log('Reading channel ' + str(channel))\\\\\\\\n\\\\\\\\n        self._send_command(':WAVeform:FORMat BYTE')\\\\\\\\n        self._send_command(':WAVeform:POINts:MODE MAXimum')\\\\\\\\n\\\\\\\\n        self._log('Reading points')\\\\\\\\n\\\\\\\\n        if points > 0:\\\\\\\\n            self._send_command(f':WAVeform:POINts {points}')\\\\\\\\n        else:\\\\\\\\n            self._send_command(':WAVeform:POINts MAXimum')\\\\\\\\n\\\\\\\\n        self._wait()\\\\\\\\n\\\\\\\\n        self._log('Reading data')\\\\\\\\n\\\\\\\\n        self._send_command(':WAVeform:DATA?')\\\\\\\\n        data = self._read_to_np()\\\\\\\\n\\\\\\\\n        return data\\\\\\\\n    \\\\\\\\n    def auto_scale(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Auto scale the oscilloscope display.\\\\\\\\n        \\\\\\\\n        This method sends an SCPI command to the oscilloscope to auto scale the display.\\\\\\\\n        \\\\\\\\n        Example:\\\\\\\\n        >>> auto_scale()\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._send_command(\\\\\\\\\\\\\\\":AUToscale\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_time_axis(self, scale: float, position: float) -> None:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the time axis of the Oscilloscope. (x-axis)\\\\\\\\n\\\\\\\\n        :param scale: scale The scale of the axis in seconds \\\\\\\\n        :param position: The position of the time axis from the trigger in seconds\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    \\\\\\\\n        self._send_command(f':TIMebase:SCALe {scale}')\\\\\\\\n        self._send_command(f':TIMebase:POSition {position}')\\\\\\\\n        self._wait()\\\\\\\\n    \\\\\\\\n    def set_channel_axis(self, channel: int, scale: float, offset: float) -> None:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the channel axis of the oscilloscope. (y-axis)\\\\\\\\n\\\\\\\\n        :param channel: The channel to set\\\\\\\\n        :param scale: The scale of the channel axis in volts\\\\\\\\n        :param offset: The offset of the channel in volts\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._send_command(f':CHANnel{channel}:SCALe {scale}')\\\\\\\\n        self._send_command(f':CHANnel{channel}:OFFSet {offset}')\\\\\\\\n        self._wait()\\\\\\\\n        \\\\\\\\n    def measure_voltage_peak_to_peak(self, channel):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Measure the peak-to-peak voltage for a specified channel.\\\\\\\\n        \\\\\\\\n        This method sends an SCPI query to the oscilloscope to measure the peak-to-peak voltage \\\\\\\\n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\\\\\\\\n        \\\\\\\\n        Returns:\\\\\\\\n        MeasurementResult: An object containing the peak-to-peak voltage measurement for the specified channel.\\\\\\\\n        \\\\\\\\n        Example:\\\\\\\\n        >>> measure_voltage_peak_to_peak(\\\\\\\\\\\\\\\"CH1\\\\\\\\\\\\\\\")\\\\\\\\n        <MeasurementResult object at 0x7f1ec2a4f510>\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_valid_channel(channel)\\\\\\\\n\\\\\\\\n\\\\\\\\n        measurement_result = MeasurementResult(self.profile[\\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\"], \\\\\\\\\\\\\\\"V\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"peak to peak voltage\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        response = self._query(f\\\\\\\\\\\\\\\"MEAS:VPP? CHAN{channel}\\\\\\\\\\\\\\\")\\\\\\\\n        measurement_result.add(response)\\\\\\\\n        return measurement_result\\\\\\\\n\\\\\\\\n    def measure_rms_voltage(self, channel: int) -> MeasurementResult:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Measure the root-mean-square (RMS) voltage for a specified channel.\\\\\\\\n        \\\\\\\\n        This method sends an SCPI query to the oscilloscope to measure the RMS voltage \\\\\\\\n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\\\\\\\\n        \\\\\\\\n        Returns:\\\\\\\\n        MeasurementResult: An object containing the RMS voltage measurement for the specified channel.\\\\\\\\n        \\\\\\\\n        Example:\\\\\\\\n        >>> measure_rms_voltage(\\\\\\\\\\\\\\\"CH1\\\\\\\\\\\\\\\")\\\\\\\\n        <MeasurementResult object at 0x7f1ec2a4f590>\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        #Error Handling\\\\\\\\n        self._check_valid_channel(channel)\\\\\\\\n\\\\\\\\n\\\\\\\\n        measurement_result = MeasurementResult(self.profile[\\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\"], \\\\\\\\\\\\\\\"V\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"rms voltage\\\\\\\\\\\\\\\")\\\\\\\\n        response = self._query(f\\\\\\\\\\\\\\\"MEAS:VRMS? CHAN{channel}\\\\\\\\\\\\\\\")\\\\\\\\n        measurement_result.add(response)\\\\\\\\n        return measurement_result\\\\\\\\n\\\\\\\\n    def read_channels(self, channels: List[int], points=10000, runAfter=True, timebase=None):\\\\\\\\n        if timebase is not None:\\\\\\\\n            self.set_timebase_scale(timebase)\\\\\\\\n\\\\\\\\n        self._log(points)\\\\\\\\n        self._log(\\\\\\\\\\\\\\\"starting\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        for channel in channels:\\\\\\\\n            self._check_valid_channel(channel)\\\\\\\\n\\\\\\\\n        # Prepare the MeasurementResult dictionary\\\\\\\\n        sampling_rate = float(self.get_sampling_rate())\\\\\\\\n        measurement_results = {channel: MeasurementResult(instrument=f\\\\\\\\\\\\\\\"{self.profile['manufacturer']}:{self.profile['model']}\\\\\\\\\\\\\\\", units=\\\\\\\\\\\\\\\"V\\\\\\\\\\\\\\\", measurement_type=\\\\\\\\\\\\\\\"Voltage\\\\\\\\\\\\\\\", sampling_rate=sampling_rate, realtime_timestamps=True)\\\\\\\\n                            for channel in channels}\\\\\\\\n\\\\\\\\n        # Setup and digitize commands\\\\\\\\n        channel_commands = ', '.join(f\\\\\\\\\\\\\\\"CHANnel{channel}\\\\\\\\\\\\\\\" for channel in channels)\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"DIGitize {channel_commands}\\\\\\\\\\\\\\\")\\\\\\\\n        self._send_command(f':WAVeform:SOURce CHANnel{channels[0]}')\\\\\\\\n\\\\\\\\n        # Read preamble to get scaling factors\\\\\\\\n        pream = self._read_preamble()\\\\\\\\n\\\\\\\\n        # Prepare the time axis once, as it is the same for all channels\\\\\\\\n        time_values = (np.arange(0, pream.points, 1) - pream.xref) * pream.xinc + pream.xorg\\\\\\\\n\\\\\\\\n        for i, channel in enumerate(channels):\\\\\\\\n            data = self._read_wave_data(channel, points)\\\\\\\\n            if len(data) != pream.points:\\\\\\\\n                print('ERROR: points mismatch, please investigate')\\\\\\\\n\\\\\\\\n            # Calculate the voltage values\\\\\\\\n            voltages = (data - pream.yref) * pream.yinc + pream.yorg\\\\\\\\n\\\\\\\\n            # Populate the MeasurementResult object for this channel\\\\\\\\n            for voltage, time_val in zip(voltages, time_values):\\\\\\\\n                measurement_results[channel].add(MeasurementValue(voltage, timestamp=time_val))\\\\\\\\n\\\\\\\\n        if runAfter:\\\\\\\\n            self._send_command(\\\\\\\\\\\\\\\":RUN\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        return measurement_results\\\\\\\\n    \\\\\\\\n    # def set_probe_attenuation(self, channel, attenuation):\\\\\\\\n    #     \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    #     Sets the probe attenuation for a given channel.\\\\\\\\n\\\\\\\\n    #     \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    #     self._check_valid_channel(channel)\\\\\\\\n    #     # Set the probe attenuation for the specified channel\\\\\\\\n    #     self._send_command(f\\\\\\\\\\\\\\\"CHANnel{channel}:PROBe {attenuation}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def get_sampling_rate(self):\\\\\\\\n        # Send the SCPI command to query the current sampling rate\\\\\\\\n        response = self._query(\\\\\\\\\\\\\\\":ACQuire:SRATe?\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n        # Parse the response to get the sampling rate value.\\\\\\\\n        sampling_rate = float(response)\\\\\\\\n        \\\\\\\\n        return MeasurementValue(sampling_rate, \\\\\\\\\\\\\\\"Hz\\\\\\\\\\\\\\\")\\\\\\\\n    \\\\\\\\n    def set_probe_scale(self, channel, scale):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the probe scale for a given channel.\\\\\\\\n\\\\\\\\n        Parameters:\\\\\\\\n            channel (int): The oscilloscope channel to set the scale for.\\\\\\\\n            scale (float): The probe scale value (e.g., 10.0 for 10:1, 1.0 for 1:1).\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_valid_channel(channel)\\\\\\\\n\\\\\\\\n        # The command format is hypothetical and needs to be adjusted \\\\\\\\n        # to match the specific oscilloscope command set.\\\\\\\\n        command = f\\\\\\\\\\\\\\\":PROBe:CH{channel}:ATTenuation {scale}\\\\\\\\\\\\\\\"\\\\\\\\n        self._send_command(command)\\\\\\\\n\\\\\\\\n        # Confirm the action to the log\\\\\\\\n        self._log(f\\\\\\\\\\\\\\\"Set probe scale to {scale}:1 for channel {channel}.\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_timebase_scale(self, scale):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Set the timebase scale of the oscilloscope.\\\\\\\\n        \\\\\\\\n        This method sends an SCPI command to adjust the timebase scale on the oscilloscope display.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        scale (float): The timebase scale in seconds per division.\\\\\\\\n        \\\\\\\\n        Example:\\\\\\\\n        >>> set_timebase_scale(0.002)\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"TIM:SCAL {scale}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def get_timebase_scale(self):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Retrieve the current timebase scale setting from the oscilloscope.\\\\\\\\n        \\\\\\\\n        This method sends an SCPI query to get the current timebase scale and encapsulates \\\\\\\\n        the result into a MeasurementResult object.\\\\\\\\n        \\\\\\\\n        Returns:\\\\\\\\n        MeasurementResult: An object containing the current timebase scale setting.\\\\\\\\n        \\\\\\\\n        Example:\\\\\\\\n        >>> get_timebase_scale()\\\\\\\\n        <MeasurementResult object at 0x7f1ec2a4f650>\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        measurement_result = MeasurementResult(self.profile[\\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\"], \\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"timebase scale\\\\\\\\\\\\\\\")\\\\\\\\n        response = self._query(\\\\\\\\\\\\\\\"TIM:SCAL?\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        measurement_result.add(response)\\\\\\\\n        return measurement_result\\\\\\\\n\\\\\\\\n    def set_acquisition_time(self, time):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Set the total acquisition time for the oscilloscope.\\\\\\\\n\\\\\\\\n        ARGS;\\\\\\\\n            time (float): The total acquisition time in seconds.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        # Set the total time for acquisition\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\":TIMebase:MAIN:RANGe {time}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_sample_rate(self, rate):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the sample rate for the oscilloscope.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n        rate (str): The desired sample rate. Valid values are 'MAX' and 'AUTO'.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        rate = rate.upper()\\\\\\\\n        valid_values = [\\\\\\\\\\\\\\\"MAX\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"AUTO\\\\\\\\\\\\\\\"]\\\\\\\\n        if rate not in valid_values:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid Valid: supported = {valid_values}\\\\\\\\\\\\\\\")\\\\\\\\n        # Set the sample rate for acquisition\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"ACQuire:SRATe {rate}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_bandwidth_limit(self, channel, bandwidth):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        \\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_valid_channel(channel)\\\\\\\\n        # Limit the bandwidth to a specified frequency to reduce noise\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"CHANnel{channel}:BANDwidth {bandwidth}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    # def set_filtering(self, channel, filter_type, frequency):\\\\\\\\n    #     self._check_valid_channel(channel)\\\\\\\\n    #     # Configure a filter on the channel to isolate the desired frequency components\\\\\\\\n    #     if self.profile[\\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\"][channel][\\\\\\\\\\\\\\\"filtering\\\\\\\\\\\\\\\"] != \\\\\\\\\\\\\\\"available\\\\\\\\\\\\\\\":\\\\\\\\n    #         raise ValueError(f\\\\\\\\\\\\\\\"Filtering is not available on Channel {channel}.\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n    #     if channel not in self.profile[\\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\"]:\\\\\\\\n    #         raise ValueError(f\\\\\\\\\\\\\\\"Invalid channel {channel}. Supported channels: {self.profile['channels']}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    #     self._send_command(f\\\\\\\\\\\\\\\"CHANnel{channel}:FILTer:{filter_type} {frequency}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_trigger(self, channel, trigger_level):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the trigger level for a given channel.\\\\\\\\n\\\\\\\\n        Parameters:\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_valid_channel(channel)\\\\\\\\n        # Set the trigger level for the specified channel\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"TRIGger:LEVel CHANnel{channel},{trigger_level}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    # def set_trigger_mode(self, mode):\\\\\\\\n    #     \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        \\\\\\\\n    #     \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    #     if mode not in self.profile[\\\\\\\\\\\\\\\"trigger_modes\\\\\\\\\\\\\\\"]:\\\\\\\\n    #         raise ValueError(f\\\\\\\\\\\\\\\"Invalid trigger mode {mode}. Supported trigger modes: {self.profile['trigger_modes']}\\\\\\\\\\\\\\\")\\\\\\\\n    #     # Set the trigger mode to either edge or pulse\\\\\\\\n    #     self._send_command(f\\\\\\\\\\\\\\\"TRIGger:MODE {mode}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_trigger_source(self, channel):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        \\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._check_valid_channel(channel)\\\\\\\\n        # Set the trigger source to the specified channel\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"TRIGger:SOURce CHANnel{channel}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    # def set_trigger_edge_slope(self, slope):\\\\\\\\n    #     \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n    #     # Set the edge slope to either rising or falling\\\\\\\\n    #     self._send_command(f\\\\\\\\\\\\\\\"TRIGger:EDGE:SLOPe {slope}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    # def set_trigger_pulse_polarity(self, polarity):\\\\\\\\n    #     # Set the pulse polarity to either positive or negative\\\\\\\\n    #     self._send_command(f\\\\\\\\\\\\\\\"TRIGger:PULSe:POLarity {polarity}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    # def set_trigger_pulse_width(self, width):\\\\\\\\n    #     # Set the pulse width to the specified value\\\\\\\\n    #     self._send_command(f\\\\\\\\\\\\\\\"TRIGger:PULSe:WIDth {width}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    # def set_trigger_pulse_delay(self, delay):\\\\\\\\n    #     # Set the pulse delay to the specified value\\\\\\\\n    #     self._send_command(f\\\\\\\\\\\\\\\"TRIGger:PULSe:DELay {delay}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    # def set_trigger_pulse_transition(self, transition):\\\\\\\\n    #     # Set the pulse transition to either positive or negative\\\\\\\\n    #     self._send_command(f\\\\\\\\\\\\\\\"TRIGger:PULSe:TRANsition {transition}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    # def set_trigger_pulse_condition(self, condition):\\\\\\\\n    #     # Set the pulse condition to either width or delay\\\\\\\\n    #     self._send_command(f\\\\\\\\\\\\\\\"TRIGger:PULSe:CONdition {condition}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def wave_gen(self, state: bool):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Enable or disable the waveform generator of the oscilloscope.\\\\\\\\n\\\\\\\\n        This method sends an SCPI command to enable or disable the function generator in the oscilloscope.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        state (str): The desired state ('ON' or 'OFF') for the waveform generator.\\\\\\\\n        \\\\\\\\n        Raises:\\\\\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\\\\\\\\n        \\\\\\\\n        Example:\\\\\\\\n        >>> set_wave_gen('ON')\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        # if state not in self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"]:\\\\\\\\n        #     raise ValueError(f\\\\\\\\\\\\\\\"Invalid state {state}. Supported states: {self.profile['function_generator']}\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"WGEN:OUTP {'ON' if state else 'OFF'}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_wave_gen_func(self, state):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Set the waveform function for the oscilloscope's waveform generator.\\\\\\\\n\\\\\\\\n        This method sends an SCPI command to change the function (e.g., 'SINE', 'SQUARE') of the waveform generator.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        state (str): The desired function ('SINE', 'SQUARE', etc.) for the waveform generator.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\\\\\\\\n\\\\\\\\n        Example:\\\\\\\\n        >>> set_wave_gen_func('SINE')\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        if state not in self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"waveform_types\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid state {state}. Supported states: {self.profile['function_generator']['waveform_types']}\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"WGEN:FUNC {state}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_wave_gen_freq(self, freq):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Set the frequency for the waveform generator.\\\\\\\\n\\\\\\\\n        This method sends an SCPI command to set the frequency of the waveform generator.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        freq (float): The desired frequency for the waveform generator in Hz.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the frequency is out of range.\\\\\\\\n\\\\\\\\n        Example:\\\\\\\\n        >>> set_wave_gen_freq(1000.0)\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        if freq < self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"frequency\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\"] or freq > self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"frequency\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"WGEN:FREQ {freq}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_wave_gen_amp(self, amp):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Set the amplitude for the waveform generator.\\\\\\\\n\\\\\\\\n        This method sends an SCPI command to set the amplitude of the waveform generator.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        amp (float): The desired amplitude for the waveform generator in volts.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the amplitude is out of range.\\\\\\\\n\\\\\\\\n        Example:\\\\\\\\n        >>> set_wave_gen_amp(1.0)\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        if amp < self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"amplitude\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\"] or amp > self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"amplitude\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"WGEN:VOLT {amp}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_wave_gen_offset(self, offset):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Set the voltage offset for the waveform generator.\\\\\\\\n\\\\\\\\n        This method sends an SCPI command to set the voltage offset of the waveform generator.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        offset (float): The desired voltage offset for the waveform generator in volts.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the offset is out of range.\\\\\\\\n\\\\\\\\n        Example:\\\\\\\\n        >>> set_wave_gen_offset(0.1)\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        if offset < self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"offset\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\"] or offset > self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"offset\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"WGEN:VOLT:OFFSet {offset}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_wgen_sin(self, amp: float, offset: float, freq: float) -> None:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Sets the waveform generator to a sine wave. (Only available on specific models)\\\\\\\\n\\\\\\\\n        :param amp: The amplitude of the sine wave in volts\\\\\\\\n        :param offset: The offset of the sine wave in volts\\\\\\\\n        :param freq: The frequency of the sine wave in Hz. The frequency can be adjusted from 100 mHz to 20 MHz.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        if offset < self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"offset\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\"] or offset > self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"offset\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\\\\\\\\\\\\\\\")\\\\\\\\n        if amp < self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"amplitude\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\"] or amp > self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"amplitude\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\\\\\\\\\\\\\\\")\\\\\\\\n        if freq < self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"frequency\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\"] or freq > self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"frequency\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        self._send_command('WGEN:FUNCtion SINusoid')\\\\\\\\n        self._send_command(f':WGEN:VOLTage {amp}')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\\\\\\\\n        self._send_command(f':WGEN:FREQuency {freq}')\\\\\\\\n\\\\\\\\n\\\\\\\\n    def set_wgen_square(self, v0: float, v1: float, freq: float, dutyCycle: int) -> None:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Sets the waveform generator to a square wave. (Only available on specific models)\\\\\\\\n\\\\\\\\n        :param v0: The voltage of the low state in volts\\\\\\\\n        :param v1: The voltage of the high state in volts\\\\\\\\n        :param freq: The frequency of the square wave in Hz. The frequency can be adjusted from 100 mHz to 10 MHz.\\\\\\\\n        :param dutyCycle: The duty cycle can be adjusted from 1% to 99% up to 500 kHz. At higher frequencies, the adjustment range narrows so as not to allow pulse widths less than 20 ns.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n        self._send_command('WGEN:FUNCtion SQUare')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\\\\\\\n        self._send_command(f':WGEN:FREQuency {freq}')\\\\\\\\n        self._send_command(f':WGEN:FUNCtion:SQUare:DCYCle {dutyCycle}')\\\\\\\\n\\\\\\\\n\\\\\\\\n    def set_wgen_ramp(self, v0: float, v1: float, freq: float, symmetry: int) -> None:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Sets the waveform generator to a ramp wave. (Only available on specific models)\\\\\\\\n\\\\\\\\n        :param v0: The voltage of the low state in volts\\\\\\\\n        :param v1: The voltage of the high state in volts\\\\\\\\n        :param freq: The frequency of the ramp wave in Hz. The frequency can be adjusted from 100 mHz to 100 kHz.\\\\\\\\n        :param symmetry: Symmetry represents the amount of time per cycle that the ramp waveform is rising and can be adjusted from 0% to 100%.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n        self._send_command('WGEN:FUNCtion RAMP')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\\\\\\\n        self._send_command(f':WGEN:FREQuency {freq}')\\\\\\\\n        self._send_command(f':WGEN:FUNCtion:RAMP:SYMMetry {symmetry}')\\\\\\\\n\\\\\\\\n\\\\\\\\n    def set_wgen_pulse(self, v0: float, v1: float, period: float, pulseWidth: float) -> None:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Sets the waveform generator to a pulse wave. (Only available on specific models)\\\\\\\\n\\\\\\\\n        :param v0: The voltage of the low state in volts\\\\\\\\n        :param v1: The voltage of the high state in volts\\\\\\\\n        :param period: The period of the pulse wave in seconds. The period can be adjusted from 10 ns to 10 s.\\\\\\\\n        :param pulseWidth: The pulse width can be adjusted from 20 ns to the period minus 20 ns.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        self._send_command('WGEN:FUNCtion PULSe')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\\\\\\\n        self._send_command(f':WGEN:PERiod {period}')\\\\\\\\n        self._send_command(f':WGEN:FUNCtion:PULSe:WIDTh {pulseWidth}')\\\\\\\\n\\\\\\\\n\\\\\\\\n    def set_wgen_dc(self, offset: float) -> None:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Sets the waveform generator to a DC wave. (Only available on specific models)\\\\\\\\n\\\\\\\\n        :param offset: The offset of the DC wave in volts\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        if offset < self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"offset\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\"] or offset > self.profile[\\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"offset\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\"]:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n        self._send_command('WGEN:FUNCtion DC')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\\\\\\\\n\\\\\\\\n\\\\\\\\n    def set_wgen_noise(self, v0: float, v1: float, offset: float) -> None:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"Sets the waveform generator to a noise wave. (Only available on specific models)\\\\\\\\n\\\\\\\\n        :param v0: The voltage of the low state in volts\\\\\\\\n        :param v1: The voltage of the high state in volts\\\\\\\\n        :param offset: The offset of the noise wave in volts\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        \\\\\\\\n        if \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\" not in self.profile:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n        self._send_command('WGEN:FUNCtion NOISe')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\\\\\\\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\\\\\\\\n\\\\\\\\n    def display_channel(self, channels, state=True) -> None:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Display the specified channels on the oscilloscope.\\\\\\\\n        \\\\\\\\n        This method sends an SCPI command to the oscilloscope to display the specified channels.\\\\\\\\n        \\\\\\\\n        Args:\\\\\\\\n        channels (list): A list of channels to display on the oscilloscope.\\\\\\\\n        \\\\\\\\n        Raises:\\\\\\\\n        ValueError: If the oscilloscope model does not support the specified channel(s).\\\\\\\\n        \\\\\\\\n        Example:\\\\\\\\n        >>> display_channel([\\\\\\\\\\\\\\\"CH1\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"CH2\\\\\\\\\\\\\\\"])\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        for channel in channels:\\\\\\\\n            self._check_valid_channel(channel)\\\\\\\\n        # Implement SCPI commands to display the specified channels\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"CHAN:{channels}:DISP {'ON' if state else 'OFF'}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n\\\\\\\\n    def fft_display(self, state=True):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Switches on the FFT display\\\\\\\\n\\\\\\\\n        :param state: The state of the FFT display\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        assert \\\\\\\\\\\\\\\"fft\\\\\\\\\\\\\\\" in self.profile, \\\\\\\\\\\\\\\"FFT is not available on this oscilloscope.\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\":FFT:DISPlay {'ON' if state else 'OFF'}\\\\\\\\\\\\\\\")\\\\\\\\n        self._log(f\\\\\\\\\\\\\\\"FFT display {'enabled' if state else 'disabled'}.\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def function_display(self, state=True):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Switches on the function display\\\\\\\\n\\\\\\\\n        :param state: The state of the function display\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        \\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\":FUNCtion:DISPlay {'ON' if state else 'OFF'}\\\\\\\\\\\\\\\")\\\\\\\\n        self._log(f\\\\\\\\\\\\\\\"Function display {'enabled' if state else 'disabled'}.\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def configure_fft(self, source_channel: int, scale: float = None, offset: float = None, window_type: str = 'HANNing', units: str = 'DECibel', display: bool = True):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Configure the oscilloscope to perform an FFT on the specified channel with the given parameters.\\\\\\\\n\\\\\\\\n        :param source_channel: The channel number to perform FFT on.\\\\\\\\n        :param scale: The scale of the FFT display in dB. Defaults to None.\\\\\\\\n        :param offset: The offset of the FFT display. Defaults to None.\\\\\\\\n        :param window_type: The windowing function to apply. Defaults to 'HANNing'.\\\\\\\\n        :param units: The unit of measurement for the FFT (DECibel or VRMS). Defaults to 'DECibel'.\\\\\\\\n        :param display: A boolean to turn the FFT display ON or OFF. Defaults to True.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        # Ensure the oscilloscope supports FFT and the specified channel is valid\\\\\\\\n        assert \\\\\\\\\\\\\\\"fft\\\\\\\\\\\\\\\" in self.profile, \\\\\\\\\\\\\\\"FFT is not available on this oscilloscope.\\\\\\\\\\\\\\\"\\\\\\\\n        assert source_channel in self.profile[\\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\"], f\\\\\\\\\\\\\\\"Invalid channel {source_channel}. Supported channels: {self.profile['channels']}\\\\\\\\\\\\\\\"\\\\\\\\n        assert window_type in self.profile[\\\\\\\\\\\\\\\"fft\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"window_types\\\\\\\\\\\\\\\"], f\\\\\\\\\\\\\\\"Invalid window type {window_type}. Supported window types: {self.profile['fft']['window_types']}\\\\\\\\\\\\\\\"\\\\\\\\n        assert units in self.profile[\\\\\\\\\\\\\\\"fft\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"units\\\\\\\\\\\\\\\"], f\\\\\\\\\\\\\\\"Invalid units {units}. Supported units: {self.profile['fft']['units']}\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        # Set the FFT source to the specified channel\\\\\\\\n        self._send_command(f':FFT:SOURce1 CHANnel{source_channel}')\\\\\\\\n        # Configure the FFT window type\\\\\\\\n        self._send_command(f':FFT:WINDow {window_type}')\\\\\\\\n        # Configure the FFT vertical type (units)\\\\\\\\n        self._send_command(f':FFT:VTYPe {units}')\\\\\\\\n        # Set the scale if provided\\\\\\\\n        if scale is not None:\\\\\\\\n            self._send_command(f':FFT:SCALe {scale}dB')\\\\\\\\n        # Set the offset if provided\\\\\\\\n        if offset is not None:\\\\\\\\n            self._send_command(f':FFT:OFFSet {offset}')\\\\\\\\n        # Turn the FFT display on or off based on the parameter\\\\\\\\n        display_state = '1' if display else '0'\\\\\\\\n        self._send_command(f':FFT:DISPlay {display_state}')\\\\\\\\n\\\\\\\\n        self._log(f\\\\\\\\\\\\\\\"FFT configured for channel {source_channel}.\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def _convert_binary_block_to_data(self, binary_block):\\\\\\\\n        # Process the binary data header to determine the size of the block\\\\\\\\n        header_len = int(binary_block[1])  # Assuming the length of the length field itself is 1 byte\\\\\\\\n        expected_data_points = int(binary_block[2:2+header_len])\\\\\\\\n\\\\\\\\n        # Use _read_to_np to read the binary data into a NumPy array\\\\\\\\n        data = self._read_to_np()\\\\\\\\n\\\\\\\\n        # Ensure that we've read the correct number of data points\\\\\\\\n        assert len(data) == expected_data_points, \\\\\\\\\\\\\\\"Data size mismatch\\\\\\\\\\\\\\\"\\\\\\\\n\\\\\\\\n        # Data is now in a NumPy array format and can be reshaped or processed as needed\\\\\\\\n        # For FRANalysis, the data often comes in pairs representing frequency and response (magnitude/phase)\\\\\\\\n        # so we need to reshape the array accordingly\\\\\\\\n        data_points_per_entry = 2  # Assuming each data point consists of a frequency and a corresponding value\\\\\\\\n        structured_data = data.reshape((-1, data_points_per_entry))\\\\\\\\n        \\\\\\\\n    def perform_franalysis(self, input_channel, output_channel, start_freq, stop_freq, points=1000, mode='SWEep'):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Perform a frequency response analysis on the oscilloscope.\\\\\\\\n\\\\\\\\n        :param input_channel: The channel number to use as the input.\\\\\\\\n        :param output_channel: The channel number to use as the output.\\\\\\\\n        :param start_freq: The start frequency of the analysis in Hz.\\\\\\\\n        :param stop_freq: The stop frequency of the analysis in Hz.\\\\\\\\n        :param points: The number of points to use for the analysis.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        # Validate input\\\\\\\\n        self._check_valid_channel(input_channel)\\\\\\\\n        self._check_valid_channel(output_channel)\\\\\\\\n        assert mode in ['SWEep', 'SINGle'], 'Mode should be \\\\\\\\\\\\\\\"SWEep\\\\\\\\\\\\\\\" or \\\\\\\\\\\\\\\"SINGle\\\\\\\\\\\\\\\"'\\\\\\\\n        assert 10 <= start_freq < stop_freq <= 20000000, 'Frequency range should be within 10 Hz to 20 MHz'\\\\\\\\n        assert points > 0, 'Number of points must be positive'\\\\\\\\n\\\\\\\\n        # Enable FRANalysis\\\\\\\\n        self._send_command(\\\\\\\\\\\\\\\":FRANalysis:ENABle 1\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        # Set the start and stop frequencies\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\":FRANalysis:FREQuency:STARt {start_freq}Hz\\\\\\\\\\\\\\\")\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\":FRANalysis:FREQuency:STOP {stop_freq}Hz\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        # Set the mode\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\":FRANalysis:FREQuency:MODE {mode}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        # If single frequency mode, set the single frequency, otherwise set points for sweep\\\\\\\\n        if mode == 'SINGle':\\\\\\\\n            self._send_command(f\\\\\\\\\\\\\\\":FRANalysis:FREQuency:SINGle {start_freq}Hz\\\\\\\\\\\\\\\")\\\\\\\\n        else:\\\\\\\\n            # Not directly provided in the command summary, assuming there's a command for points\\\\\\\\n            assert points > 0, 'Number of points must be positive'\\\\\\\\n            # TODO remove this hard-coded limit - only for DSOX1204G\\\\\\\\n            assert points <= 1000, 'Number of points must be less than 1000'\\\\\\\\n            self._send_command(f\\\\\\\\\\\\\\\":FRANalysis:SWEep:POINts {points}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        # Initiate FRANalysis\\\\\\\\n        self._send_command(\\\\\\\\\\\\\\\":FRANalysis:RUN\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        # Wait for analysis to complete and then read the data\\\\\\\\n        # The waiting mechanism is not detailed, assuming there's a method for it\\\\\\\\n        self._wait()\\\\\\\\n        # Read the FRANalysis data (binary block format)\\\\\\\\n        franalysis_data = self._query(\\\\\\\\\\\\\\\":FRANalysis:DATA?\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        # Process the binary block data into a structured format\\\\\\\\n        # Assuming a helper function to convert binary block to numerical data\\\\\\\\n        data = self._read_preamble()\\\\\\\\n        # data = self._convert_binary_block_to_data(franalysis_data)\\\\\\\\n\\\\\\\\n        # Disable FRANalysis after completion\\\\\\\\n        self._send_command(\\\\\\\\\\\\\\\":FRANalysis:ENABle 0\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        # Return the processed data\\\\\\\\n        return data\\\\\\\\n    \\\\\\\\n    def read_fft_data(self) -> MeasurementResult:\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Perform the FFT and read the data from the oscilloscope, returning it as a MeasurementResult.\\\\\\\\n\\\\\\\\n        :return: A MeasurementResult object containing the FFT data.\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._log('Initiating FFT data read.')\\\\\\\\n        \\\\\\\\n        # The oscilloscope setup for FFT should be done before calling this method\\\\\\\\n        # Make sure that the acquisition is already started or in continuous mode\\\\\\\\n        \\\\\\\\n        # Assuming :FUNCtion:DATA? returns the FFT data from the oscilloscope\\\\\\\\n        self._send_command(':FUNCtion:DATA?')\\\\\\\\n        fft_data = self._read_to_np()\\\\\\\\n        \\\\\\\\n        # Now, instead of just returning fft_data, we need to encapsulate it into MeasurementValue objects\\\\\\\\n        # and then add these to a MeasurementResult object.\\\\\\\\n\\\\\\\\n        # For this example, let's assume 'self.sampling_rate' is set and represents the sampling rate used for FFT\\\\\\\\n        if self.sampling_rate is None:\\\\\\\\n            raise ValueError(\\\\\\\\\\\\\\\"Sampling rate must be set to read FFT data.\\\\\\\\\\\\\\\")\\\\\\\\n        \\\\\\\\n        # Compute the frequency bins for the FFT data\\\\\\\\n        freq = np.fft.fftfreq(len(fft_data), 1 / self.sampling_rate)\\\\\\\\n        \\\\\\\\n        units = self._query(\\\\\\\\\\\\\\\":FFT:VTYPe?\\\\\\\\\\\\\\\")\\\\\\\\n        # Create a new MeasurementResult for the FFT results\\\\\\\\n        fft_measurement_result = MeasurementResult(\\\\\\\\n            instrument=self.instrument,  # Replace with actual attribute, if different\\\\\\\\n            units=units,  \\\\\\\\n            measurement_type=\\\\\\\\\\\\\\\"Frequency Spectrum\\\\\\\\\\\\\\\",\\\\\\\\n            sampling_rate=self.sampling_rate  # Including the sampling rate for reference\\\\\\\\n        )\\\\\\\\n        \\\\\\\\n        # Populate the MeasurementResult with MeasurementValue objects\\\\\\\\n        for f, magnitude in zip(freq, fft_data):\\\\\\\\n            fft_measurement_value = MeasurementValue(value=magnitude)\\\\\\\\n            # Normally, timestamp would be set to the time the measurement was taken\\\\\\\\n            # In this case, we can repurpose it to store the frequency, if that's acceptable for your design\\\\\\\\n            fft_measurement_value.timestamp = f\\\\\\\\n            fft_measurement_result.add(fft_measurement_value)\\\\\\\\n        \\\\\\\\n        return fft_measurement_result\\\\\\\\n\\\\\\\\n# class DigitalOscilloscopeWithJitter(Oscilloscope):\\\\\\\\n\\\\\\\\n#     def __init__(self, visa_resource, profile):\\\\\\\\n#         super().__init__(visa_resource, profile)\\\\\\\\n\\\\\\\\n#     def _available_jitter_measurements(self, jitter_type):\\\\\\\\n#         if jitter_type not in self.profile[\\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\"]:\\\\\\\\n#             raise ValueError(f\\\\\\\\\\\\\\\"Invalid jitter type {jitter_type}. Supported jitter types: {self.profile['jitter_analysis']}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n#     def setup_rms_jitter_measurement(self, channel):\\\\\\\\n#         self._available_jitter_measurements(\\\\\\\\\\\\\\\"rms\\\\\\\\\\\\\\\")\\\\\\\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\\\\\\\n#         self._send_command(f\\\\\\\\\\\\\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\\\\\\\\\\\\\")\\\\\\\\n#         self._send_command(\\\\\\\\\\\\\\\"MEASure:JITTer:MODE RMS\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n#     def setup_peak_to_peak_jitter_measurement(self, channel):\\\\\\\\n#         self._available_jitter_measurements(\\\\\\\\\\\\\\\"peak_to_peak\\\\\\\\\\\\\\\")\\\\\\\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\\\\\\\n#         self._send_command(f\\\\\\\\\\\\\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\\\\\\\\\\\\\")\\\\\\\\n#         self._send_command(\\\\\\\\\\\\\\\"MEASure:JITTer:MODE PK2PK\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n#     def setup_period_jitter_measurement(self, channel):\\\\\\\\n#         self._available_jitter_measurements(\\\\\\\\\\\\\\\"period\\\\\\\\\\\\\\\")\\\\\\\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\\\\\\\n#         self._send_command(f\\\\\\\\\\\\\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\\\\\\\\\\\\\")\\\\\\\\n#         self._send_command(\\\\\\\\\\\\\\\"MEASure:JITTer:MODE PERiod\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n#     def setup_cycle_to_cycle_jitter_measurement(self, channel):\\\\\\\\n#         self._available_jitter_measurements(\\\\\\\\\\\\\\\"cycle_to_cycle\\\\\\\\\\\\\\\")\\\\\\\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\\\\\\\n#         self._send_command(f\\\\\\\\\\\\\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\\\\\\\\\\\\\")\\\\\\\\n#         self._send_command(\\\\\\\\\\\\\\\"MEASure:JITTer:MODE CCYCle\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n#     def configure_trigger(self, trigger_source, trigger_level):\\\\\\\\n#         # Implement SCPI commands to configure trigger settings for jitter measurement\\\\\\\\n#         self._send_command(f\\\\\\\\\\\\\\\"TRIGger:SOURce CHANnel{trigger_source}\\\\\\\\\\\\\\\")\\\\\\\\n#         self._send_command(f\\\\\\\\\\\\\\\"TRIGger:LEVel CHANnel{trigger_source},{trigger_level}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n#     def acquire_jitter_data(self):\\\\\\\\n#         # Implement SCPI commands to acquire jitter data from the oscilloscope\\\\\\\\n#         self._send_command(\\\\\\\\\\\\\\\"ACQuire:STATE RUN\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n#     def analyze_jitter_data(self):\\\\\\\\n#         measurement_result = MeasurementResult(self.profile[\\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\"], \\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"jitter\\\\\\\\\\\\\\\")\\\\\\\\n#         jitter_value = self._query_command(\\\\\\\\\\\\\\\"MEASure:JITTer?\\\\\\\\\\\\\\\")\\\\\\\\n#         measurement_result.add_measurement(jitter_value)\\\\\\\\n#         return measurement_result\\\\\\\\n    \\\\\\\\n#     def perform_rms_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\\\\\\\n#         self.setup_rms_jitter_measurement(channel)\\\\\\\\n#         self.configure_trigger(trigger_source, trigger_level)\\\\\\\\n#         self.acquire_jitter_data()\\\\\\\\n#         return self.analyze_jitter_data()\\\\\\\\n    \\\\\\\\n#     def perform_peak_to_peak_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\\\\\\\n#         \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n#         Perform a peak-to-peak jitter measurement on a specified channel with given trigger settings.\\\\\\\\n        \\\\\\\\n#         This method sets up the measurement, configures the trigger, acquires the jitter data and \\\\\\\\n#         then analyzes the data to return a MeasurementResult object containing the results of \\\\\\\\n#         the jitter measurement.\\\\\\\\n        \\\\\\\\n#         Args:\\\\\\\\n#         channel (str/int): The identifier for the channel on which the measurement is to be performed.\\\\\\\\n#                         This could be an integer representing the channel number or a string representing\\\\\\\\n#                         the channel name, depending on the implementation.\\\\\\\\n#         trigger_source (str/int): The identifier for the trigger source. This could be an integer or a \\\\\\\\n#                                 string representing the source depending on the implementation.\\\\\\\\n#         trigger_level (float): The trigger level for the measurement in volts. This value sets the voltage \\\\\\\\n#                             level at which the trigger event occurs.\\\\\\\\n        \\\\\\\\n#         Returns:\\\\\\\\n#         MeasurementResult: An object containing the results of the peak-to-peak jitter measurement.\\\\\\\\n        \\\\\\\\n#         Raises:\\\\\\\\n#         NotImplementedError: If any of the method calls within this function (e.g., setup_peak_to_peak_jitter_measurement, \\\\\\\\n#                             configure_trigger, acquire_jitter_data, analyze_jitter_data) are not implemented.\\\\\\\\n#         MeasurementError: If there is an error during the measurement process.\\\\\\\\n        \\\\\\\\n#         Example:\\\\\\\\n#         >>> perform_peak_to_peak_jitter_measurement(\\\\\\\\\\\\\\\"CH1\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"External\\\\\\\\\\\\\\\", 0.5)\\\\\\\\n#         <MeasurementResult object at 0x7f9bd8134f50>\\\\\\\\n#         \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n#         self.setup_peak_to_peak_jitter_measurement(channel)\\\\\\\\n#         self.configure_trigger(trigger_source, trigger_level)\\\\\\\\n#         self.acquire_jitter_data()\\\\\\\\n#         return self.analyze_jitter_data()\\\\\\\\n\\\\\\\\n        \\\\\\\\n#     def perform_period_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\\\\\\\n#         self.setup_period_jitter_measurement(channel)\\\\\\\\n#         self.configure_trigger(trigger_source, trigger_level)\\\\\\\\n#         self.acquire_jitter_data()\\\\\\\\n#         return self.analyze_jitter_data()\\\\\\\\n\\\\\\\\n#     def perform_cycle_to_cycle_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\\\\\\\n#         self.setup_cycle_to_cycle_jitter_measurement(channel)\\\\\\\\n#         self.configure_trigger(trigger_source, trigger_level)\\\\\\\\n#         self.acquire_jitter_data()\\\\\\\\n#         return self.analyze_jitter_data()\\\\\\\\n        \\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\instruments\\\\\\\\\\\\\\\\WaveformGenerator.py\\\\\\\": \\\\\\\"from pytestlab.instruments.instrument import SCPIInstrument\\\\\\\\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\\\\\\\\nimport numpy as np\\\\\\\\n\\\\\\\\nclass WaveformGenerator(SCPIInstrument):\\\\\\\\n    def __init__(self, profile):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Initialize a WaveformGenerator instance with a device profile.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            profile (dict): A dictionary containing device profile information.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        super().__init__()\\\\\\\\n        self.profile = profile\\\\\\\\n\\\\\\\\n    def _validate_waveform(self, waveform_type):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Validate if the waveform type is supported by the device.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            waveform_type (str): The type of waveform to validate.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If the waveform type is not supported.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        standard_waveforms = [w.upper() for w in self.profile.get('waveforms', {}).get('standard', [])]\\\\\\\\n        if waveform_type.upper() not in standard_waveforms:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Invalid waveform type: {waveform_type}. Supported types: {standard_waveforms}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def _validate_frequency(self, frequency):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Validate if the frequency is within the device's supported range.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            frequency (float): The frequency to validate.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If the frequency is out of range.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        max_frequency = self.profile.get('max_frequency')\\\\\\\\n        if frequency > max_frequency:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Frequency out of range. Max supported frequency: {max_frequency}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def _validate_amplitude(self, amplitude):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Validate if the amplitude is within the device's supported range.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            amplitude (float): The amplitude to validate.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If the amplitude is out of range.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        min_amplitude = self.profile.get('amplitude', {}).get('min', 0)\\\\\\\\n        max_amplitude = self.profile.get('amplitude', {}).get('max', float('inf'))\\\\\\\\n        if not min_amplitude <= amplitude <= max_amplitude:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Amplitude out of range. Supported range: {min_amplitude} to {max_amplitude}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def _validate_offset(self, offset):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Validate if the offset is within the device's supported range.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            offset (float): The offset to validate.\\\\\\\\n\\\\\\\\n        Raises:\\\\\\\\n            ValueError: If the offset is out of range.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        min_offset = self.profile.get('dc_offset', {}).get('min', float('-inf'))\\\\\\\\n        max_offset = self.profile.get('dc_offset', {}).get('max', float('inf'))\\\\\\\\n        if not min_offset <= offset <= max_offset:\\\\\\\\n            raise ValueError(f\\\\\\\\\\\\\\\"Offset out of range. Supported range: {min_offset} to {max_offset}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_arbitrary_waveform(self, channel, waveform, scale=True):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the arbitrary waveform for the specified channel.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int or str): The channel for which to set the waveform.\\\\\\\\n            waveform (list): The arbitrary waveform to set.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._log(f\\\\\\\\\\\\\\\"Setting arbitrary waveform for channel {channel}\\\\\\\\\\\\\\\")\\\\\\\\n        waveform_np = np.array(waveform)\\\\\\\\n        awg_max_voltage = self.profile[\\\\\\\\\\\\\\\"amplitude\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\"]\\\\\\\\n        awg_min_voltage = self.profile[\\\\\\\\\\\\\\\"amplitude\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\"]\\\\\\\\n\\\\\\\\n        max_length = self.profile[\\\\\\\\\\\\\\\"waveforms\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"arbitrary\\\\\\\\\\\\\\\"][\\\\\\\\\\\\\\\"max_length\\\\\\\\\\\\\\\"]\\\\\\\\n        if scale:\\\\\\\\n            waveform_normalized = (waveform - np.min(waveform)) / (np.max(waveform) - np.min(waveform))\\\\\\\\n            waveform_scaled = waveform_normalized * (awg_max_voltage - awg_min_voltage) + awg_min_voltage\\\\\\\\n            waveform_np = np.array(waveform_scaled)\\\\\\\\n            self._log(f\\\\\\\\\\\\\\\"Waveform scaled to {awg_min_voltage} to {awg_max_voltage} V\\\\\\\\\\\\\\\")\\\\\\\\n            if len(waveform_np) > max_length:\\\\\\\\n                # squash into max_length by approximating\\\\\\\\n                waveform_np = waveform_np[::int(len(waveform_np) / max_length)] # TODO: improve this approximation\\\\\\\\n                self._log(f\\\\\\\\\\\\\\\"Waveform squashed to {max_length} samples\\\\\\\\\\\\\\\")\\\\\\\\n        else:\\\\\\\\n            self._log(f\\\\\\\\\\\\\\\"Waveform not scaled\\\\\\\\\\\\\\\")\\\\\\\\n            if len(waveform_np) > max_length:\\\\\\\\n                self._log(f\\\\\\\\\\\\\\\"Waveform length exceeds maximum length: {max_length}\\\\\\\\\\\\\\\")\\\\\\\\n                raise ValueError(f\\\\\\\\\\\\\\\"Waveform length exceeds maximum length: {max_length}\\\\\\\\\\\\\\\")\\\\\\\\n            if np.max(waveform_np) > awg_max_voltage or np.min(waveform_np) < awg_min_voltage:\\\\\\\\n                self._log(f\\\\\\\\\\\\\\\"Waveform exceeds amplitude range: {awg_min_voltage} to {awg_max_voltage}\\\\\\\\\\\\\\\")\\\\\\\\n                raise ValueError(f\\\\\\\\\\\\\\\"Waveform exceeds amplitude range: {awg_min_voltage} to {awg_max_voltage}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        binary_waveform = waveform_np.tobytes()\\\\\\\\n\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"SOURCE{channel}:DATA:VOL:CLEAR\\\\\\\\\\\\\\\")  # Clear the volatile memory\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"SOURCE{channel}:FUNCTION ARBITRAR\\\\\\\\\\\\\\\")  # Set the source to arbitrary waveform\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"SOURCE{channel}:DATA:ARB:DAC {binary_waveform}, (@1)\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n        self._log(f\\\\\\\\\\\\\\\"Waveform set\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_waveform(self, channel, waveform_type):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the waveform type for the specified channel after validation.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int or str): The channel for which to set the waveform.\\\\\\\\n            waveform_type (str): The type of waveform to set.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._validate_waveform(waveform_type)\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"SOUR{channel}:FUNC {waveform_type.upper()}\\\\\\\\\\\\\\\")\\\\\\\\n        self._log(f\\\\\\\\\\\\\\\"Waveform set to {waveform_type}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_frequency(self, channel, frequency):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the frequency for the specified channel after validation.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int or str): The channel for which to set the frequency.\\\\\\\\n            frequency (float): The frequency to set.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._validate_frequency(frequency)\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"SOUR{channel}:FREQ {frequency}\\\\\\\\\\\\\\\")\\\\\\\\n        self._log(f\\\\\\\\\\\\\\\"Frequency set to {frequency} Hz\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_amplitude(self, channel, amplitude):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the amplitude for the specified channel after validation.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int or str): The channel for which to set the amplitude.\\\\\\\\n            amplitude (float): The amplitude to set.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._validate_amplitude(amplitude)\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"SOUR{channel}:AMPL {amplitude}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n    def set_offset(self, channel, offset):\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        Sets the offset for the specified channel after validation.\\\\\\\\n\\\\\\\\n        Args:\\\\\\\\n            channel (int or str): The channel for which to set the offset.\\\\\\\\n            offset (float): The offset to set.\\\\\\\\n\\\\\\\\n        \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n        self._validate_offset(offset)\\\\\\\\n        self._send_command(f\\\\\\\\\\\\\\\"SOUR{channel}:OFFS {offset}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n# # Similar approach can be taken for PatternGenerator\\\\\\\\n# class PatternGenerator(SCPIInstrument):\\\\\\\\n#     def __init__(self, profile):\\\\\\\\n#         \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n#         Initialize a PatternGenerator instance with a device profile.\\\\\\\\n\\\\\\\\n#         Args:\\\\\\\\n#             profile (dict): A dictionary containing device profile information.\\\\\\\\n\\\\\\\\n#         \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n#         super().__init__()\\\\\\\\n#         self.profile = profile\\\\\\\\n\\\\\\\\n#     def _validate_pattern(self, pattern):\\\\\\\\n#         \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n#         Validate if the pattern is supported by the device.\\\\\\\\n\\\\\\\\n#         Args:\\\\\\\\n#             pattern (str): The type of pattern to validate.\\\\\\\\n\\\\\\\\n#         Raises:\\\\\\\\n#             ValueError: If the pattern is not supported.\\\\\\\\n\\\\\\\\n#         \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n#         standard_patterns = [p.upper() for p in self.profile.get('waveforms', {}).get('standard', [])]\\\\\\\\n#         if pattern.upper() not in standard_patterns:\\\\\\\\n#             raise ValueError(f\\\\\\\\\\\\\\\"Invalid pattern: {pattern}. Supported types: {standard_patterns}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\\n#     def set_pattern(self, channel, pattern):\\\\\\\\n#         \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n#         Sets the pattern for the specified channel after validation.\\\\\\\\n\\\\\\\\n#         Args:\\\\\\\\n#             channel (int or str): The channel for which to set the pattern.\\\\\\\\n#             pattern (str): The type of pattern to set.\\\\\\\\n\\\\\\\\n#         \\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\n#         self._validate_pattern(pattern)\\\\\\\\n#         self._send_command(f\\\\\\\\\\\\\\\"SOUR{channel}:FUNC {pattern.upper()}\\\\\\\\\\\\\\\")\\\\\\\\n\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\profiles\\\\\\\\\\\\\\\\__init__.py\\\\\\\": \\\\\\\"\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\profiles\\\\\\\\\\\\\\\\keysight\\\\\\\\\\\\\\\\infiniium.py\\\\\\\": \\\\\\\"\\\\\\\\noscilloscope_profile = {\\\\\\\\n    \\\\\\\\\\\\\\\"MXR054A\\\\\\\\\\\\\\\": {\\\\\\\\n    \\\\\\\\\\\\\\\"manufacturer\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Keysight\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR054A\\\\\\\\\\\\\\\", \\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"500 MHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"MXR058A\\\\\\\\\\\\\\\": {\\\\\\\\n    \\\\\\\\\\\\\\\"manufacturer\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Keysight\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR058A\\\\\\\\\\\\\\\", \\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n      1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n      2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },  \\\\\\\\n      3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n      4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n      5: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n      6: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }, \\\\\\\\n      7: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n      8: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"500 MHz\\\\\\\\\\\\\\\",  \\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 8,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n\\\\\\\\n    \\\\\\\\\\\\\\\"MXR104A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR054A except:\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR104A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"1 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n\\\\\\\\n  \\\\\\\\\\\\\\\"MXR108A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR058A except: \\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR108A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"1 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n\\\\\\\\n  \\\\\\\\\\\\\\\"MXR204A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR054A except:\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR204A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"2 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n\\\\\\\\n  \\\\\\\\\\\\\\\"MXR208A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR058A except:\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR208A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"2 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n\\\\\\\\n  \\\\\\\\\\\\\\\"MXR254A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR054A except:\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR254A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"2.5 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n  \\\\\\\\n  \\\\\\\\\\\\\\\"MXR258A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR058A except:\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR258A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"2.5 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n\\\\\\\\n  \\\\\\\\\\\\\\\"MXR404A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR054A except:\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR404A\\\\\\\\\\\\\\\", \\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"4 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n\\\\\\\\n  \\\\\\\\\\\\\\\"MXR408A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR058A except:\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR408A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"4 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n\\\\\\\\n  \\\\\\\\\\\\\\\"MXR604A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR054A except:\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR604A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"6 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  },\\\\\\\\n\\\\\\\\n  \\\\\\\\\\\\\\\"MXR608A\\\\\\\\\\\\\\\": {\\\\\\\\n    # Same as MXR058A except:\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MXR608A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"6 GHz\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,               \\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],   \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,  \\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Input Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5.0,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5.0, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10, 100]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min_scale\\\\\\\\\\\\\\\": 5e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_scale\\\\\\\\\\\\\\\": 200,\\\\\\\\n        \\\\\\\\\\\\\\\"time_units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"s\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ms\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"us\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ns\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"trigger\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"TIMEOUT\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"WINDOW\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"slope\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RISING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FALLING\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"EITHER\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"external_trigger_input\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AUX\\\\\\\\\\\\\\\"] \\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"analog_channels\\\\\\\\\\\\\\\": 4,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"16 GSa/s\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"standard_memory\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"200 Mpts/ch\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"> 200,000 wfms/sec\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"jitter_analysis\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"available_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RMS\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"jitter_sources\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Time Interval Error\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"analysis_depth\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"histogram_bins\\\\\\\\\\\\\\\": 256, \\\\\\\\n        \\\\\\\\\\\\\\\"modulation_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"real_time_analysis\\\\\\\\\\\\\\\": False,\\\\\\\\n        \\\\\\\\\\\\\\\"min_jitter_measurement\\\\\\\\\\\\\\\": 1e-12,\\\\\\\\n        \\\\\\\\\\\\\\\"max_jitter_measurement\\\\\\\\\\\\\\\": 1e-3\\\\\\\\n    }\\\\\\\\n  }\\\\\\\\n}\\\\\\\",\\\\n    \\\\\\\"pytestlab\\\\\\\\\\\\\\\\profiles\\\\\\\\\\\\\\\\keysight\\\\\\\\\\\\\\\\smartbench.py\\\\\\\": \\\\\\\"oscilloscope_profile = {\\\\\\\\n    \\\\\\\\\\\\\\\"DSOX1204A\\\\\\\\\\\\\\\":{\\\\\\\\n    \\\\\\\\\\\\\\\"manufacturer\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Keysight\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"vendor_id\\\\\\\\\\\\\\\": 0x2A8D,\\\\\\\\n    \\\\\\\\\\\\\\\"product_id\\\\\\\\\\\\\\\": 0x0396,\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"DSOX1204A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Analog Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\"], \\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10]\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Analog Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Analog Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Analog Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5, \\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": 70e6,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": 2e9,\\\\\\\\n    \\\\\\\\\\\\\\\"memory\\\\\\\\\\\\\\\": 2e6,\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": 2e5,\\\\\\\\n    \\\\\\\\\\\\\\\"trigger_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"Edge\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Pulse Width\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Video\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"I2C\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"SPI\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"UART/RS232\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"CAN\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"LIN\\\\\\\\\\\\\\\"],\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {  \\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 5e-9,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 50\\\\\\\\n    }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"DSOX1204G\\\\\\\\\\\\\\\": {\\\\\\\\n    \\\\\\\\\\\\\\\"manufacturer\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Keysight\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"DSOX1204G\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"vendor_id\\\\\\\\\\\\\\\": 0x2A8D,\\\\\\\\n    \\\\\\\\\\\\\\\"product_id\\\\\\\\\\\\\\\": 0x0396,\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Oscilloscope\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": {\\\\\\\\n        1: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Analog Channel 1\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10],\\\\\\\\n        \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n            \\\\\\\\\\\\\\\"range\\\\\\\\\\\\\\\": {\\\\\\\\n            \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 5e-9,\\\\\\\\n            \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 50\\\\\\\\n            },\\\\\\\\n            \\\\\\\\\\\\\\\"horizontal_resolution\\\\\\\\\\\\\\\": 1e-12\\\\\\\\n        }\\\\\\\\n        },\\\\\\\\n        2: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Analog Channel 2\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10]\\\\\\\\n        },\\\\\\\\n        3: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Analog Channel 3\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10]\\\\\\\\n        },\\\\\\\\n        4: {\\\\\\\\n        \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Analog Channel 4\\\\\\\\\\\\\\\",\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5,\\\\\\\\n        \\\\\\\\\\\\\\\"input_coupling\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"AC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"input_impedance\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"probe_attenuation\\\\\\\\\\\\\\\": [1, 10]\\\\\\\\n        }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"bandwidth\\\\\\\\\\\\\\\": 70e6,\\\\\\\\n    \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": 2e9,\\\\\\\\n    \\\\\\\\\\\\\\\"memory\\\\\\\\\\\\\\\": 2e6,\\\\\\\\n    \\\\\\\\\\\\\\\"waveform_update_rate\\\\\\\\\\\\\\\": 2e5,\\\\\\\\n    \\\\\\\\\\\\\\\"trigger_modes\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"EDGE\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULSe\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"VIDEo\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"I2C\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"SPI\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"UART\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"RS232\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"CAN\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"LIN\\\\\\\\\\\\\\\"],\\\\\\\\n    \\\\\\\\\\\\\\\"timebase\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 5e-9,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 50\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"fft\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"window_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"RECTangular\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"HANNing\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FLATtop\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"BHARris\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"units\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"DECibel\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"VRMS\\\\\\\\\\\\\\\"]\\\\\\\\n    },\\\\\\\\n    \\\\\\\\\\\\\\\"function_generator\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"waveform_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"SINusoid\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"SQUare\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"RAMp\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PULse\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"NOISe\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"supported_states\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"ON\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"OFF\\\\\\\\\\\\\\\"],\\\\\\\\n        \\\\\\\\\\\\\\\"offset\\\\\\\\\\\\\\\": { \\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5\\\\\\\\n        },\\\\\\\\n        \\\\\\\\\\\\\\\"frequency\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 0.1,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 20e6\\\\\\\\n        },\\\\\\\\n        \\\\\\\\\\\\\\\"amplitude\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 2e-3,\\\\\\\\n        \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 20    \\\\\\\\n        }\\\\\\\\n    }\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\npower_supply_profile = {\\\\\\\\n  \\\\\\\\\\\\\\\"EDU36311A\\\\\\\\\\\\\\\": {\\\\\\\\n    \\\\\\\\\\\\\\\"manufacturer\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Keysight\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"vendor_id\\\\\\\\\\\\\\\": 0x2a8d,\\\\\\\\n    \\\\\\\\\\\\\\\"product_id\\\\\\\\\\\\\\\": 0x8f01,\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"EDU36311A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"powersupply\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"outputs\\\\\\\\\\\\\\\": {\\\\\\\\n      1: {\\\\\\\\n        \\\\\\\\\\\\\\\"voltage\\\\\\\\\\\\\\\": {\\\\\\\\n          \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 0,\\\\\\\\n          \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 6\\\\\\\\n        },\\\\\\\\n        \\\\\\\\\\\\\\\"current\\\\\\\\\\\\\\\": {\\\\\\\\n          \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 0, \\\\\\\\n          \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5\\\\\\\\n        }\\\\\\\\n      },\\\\\\\\n      2: {\\\\\\\\n        \\\\\\\\\\\\\\\"voltage\\\\\\\\\\\\\\\": {\\\\\\\\n          \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 0,\\\\\\\\n          \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 30\\\\\\\\n        },\\\\\\\\n        \\\\\\\\\\\\\\\"current\\\\\\\\\\\\\\\": {\\\\\\\\n          \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 0,\\\\\\\\n          \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 1\\\\\\\\n        }\\\\\\\\n      },\\\\\\\\n      3: {\\\\\\\\n        \\\\\\\\\\\\\\\"voltage\\\\\\\\\\\\\\\": {\\\\\\\\n          \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 0,\\\\\\\\n          \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 30\\\\\\\\n        },\\\\\\\\n        \\\\\\\\\\\\\\\"current\\\\\\\\\\\\\\\": {\\\\\\\\n          \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 0,\\\\\\\\n          \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 1  \\\\\\\\n        }\\\\\\\\n      }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"total_power\\\\\\\\\\\\\\\": 90, \\\\\\\\n    \\\\\\\\\\\\\\\"line_regulation\\\\\\\\\\\\\\\": 0.01, \\\\\\\\n    \\\\\\\\\\\\\\\"load_regulation\\\\\\\\\\\\\\\": 0.2,\\\\\\\\n    \\\\\\\\\\\\\\\"programming_accuracy\\\\\\\\\\\\\\\": {\\\\\\\\n      \\\\\\\\\\\\\\\"voltage\\\\\\\\\\\\\\\": 0.05,\\\\\\\\n      \\\\\\\\\\\\\\\"current\\\\\\\\\\\\\\\": 0.2  \\\\\\\\n    },\\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"readback_accuracy\\\\\\\\\\\\\\\": {\\\\\\\\n      \\\\\\\\\\\\\\\"voltage\\\\\\\\\\\\\\\": 0.05,\\\\\\\\n      \\\\\\\\\\\\\\\"current\\\\\\\\\\\\\\\": 0.2\\\\\\\\n    },\\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"interfaces\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"USB\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"LAN\\\\\\\\\\\\\\\"],\\\\\\\\n    \\\\\\\\\\\\\\\"remote_control\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"SCPI\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"IVI\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Web Browser\\\\\\\\\\\\\\\"]\\\\\\\\n  }\\\\\\\\n}\\\\\\\\n\\\\\\\\nawg_profile = {\\\\\\\\n  \\\\\\\\\\\\\\\"EDU33211A\\\\\\\\\\\\\\\": {\\\\\\\\n    \\\\\\\\\\\\\\\"manufacturer\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Keysight\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"EDU33211A\\\\\\\\\\\\\\\", \\\\\\\\n    \\\\\\\\\\\\\\\"vendor_id\\\\\\\\\\\\\\\": 0x2a8d,\\\\\\\\n    \\\\\\\\\\\\\\\"product_id\\\\\\\\\\\\\\\": 0x8d01,\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Arbitrary Waveform Generator\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": 1,\\\\\\\\n    \\\\\\\\\\\\\\\"max_frequency\\\\\\\\\\\\\\\": 20e6, \\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"waveforms\\\\\\\\\\\\\\\": {\\\\\\\\n      \\\\\\\\\\\\\\\"standard\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"sine\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"square\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"ramp\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"pulse\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"triangle\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"noise\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PRBS\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"DC\\\\\\\\\\\\\\\"],\\\\\\\\n      \\\\\\\\\\\\\\\"built-in\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"cardiac\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"exponential_fall\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"exponential_rise\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"gaussian_pulse\\\\\\\\\\\\\\\", \\\\\\\\n                  \\\\\\\\\\\\\\\"haversine\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"lorentz\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"dlorentz\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"negative_ramp\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"sinc\\\\\\\\\\\\\\\"],\\\\\\\\n      \\\\\\\\\\\\\\\"arbitrary\\\\\\\\\\\\\\\": {\\\\\\\\n        \\\\\\\\\\\\\\\"memory\\\\\\\\\\\\\\\": 8e6, \\\\\\\\n        \\\\\\\\\\\\\\\"max_length\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n        \\\\\\\\\\\\\\\"sampling_rate\\\\\\\\\\\\\\\": {\\\\\\\\n          \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 1e-6,\\\\\\\\n          \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 250e6\\\\\\\\n        },\\\\\\\\n        \\\\\\\\\\\\\\\"resolution\\\\\\\\\\\\\\\": 16\\\\\\\\n      }\\\\\\\\n    },\\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"modulation_types\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"AM\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FM\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PM\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"FSK\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"BPSK\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"PWM\\\\\\\\\\\\\\\"],\\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"amplitude\\\\\\\\\\\\\\\": {\\\\\\\\n      \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": 1e-3,\\\\\\\\n      \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 10\\\\\\\\n    },\\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"dc_offset\\\\\\\\\\\\\\\": {\\\\\\\\n      \\\\\\\\\\\\\\\"min\\\\\\\\\\\\\\\": -5,\\\\\\\\n      \\\\\\\\\\\\\\\"max\\\\\\\\\\\\\\\": 5  \\\\\\\\n    },\\\\\\\\n\\\\\\\\n    \\\\\\\\\\\\\\\"accuracy\\\\\\\\\\\\\\\": {\\\\\\\\n      \\\\\\\\\\\\\\\"amplitude\\\\\\\\\\\\\\\": 0.02, \\\\\\\\n      \\\\\\\\\\\\\\\"frequency\\\\\\\\\\\\\\\": 1e-6\\\\\\\\n    },\\\\\\\\n    \\\\\\\\n    \\\\\\\\\\\\\\\"interfaces\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"USB\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"LAN\\\\\\\\\\\\\\\"], \\\\\\\\n    \\\\\\\\\\\\\\\"remote_control\\\\\\\\\\\\\\\": [\\\\\\\\\\\\\\\"SCPI\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"IVI\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\"Web Browser\\\\\\\\\\\\\\\"]\\\\\\\\n  }\\\\\\\\n}\\\\\\\\n\\\\\\\\nmultimeter_profile = {\\\\\\\\n    \\\\\\\\\\\\\\\"EDU34450A\\\\\\\\\\\\\\\": {\\\\\\\\n    \\\\\\\\\\\\\\\"manufacturer\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Keysight\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"model\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"EDU34450A\\\\\\\\\\\\\\\",\\\\\\\\n    \\\\\\\\\\\\\\\"vendor_id\\\\\\\\\\\\\\\": 0x2a8d,\\\\\\\\n    \\\\\\\\\\\\\\\"product_id\\\\\\\\\\\\\\\": 0x8e01,\\\\\\\\n    \\\\\\\\\\\\\\\"device_type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"multimeter\\\\\\\\\\\\\\\",\\\\\\\\n\\\\\\\\n    \\\\\\\\\\\\\\\"channels\\\\\\\\\\\\\\\": 1,\\\\\\\\n    \\\\\\\\\\\\\\\"resolution\\\\\\\\\\\\\\\": 5.5,\\\\\\\\n    \\\\\\\\\\\\\\\"max_voltage\\\\\\\\\\\\\\\": 1000,\\\\\\\\n    \\\\\\\\\\\\\\\"max_current\\\\\\\\\\\\\\\": 10,\\\\\\\\n    \\\\\\\\\\\\\\\"max_resistance\\\\\\\\\\\\\\\": 100e6,\\\\\\\\n    \\\\\\\\\\\\\\\"max_capacitance\\\\\\\\\\\\\\\": 10e-6,\\\\\\\\n    \\\\\\\\\\\\\\\"max_frequency\\\\\\\\\\\\\\\": 1e6,\\\\\\\\n    }\\\\\\\\n  }\\\\\\\"\\\\n}\\\",\\n    \\\"README.md\\\": \\\"# PyTestLab\\\\n\\\\nA Python library for test and measurement  automation and measurement data management.\\\\n\\\",\\n    \\\"setup.py\\\": \\\"from setuptools import setup, find_packages\\\\n\\\\nsetup(\\\\n    name='pytestlab',\\\\n    version='0.0.1',\\\\n    description='A Python library for instrument automation and measurement data management.',\\\\n    author='Emmanuel Olowe',\\\\n    author_email='e.a.olowe@ed.ac.uk',\\\\n    # url='https://github.com/labiium/PyTestLab',\\\\n    # packages=find_packages(),\\\\n    # install_requires=[\\\\n    #     'numpy',\\\\n    #     # 'scipy',\\\\n    #     'pandas',\\\\n    #     # 'pyvisa',\\\\n    # ],\\\\n    classifiers=[\\\\n        'Development Status :: 3 - Alpha',\\\\n        'Intended Audience :: Developers',\\\\n        'License :: OSI Approved :: MIT License',\\\\n        'Programming Language :: Python :: 3',\\\\n        'Programming Language :: Python :: 3.6',\\\\n        'Programming Language :: Python :: 3.7',\\\\n        'Programming Language :: Python :: 3.8',\\\\n        'Programming Language :: Python :: 3.9',\\\\n        'Programming Language :: Python :: 3.10',\\\\n        'Programming Language :: Python :: 3.11',\\\\n    ],\\\\n)\\\\n\\\",\\n    \\\"examples\\\\\\\\description.json\\\": \\\"{\\\\n    \\\\\\\"methods\\\\\\\": [\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"add_instrument\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Add an instrument to the manager's collection.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"name\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"str\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The name of the instrument.\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"instrument\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"object\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The instrument object to be added.\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"remove_instrument\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Remove an instrument from the manager's collection.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"name\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"str\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The name of the instrument to be removed.\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"get_instrument\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Get an instrument by name from the manager's collection.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"name\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"str\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The name of the instrument to retrieve.\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"list_instruments\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"List all instruments currently added to the manager.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"connect_all_instruments\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Connect all instruments in the manager's collection.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"disconnect_all_instruments\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Disconnect all instruments in the manager's collection.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"is_all_instruments_connected\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Check if all instruments are connected.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"is_instrument_connected\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Check if a specific instrument is connected.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"name\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"str\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The name of the instrument to check.\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"measure_voltage\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Perform a voltage measurement.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"voltage\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"float\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The voltage to measure.\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"channel\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"int\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The channel number to measure (default: 1).\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"measure_current\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Perform a current measurement.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"current\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"float\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The current to measure.\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"channel\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"int\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The channel number to measure (default: 1).\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"measure_power\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Perform a power measurement.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"power\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"float\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The power to measure.\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"channel\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"int\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The channel number to measure (default: 1).\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"measure_eye_diagram\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Perform an Eye Diagram measurement.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"test_pattern\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"str\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The test pattern to use.\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"voltage\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"float\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The voltage for the power supply (default: 1.0 V).\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"current\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"float\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The current for the power supply (default: 0.5 A).\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"channel\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"int\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The channel number to use (default: 1).\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"eye_duration\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"float\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The duration of the eye diagram measurement (default: 0.1 s).\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"perform_s21_measurement\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Perform an S21 measurement.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"frequency\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"float\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The frequency for the measurement.\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"power_level\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"float\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The power level for the measurement.\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"channel\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"int\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The channel number to use (default: 1).\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"measurement_time\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"float\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The measurement time (default: 0.1 s).\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"calibrate_power_supply\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Calibrate the power supply.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"calibrate_oscilloscope\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Calibrate the oscilloscope.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"calibrate_vna\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Calibrate the Vector Network Analyzer.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"save_measurement_data\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Save measurement data to a file.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"data\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"dict\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The measurement data to save.\\\\\\\"\\\\n                },\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"file_name\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"str\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The name of the file to save the data to.\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"load_measurement_data\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Load measurement data from a file.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"file_name\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"str\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"The name of the file to load the data from.\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"configure_power_supply\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Configure power supply settings.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"settings\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"dict\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"A dictionary containing power supply settings.\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"configure_oscilloscope\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Configure oscilloscope settings.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"settings\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"dict\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"A dictionary containing oscilloscope settings.\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"configure_vna\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Configure Vector Network Analyzer settings.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": [\\\\n                {\\\\n                    \\\\\\\"name\\\\\\\": \\\\\\\"settings\\\\\\\",\\\\n                    \\\\\\\"type\\\\\\\": \\\\\\\"dict\\\\\\\",\\\\n                    \\\\\\\"description\\\\\\\": \\\\\\\"A dictionary containing VNA settings.\\\\\\\"\\\\n                }\\\\n            ]\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"check_instrument_compatibility\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Check if the connected instruments are compatible for the planned measurements.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"perform_full_system_check\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Perform a comprehensive system check before starting measurements.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        },\\\\n        {\\\\n            \\\\\\\"name\\\\\\\": \\\\\\\"report_system_status\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Generate a report on the status of connected instruments and overall system health.\\\\\\\",\\\\n            \\\\\\\"parameters\\\\\\\": []\\\\n        }\\\\n    ]\\\\n}\\\",\\n    \\\"examples\\\\\\\\digital_multimeter_example.py\\\": \\\"from pytestlab.instruments.DigitalMultimeter import DigitalMultimeter\\\\nimport json\\\\n# connect to the digital multimeter\\\\npath_to_description = \\\\\\\"/examples/instrument_descriptions/digital_multi_meter.json\\\\\\\"\\\\ndescription = json.load(open(path_to_description, \\\\\\\"r\\\\\\\"))\\\\n\\\\ndigital_multimeter = DigitalMultimeter(description[\\\\\\\"visa_resource\\\\\\\"], description)\\\\n\\\\n# print the id of the digital multimeter\\\\nprint(digital_multimeter.id())\\\\n\\\\n# reset the digital multimeter\\\\ndigital_multimeter.reset()\\\\n\\\\n# set the voltage of channel 1 to 1.5V\\\\ndigital_multimeter.set_channel_voltage(1, 1.5)\\\\n\\\\n# get the voltage of channel 1\\\\nprint(digital_multimeter.get_channel_voltage(1))\\\\n\\\\n\\\\n# measure the frequency of channel 1\\\\nprint(digital_multimeter.measure_frequency(1))\\\\n\\\\n# close the connection to the digital multimeter\\\\ndigital_multimeter.close()\\\",\\n    \\\"examples\\\\\\\\oscilloscope_jitter_example.py\\\": \\\"from pytestlab.instruments.Oscilloscope import Oscilloscope\\\\nfrom pytestlab.instruments.InstrumentManager import InstrumentManager\\\\n\\\\n# connect to the oscilloscope\\\\noscilloscope = Oscilloscope(\\\\\\\"USB0::0x0957::0x1799::MY58100838::INSTR\\\\\\\")\\\\n\\\\n# reset oscilloscope\\\\noscilloscope.reset()\\\\n\\\\nprint(oscilloscope.id())\\\\n\\\\n# get the voltage of channel 1\\\\nprint(oscilloscope.get_channel_voltage(1))\\\\n\\\\n# measure the frequency of channel 1\\\\nprint(oscilloscope.measure_frequency(1))\\\\n\\\\n# rms jitter measurement\\\\nprint(oscilloscope.perform_rms_jitter_measurement(1, 0.5))\\\\n\\\\n# peak-to-peak jitter measurement\\\\nprint(oscilloscope.perform_peak_to_peak_jitter_measurement(1, 0.5))\\\\n\\\\n# rise time measurement\\\\nprint(oscilloscope.perform_rise_time_measurement(1, 0.5))\\\\n\\\\n# fall time measurement\\\\nprint(oscilloscope.perform_fall_time_measurement(1, 0.5))\\\\n\\\\n# eye diagram measurement\\\",\\n    \\\"examples\\\\\\\\__init__.py\\\": \\\"\\\",\\n    \\\"examples\\\\\\\\instrument_descrptions\\\\\\\\.oscilloscope_description.py\\\": \\\"oscilloscope_description = {\\\\n    \\\\\\\"manufacturer\\\\\\\": \\\\\\\"Keysight\\\\\\\",    # Manufacturer name\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"Magic Oscilloscope with 2 Channels\\\\\\\",    # Model name/number\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\", # Device type\\\\n    \\\\\\\"visa_resource\\\\\\\": \\\\\\\"USB0::0x0957::0x1799::MY58100838::INSTR\\\\\\\",   # VISA resource string\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n            \\\\\\\"min\\\\\\\": -5.0,             # Minimum voltage (in volts) supported on Channel 1\\\\n            \\\\\\\"max\\\\\\\": 5.0,              # Maximum voltage (in volts) supported on Channel 1\\\\n            \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\", \\\\\\\"GND\\\\\\\"],   # List of supported input coupling modes\\\\n            \\\\\\\"input_impedance\\\\\\\": 1e6,   # Input impedance (in ohms) for Channel 1\\\\n            \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100],       # List of supported probe attenuation ratios\\\\n            # Add more channel-specific settings and limitations as needed\\\\n        },\\\\n        2: {\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n            \\\\\\\"min\\\\\\\": -5.0,             # Minimum voltage (in volts) supported on Channel 2\\\\n            \\\\\\\"max\\\\\\\": 5.0,              # Maximum voltage (in volts) supported on Channel 2\\\\n            \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\", \\\\\\\"GND\\\\\\\"],   # List of supported input coupling modes\\\\n            \\\\\\\"input_impedance\\\\\\\": 1e6,   # Input impedance (in ohms) for Channel 2\\\\n            \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100],       # List of supported probe attenuation ratios\\\\n            # Add more channel-specific settings and limitations as needed\\\\n        },\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 1e-9,         # Minimum timebase scale (in seconds) supported\\\\n        \\\\\\\"max_scale\\\\\\\": 10.0,         # Maximum timebase scale (in seconds) supported\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"],   # List of supported time units\\\\n        # Add more timebase-related settings and limitations as needed\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"VIDEO\\\\\\\", \\\\\\\"USB\\\\\\\", \\\\\\\"RS232\\\\\\\"],   # List of supported trigger modes\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\"],          # List of supported trigger slope options\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"EXT\\\\\\\", \\\\\\\"EXT/10\\\\\\\", \\\\\\\"EXT/100\\\\\\\"],  # List of supported external trigger inputs\\\\n        # Add more trigger-related settings and limitations as needed\\\\n    },\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"0.5 - 6 GHz\\\\\\\",            # Oscilloscope bandwidth (in Hz)\\\\n    \\\\\\\"analog_channels\\\\\\\": [4, 8],             # Number of analog channels supported (upgradeable)\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",           # Oscilloscope sampling rate (in samples per second)\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200Mpts/ch\\\\\\\",       # Standard memory per channel (in points)\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\">200,000 wfms/sec\\\\\\\",  # Waveform update rate (in waveforms per second)\\\\n    # Jitter analysis\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\", \\\\\\\"Peak-to-Peak\\\\\\\"],   # Types of jitter measurement\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\", \\\\\\\"Phase Noise\\\\\\\"], # List of selectable jitter sources\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,         # Maximum number of cycles or edges that can be analyzed\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256,         # Number of histogram bins for jitter distribution\\\\n        \\\\\\\"modulation_analysis\\\\\\\": True,   # Supports modulation analysis or not\\\\n        \\\\\\\"real_time_analysis\\\\\\\": True,    # Supports real-time jitter analysis or not\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,   # Minimum measurable jitter (in seconds)\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3,    # Maximum measurable jitter (in seconds)\\\\n        # Add more jitter-related settings and limitations as needed\\\\n    }\\\\n    # Add more settings and limitations as needed\\\\n}\\\\n\\\",\\n    \\\"examples\\\\\\\\instrument_descrptions\\\\\\\\digital_multimeter.py\\\": \\\"digital_multimeter_description = {\\\\n    \\\\\\\"voltage_channels\\\\\\\": [1, 2],   # Supported voltage measurement channels: 1, 2\\\\n    \\\\\\\"current_channels\\\\\\\": [1],      # Supported current measurement channels: 1\\\\n    \\\\\\\"voltage_range\\\\\\\": 1000,        # Voltage measurement range (in Volts)\\\\n    \\\\\\\"current_range\\\\\\\": 10,          # Current measurement range (in Amperes)\\\\n}\\\",\\n    \\\"examples\\\\\\\\instrument_descrptions\\\\\\\\digital_power_supply.py\\\": \\\"digital_power_supply_description = {\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\\\\"min_voltage\\\\\\\": 0, \\\\\\\"max_voltage\\\\\\\": 30},   # Channel 1 voltage range: 0 V to 30 V\\\\n        2: {\\\\\\\"min_voltage\\\\\\\": 0, \\\\\\\"max_voltage\\\\\\\": 30},   # Channel 2 voltage range: 0 V to 30 V\\\\n    },\\\\n    \\\\\\\"max_current\\\\\\\": 5,   # Maximum current (in Amperes) supported by the power supply\\\\n}\\\",\\n    \\\"examples\\\\\\\\instrument_descrptions\\\\\\\\oscilloscope.json\\\": \\\"{\\\\n    \\\\\\\"manufacturer\\\\\\\": \\\\\\\"Keysight\\\\\\\",\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"Magic Oscilloscope with 2 Channels\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"visa_resource\\\\\\\": \\\\\\\"USB0::0x0957::0x1799::MY58100838::INSTR\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        \\\\\\\"1\\\\\\\": {\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n            \\\\\\\"min\\\\\\\": -5.0,\\\\n            \\\\\\\"max\\\\\\\": 5.0,\\\\n            \\\\\\\"input_coupling\\\\\\\": [\\\\n                \\\\\\\"AC\\\\\\\",\\\\n                \\\\\\\"DC\\\\\\\",\\\\n                \\\\\\\"GND\\\\\\\"\\\\n            ],\\\\n            \\\\\\\"input_impedance\\\\\\\": 1000000,\\\\n            \\\\\\\"probe_attenuation\\\\\\\": [\\\\n                1,\\\\n                10,\\\\n                100\\\\n            ]\\\\n        },\\\\n        \\\\\\\"2\\\\\\\": {\\\\n            \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n            \\\\\\\"min\\\\\\\": -5.0,\\\\n            \\\\\\\"max\\\\\\\": 5.0,\\\\n            \\\\\\\"input_coupling\\\\\\\": [\\\\n                \\\\\\\"AC\\\\\\\",\\\\n                \\\\\\\"DC\\\\\\\",\\\\n                \\\\\\\"GND\\\\\\\"\\\\n            ],\\\\n            \\\\\\\"input_impedance\\\\\\\": 1000000,\\\\n            \\\\\\\"probe_attenuation\\\\\\\": [\\\\n                1,\\\\n                10,\\\\n                100\\\\n            ]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 1e-9,\\\\n        \\\\\\\"max_scale\\\\\\\": 10.0,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\n            \\\\\\\"s\\\\\\\",\\\\n            \\\\\\\"ms\\\\\\\",\\\\n            \\\\\\\"us\\\\\\\",\\\\n            \\\\\\\"ns\\\\\\\"\\\\n        ]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\n            \\\\\\\"EDGE\\\\\\\",\\\\n            \\\\\\\"PULSE\\\\\\\",\\\\n            \\\\\\\"VIDEO\\\\\\\",\\\\n            \\\\\\\"USB\\\\\\\",\\\\n            \\\\\\\"RS232\\\\\\\"\\\\n        ],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\n            \\\\\\\"RISING\\\\\\\",\\\\n            \\\\\\\"FALLING\\\\\\\"\\\\n        ],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\n            \\\\\\\"EXT\\\\\\\",\\\\n            \\\\\\\"EXT/10\\\\\\\",\\\\n            \\\\\\\"EXT/100\\\\\\\"\\\\n        ]\\\\n    },\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"0.5 - 6 GHz\\\\\\\",\\\\n    \\\\\\\"analog_channels\\\\\\\": [\\\\n        4,\\\\n        8\\\\n    ],\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\">200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\n            \\\\\\\"RMS\\\\\\\",\\\\n            \\\\\\\"Peak-to-Peak\\\\\\\"\\\\n        ],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\n            \\\\\\\"Time Interval Error\\\\\\\",\\\\n            \\\\\\\"Phase Noise\\\\\\\"\\\\n        ],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1000000,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256,\\\\n        \\\\\\\"modulation_analysis\\\\\\\": true,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": true,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n}\\\",\\n    \\\"examples\\\\\\\\instrument_descrptions\\\\\\\\train.jsonl\\\": \\\"  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a frequency measurement on channel 4 with 10 Hz.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a frequency measurement on channel 4. The signal generator will be set to 10 Hz, the output will be enabled, the frequency will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nsignal_generator.set_frequency(10, channel=4)\\\\\\\\nsignal_generator.enable_output(channel=4)\\\\\\\\nmanager.measure_frequency(10, channel=4)\\\\\\\\nsignal_generator.disable_output(channel=4)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a resistance measurement with 100 ohms.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a resistance measurement. The multimeter will be set to measure resistance, a 100-ohm resistor will be connected, and the resistance will be measured.\\\\\\\\n```python\\\\\\\\nmultimeter.set_to_resistance()\\\\\\\\nmanager.connect_resistor(100)\\\\\\\\nresistance = multimeter.measure_resistance()\\\\\\\\nprint('Measured resistance:', resistance)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a jitter measurement on channel 5 with a peak-to-peak value of 10 ns.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a jitter measurement on channel 5. The oscilloscope will be set to measure jitter with a peak-to-peak value of 10 ns.\\\\\\\\n```python\\\\\\\\noscilloscope.set_to_jitter(channel=5)\\\\\\\\nmanager.set_jitter_pp(10, channel=5)\\\\\\\\njitter = oscilloscope.measure_jitter()\\\\\\\\nprint('Measured jitter:', jitter)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a rise time measurement on channel 1 with 5 ms.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a rise time measurement on channel 1. The oscilloscope will be set to measure rise time with a value of 5 ms.\\\\\\\\n```python\\\\\\\\noscilloscope.set_to_rise_time(channel=1)\\\\\\\\nmanager.set_rise_time(5, channel=1)\\\\\\\\nrise_time = oscilloscope.measure_rise_time()\\\\\\\\nprint('Measured rise time:', rise_time)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a fall time measurement on channel 2 with 5 ms.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a fall time measurement on channel 2. The oscilloscope will be set to measure fall time with a value of 5 ms.\\\\\\\\n```python\\\\\\\\noscilloscope.set_to_fall_time(channel=2)\\\\\\\\nmanager.set_fall_time(5, channel=2)\\\\\\\\nfall_time = oscilloscope.measure_fall_time()\\\\\\\\nprint('Measured fall time:', fall_time)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a Bit Error Rate (BER) measurement with a bit sequence 10101010.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a Bit Error Rate (BER) measurement. The bit sequence 10101010 is sent, and the received bit sequence is checked for errors.\\\\\\\\n```python\\\\\\\\nmanager.send_bit_sequence('10101010')\\\\\\\\nber = manager.measure_ber('10101010')\\\\\\\\nprint('Measured BER:', ber)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a power measurement on channel 3 with 5 Watts.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a power measurement on channel 3. The power meter will be set to 5 Watts, the output will be enabled, the power will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\npower_meter.set_power(5, channel=3)\\\\\\\\npower_meter.enable_output(channel=3)\\\\\\\\nmanager.measure_power(5, channel=3)\\\\\\\\npower_meter.disable_output(channel=3)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform an impedance measurement with 50 Ohms.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs an impedance measurement. The multimeter will be set to measure impedance, a 50-ohm load will be connected, and the impedance will be measured.\\\\\\\\n```python\\\\\\\\nmultimeter.set_to_impedance()\\\\\\\\nmanager.connect_load(50)\\\\\\\\nimpedance = multimeter.measure_impedance()\\\\\\\\nprint('Measured impedance:', impedance)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a voltage peak-to-peak measurement on channel 1 with 5 V.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a voltage peak-to-peak measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the voltage will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\npower_supply.set_voltage(5, channel=1)\\\\\\\\npower_supply.enable_output(channel=1)\\\\\\\\nmanager.measure_voltage_pp(5, channel=1)\\\\\\\\npower_supply.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a current peak-to-peak measurement on channel 2 with 2 A.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a current peak-to-peak measurement on channel 2. The digital power supply will be set to 2 A, the output will be enabled, the current will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\npower_supply.set_current(2, channel=2)\\\\\\\\npower_supply.enable_output(channel=2)\\\\\\\\nmanager.measure_current_pp(2, channel=2)\\\\\\\\npower_supply.disable_output(channel=2)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a pulse width measurement on channel 1 with 5 ms.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a pulse width measurement on channel 1. The pulse generator will be set to 5 ms, the output will be enabled, the pulse width will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\npulse_generator.set_pulse_width(5, channel=1)\\\\\\\\npulse_generator.enable_output(channel=1)\\\\\\\\nmanager.measure_pulse_width(5, channel=1)\\\\\\\\npulse_generator.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a phase shift measurement between channels 1 and 2.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a phase shift measurement between channels 1 and 2. The oscilloscope will be set to measure phase shift, and the phase shift will be measured.\\\\\\\\n```python\\\\\\\\noscilloscope.set_to_phase_shift()\\\\\\\\nphase_shift = oscilloscope.measure_phase_shift(channel1=1, channel2=2)\\\\\\\\nprint('Measured phase shift:', phase_shift)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a duty cycle measurement on channel 1 with 50%.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a duty cycle measurement on channel 1. The signal generator will be set to a duty cycle of 50%, the output will be enabled, the duty cycle will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nsignal_generator.set_duty_cycle(50, channel=1)\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\nmanager.measure_duty_cycle(50, channel=1)\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a Signal to Noise Ratio (SNR) measurement with a signal of 5 V and noise of 0.5 V.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a Signal to Noise Ratio (SNR) measurement. The signal of 5 V and noise of 0.5 V is set, and the SNR is measured.\\\\\\\\n```python\\\\\\\\nmanager.set_signal_and_noise(signal=5, noise=0.5)\\\\\\\\nsnr = manager.measure_snr()\\\\\\\\nprint('Measured SNR:', snr)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a voltage RMS measurement on channel 1 with 5 V.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a voltage RMS measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the RMS voltage will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\npower_supply.set_voltage(5, channel=1)\\\\\\\\npower_supply.enable_output(channel=1)\\\\\\\\nmanager.measure_voltage_rms(5, channel=1)\\\\\\\\npower_supply.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a current RMS measurement on channel 2 with 2 A.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a current RMS measurement on channel 2. The digital power supply will be set to 2 A, the output will be enabled, the RMS current will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\npower_supply.set_current(2, channel=2)\\\\\\\\npower_supply.enable_output(channel=2)\\\\\\\\nmanager.measure_current_rms(2, channel=2)\\\\\\\\npower_supply.disable_output(channel=2)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a power factor measurement on channel 1.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a power factor measurement on channel 1. The power meter will be set to measure power factor on channel 1.\\\\\\\\n```python\\\\\\\\npower_meter.set_to_power_factor(channel=1)\\\\\\\\npower_factor = power_meter.measure_power_factor()\\\\\\\\nprint('Measured power factor:', power_factor)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a Total Harmonic Distortion (THD) measurement on channel 1.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a Total Harmonic Distortion (THD) measurement on channel 1. The spectrum analyzer will be set to measure THD on channel 1.\\\\\\\\n```python\\\\\\\\nspectrum_analyzer.set_to_thd(channel=1)\\\\\\\\nthd = spectrum_analyzer.measure_thd()\\\\\\\\nprint('Measured THD:', thd)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a signal amplitude measurement on channel 1 with 5 V.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a signal amplitude measurement on channel 1. The signal generator will be set to 5 V, the output will be enabled, the signal amplitude will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nsignal_generator.set_amplitude(5, channel=1)\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\nmanager.measure_signal_amplitude(5, channel=1)\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a latency measurement between channel 1 and channel 2.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a latency measurement between channel 1 and channel 2. The oscilloscope will be set to measure latency between the two channels.\\\\\\\\n```python\\\\\\\\noscilloscope.set_to_latency()\\\\\\\\nlatency = oscilloscope.measure_latency(channel1=1, channel2=2)\\\\\\\\nprint('Measured latency:', latency)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a cross-correlation measurement between channel 1 and channel 2.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a cross-correlation measurement between channel 1 and channel 2. The oscilloscope will be set to measure cross-correlation between the two channels.\\\\\\\\n```python\\\\\\\\noscilloscope.set_to_cross_correlation()\\\\\\\\ncross_correlation = oscilloscope.measure_cross_correlation(channel1=1, channel2=2)\\\\\\\\nprint('Measured cross-correlation:', cross_correlation)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform an attenuation measurement on channel 1 with 5 dB.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs an attenuation measurement on channel 1. The signal generator will be set to 5 dB, the output will be enabled, the attenuation will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nsignal_generator.set_attenuation(5, channel=1)\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\nmanager.measure_attenuation(5, channel=1)\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a bandwidth measurement on channel 1 with 5 MHz.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a bandwidth measurement on channel 1. The signal generator will be set to 5 MHz, the output will be enabled, the bandwidth will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nsignal_generator.set_bandwidth(5, channel=1)\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\nmanager.measure_bandwidth(5, channel=1)\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a gain measurement on channel 1 with 5 dB.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a gain measurement on channel 1. The signal generator will be set to 5 dB, the output will be enabled, the gain will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nsignal_generator.set_gain(5, channel=1)\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\nmanager.measure_gain(5, channel=1)\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a frequency response measurement on channel 1 from 1 Hz to 1 MHz.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a frequency response measurement on channel 1. The spectrum analyzer will be set from 1 Hz to 1 MHz, the frequency response will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nspectrum_analyzer.set_frequency_range(1, 1e6, channel=1)\\\\\\\\nfrequency_response = spectrum_analyzer.measure_frequency_response(channel=1)\\\\\\\\nprint('Measured frequency response:', frequency_response)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a delay measurement between channel 1 and channel 2 with 5 ms.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a delay measurement between channel 1 and channel 2. The oscilloscope will be set to measure delay, and the delay will be measured.\\\\\\\\n```python\\\\\\\\noscilloscope.set_to_delay()\\\\\\\\ndelay = oscilloscope.measure_delay(channel1=1, channel2=2)\\\\\\\\nprint('Measured delay:', delay)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a power measurement on channel 1 with 5 W.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a power measurement on channel 1. The digital power supply will be set to 5 W, the output will be enabled, the power will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\npower_supply.set_power(5, channel=1)\\\\\\\\npower_supply.enable_output(channel=1)\\\\\\\\nmanager.measure_power(5, channel=1)\\\\\\\\npower_supply.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a modulation depth measurement on channel 1 with 50%.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a modulation depth measurement on channel 1. The signal generator will be set to 50%, the output will be enabled, the modulation depth will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nsignal_generator.set_modulation_depth(50, channel=1)\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\nmanager.measure_modulation_depth(50, channel=1)\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a peak to peak voltage measurement on channel 1 with 5 V.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a peak to peak voltage measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the peak to peak voltage will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\npower_supply.set_voltage(5, channel=1)\\\\\\\\npower_supply.enable_output(channel=1)\\\\\\\\nmanager.measure_peak_to_peak_voltage(5, channel=1)\\\\\\\\npower_supply.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a duty cycle measurement on channel 1 with 50%.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a duty cycle measurement on channel 1. The signal generator will be set to 50%, the output will be enabled, the duty cycle will be measured, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nsignal_generator.set_duty_cycle(50, channel=1)\\\\\\\\nsignal_generator.enable_output(channel=1)\\\\\\\\nmanager.measure_duty_cycle(50, channel=1)\\\\\\\\nsignal_generator.disable_output(channel=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Automate a temperature measurement on sensor 1 with 25 C.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command automates a temperature measurement on sensor 1. The digital thermometer will be set to 25 C, the measurement will be taken, and then the output will be disabled.\\\\\\\\n```python\\\\\\\\nthermometer.set_temperature(25, sensor=1)\\\\\\\\nmanager.measure_temperature(25, sensor=1)\\\\\\\\n```\\\\\\\"\\\\n  },\\\\n  {\\\\n    \\\\\\\"query\\\\\\\": \\\\\\\"Perform a phase shift measurement between channel 1 and channel 2 with 90 degrees.\\\\\\\",\\\\n    \\\\\\\"command_with_explanation\\\\\\\": \\\\\\\"This command performs a phase shift measurement between channel 1 and channel 2. The oscilloscope will be set to measure phase shift, and the phase shift will be measured.\\\\\\\\n```python\\\\\\\\noscilloscope.set_to_phase_shift()\\\\\\\\nphase_shift = oscilloscope.measure_phase_shift(channel1=1, channel2=2)\\\\\\\\nprint('Measured phase shift:', phase_shift)\\\\\\\\n```\\\\\\\"\\\\n  }\\\\n\\\",\\n    \\\"examples\\\\\\\\instrument_descrptions\\\\\\\\waveform_generator_description.py\\\": \\\"waveform_generator_description = {\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\\\\"min\\\\\\\": 1, \\\\\\\"max\\\\\\\": 2},   # Channel 1 voltage range: 1 V to 2 V\\\\n        2: {\\\\\\\"min\\\\\\\": 1, \\\\\\\"max\\\\\\\": 2},   # Channel 2 voltage range: 1 V to 2 V\\\\n    },\\\\n    \\\\\\\"waveform_types\\\\\\\": [\\\\\\\"SINE\\\\\\\", \\\\\\\"SQUARE\\\\\\\", \\\\\\\"TRIANGLE\\\\\\\", \\\\\\\"RAMP\\\\\\\"],  # Supported waveform types\\\\n}\\\",\\n    \\\"pytestlab\\\\\\\\errors.py\\\": \\\"class SCPIConnectionError(Exception):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"For SCPI instrument connection errors.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, message=\\\\\\\"Failed to connect to the instrument.\\\\\\\"):\\\\n        self.message = message\\\\n        super().__init__(self.message)\\\\n\\\\nclass SCPICommunicationError(Exception):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"For SCPI communication errors.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, message=\\\\\\\"Error in SCPI communication.\\\\\\\"):\\\\n        self.message = message\\\\n        super().__init__(self.message)\\\\n\\\\nclass SCPIValueError(ValueError):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"For invalid SCPI values or settings.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, message=\\\\\\\"Invalid value for SCPI command.\\\\\\\"):\\\\n        self.message = message\\\\n        super().__init__(self.message)\\\\n\\\\nclass InstrumentNotFoundError(Exception):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"For instrument not found errors.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, name):\\\\n        super().__init__(f\\\\\\\"Instrument {name} not found in the manager's collection.\\\\\\\")\\\\n\\\\n\\\\nclass IntrumentConfigurationError(Exception):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"For instrument configuration errors.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, message=\\\\\\\"Invalid Instrument configuration.\\\\\\\"):\\\\n        self.message = message\\\\n        super().__init__(self.message)\\\",\\n    \\\"pytestlab\\\\\\\\MeasurementDatabase.py\\\": \\\"import sqlite3\\\\nimport time\\\\nimport numpy as np\\\\nfrom datetime import datetime\\\\nfrom dataclasses import dataclass\\\\nimport matplotlib.pyplot as plt\\\\n\\\\n@dataclass\\\\nclass Preamble:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A class to store the preamble data from the oscilloscope channel.\\\\n\\\\n    :param format: The format of the data\\\\n    :param type: The type of the data\\\\n    :param points: The number of points\\\\n    :param xinc: The x increment\\\\n    :param xorg: The x origin\\\\n    :param xref: The x reference\\\\n    :param yinc: The y increment\\\\n    :param yorg: The y origin\\\\n    :param yref: The y reference\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    format: str\\\\n    type: str\\\\n    points: int\\\\n    xinc: float\\\\n    xorg: float\\\\n    xref: float\\\\n    yinc: float\\\\n    yorg: float\\\\n    yref: float\\\\n\\\\nclass MeasurementValue:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A class to represent a single measurement value and its timestamp.\\\\n    \\\\n    Attributes:\\\\n        value (float): The measurement value.\\\\n        units (str): The units of the measurement value (e.g. \\\\\\\"V\\\\\\\", \\\\\\\"A\\\\\\\", \\\\\\\"Ohm\\\\\\\", \\\\\\\"Hz\\\\\\\").\\\\n        timestamp (float): The timestamp when the measurement was taken.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    def __init__(self, value, units=\\\\\\\"units\\\\\\\", timestamp=None):\\\\n        self.value = float(value)\\\\n        self.units = units\\\\n        self.timestamp = timestamp if timestamp else time.time()\\\\n\\\\n    def __str__(self):\\\\n        return f\\\\\\\"{self.value}\\\\\\\"\\\\n\\\\n    def __float__(self):\\\\n        return self.value\\\\n    \\\\nclass MeasurementResult:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A class to represent a collection of measurement values.\\\\n    \\\\n    Attributes:\\\\n        values (list): A list of MeasurementValue objects.\\\\n        units (str): The units of the measurements.\\\\n        instrument (str): The name of the instrument used for the measurements.\\\\n        measurement_type (str): The type of measurement.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    def __init__(self, instrument, units, measurement_type, sampling_rate=None, realtime_timestamps=False):\\\\n        self.values = []\\\\n        self.units = units\\\\n        self.instrument = instrument\\\\n        self.timestamp = time.time()\\\\n        self.realtime_timestamps = realtime_timestamps\\\\n        self.measurement_type = measurement_type\\\\n        self.sampling_rate = sampling_rate\\\\n\\\\n    def __str__(self):\\\\n        string = \\\\\\\"\\\\\\\"\\\\n        for value in self.values:\\\\n            string += f\\\\\\\"{value} {self.units}\\\\\\\\n\\\\\\\"\\\\n\\\\n        # remove last newline\\\\n        string = string[:-1]\\\\n        return string\\\\n    \\\\n    def __repr__(self):\\\\n        return str(self)\\\\n    \\\\n    def add(self, value):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Adds a new MeasurementValue to the collection.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        ## append to numpy array\\\\n        if value.units != self.units and self.units != \\\\\\\"units\\\\\\\" and value.units != \\\\\\\"units\\\\\\\":\\\\n            raise ValueError(\\\\\\\"MeasurementValue units must match MeasurementResult units.\\\\\\\")\\\\n        self.values = np.append(self.values, value)\\\\n\\\\n    def set_values(self, values):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Sets the MeasurementValues in the collection.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.values = values\\\\n\\\\n    def get(self, index):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Gets the MeasurementValue at a specified index.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.values[index]\\\\n\\\\n    def get_all(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Returns all the MeasurementValues in the collection.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self.values\\\\n\\\\n    def clear(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Clears all the MeasurementValues from the collection.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.values.clear()\\\\n    \\\\n    def plot(self, title=None, xlabel=None, ylabel=None):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Generates a plot of the measurement values.\\\\n\\\\n        Args:\\\\n            title (str, optional): The title of the plot.\\\\n            xlabel (str, optional): The label for the x-axis.\\\\n            ylabel (str, optional): The label for the y-axis.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        timestamps = [value.timestamp for value in self.values]\\\\n        measurements = [value.value for value in self.values]\\\\n        \\\\n        plt.figure(figsize=(10, 5))\\\\n        if self.realtime_timestamps:\\\\n            plt.plot(timestamps, measurements, marker='o')\\\\n        else:\\\\n            plt.plot(measurements, marker='o')\\\\n        if title:\\\\n            plt.title(title)\\\\n        \\\\n        xlabel = xlabel if xlabel else \\\\\\\"Time (s)\\\\\\\"\\\\n        ylabel = ylabel if ylabel else f\\\\\\\"Measurement ({self.units})\\\\\\\"\\\\n        \\\\n        plt.xlabel(xlabel)\\\\n        plt.ylabel(ylabel)\\\\n        plt.grid(True)\\\\n        plt.show()\\\\n\\\\n    def perform_fft(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Performs FFT on the measurement values and returns a MeasurementResult object\\\\n        for the frequency spectrum.\\\\n\\\\n        Returns:\\\\n            MeasurementResult: An object with frequencies as its measurement values.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # check if is a time-domain measurement\\\\n        if self.measurement_type == \\\\\\\"Frequency Spectrum\\\\\\\":\\\\n            raise ValueError(\\\\\\\"Cannot perform FFT on Frequency Spectrum measurement.\\\\\\\")\\\\n        if self.sampling_rate is None:\\\\n            raise ValueError(\\\\\\\"Sampling rate must be set to perform FFT.\\\\\\\")\\\\n\\\\n        # Extract the measurement values and convert them to a numpy array\\\\n        data = np.array([value.value for value in self.values])\\\\n\\\\n        # Perform the FFT\\\\n        fft_result = np.fft.fft(data)\\\\n\\\\n        # Compute the frequency bins\\\\n        freq = np.fft.fftfreq(len(fft_result), 1 / self.sampling_rate)\\\\n\\\\n        # Calculate the magnitudes\\\\n        magnitudes = np.abs(fft_result)\\\\n\\\\n\\\\n        # Create a new MeasurementResult for the FFT results\\\\n        fft_measurement_result = MeasurementResult(\\\\n            instrument=self.instrument,\\\\n            units=self.units,\\\\n            measurement_type=\\\\\\\"Frequency Spectrum\\\\\\\",\\\\n            sampling_rate=self.sampling_rate,  #  for reference\\\\n            realtime_timestamps=self.realtime_timestamps\\\\n        )\\\\n\\\\n        # Populate the FFT MeasurementResult with frequency and magnitude pairs\\\\n        for f, magnitude in zip(freq, magnitudes):\\\\n            fft_measurement_value = MeasurementValue(value=magnitude)\\\\n            # Normally we would set the timestamp to the frequency value\\\\n            # Misuse the timestamp here for plotting purposes\\\\n            fft_measurement_value.timestamp = f\\\\n            fft_measurement_result.add(fft_measurement_value)\\\\n\\\\n        return fft_measurement_result\\\\n    \\\\n    def __len__(self):\\\\n        return len(self.values)\\\\n\\\\n    def __getitem__(self, index):\\\\n        return self.values[index]\\\\n\\\\n    def __iter__(self):\\\\n        return iter(self.values)\\\\n\\\\n    def __delitem__(self, index):\\\\n        del self.values[index]\\\\n\\\\nclass MeasurementDatabase:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    A class for managing a SQLite database that stores measurement results.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    def __init__(self, db_path):\\\\n        self.db_path = db_path\\\\n        self._create_tables()\\\\n\\\\n    def _create_tables(self):\\\\n        with self._get_connection() as conn:\\\\n            conn.execute('''\\\\n                CREATE TABLE IF NOT EXISTS instruments (\\\\n                    instrument_id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n                    name TEXT NOT NULL UNIQUE\\\\n                )\\\\n            ''')\\\\n            conn.execute('''\\\\n                CREATE TABLE IF NOT EXISTS measurements (\\\\n                    measurement_id INTEGER PRIMARY KEY AUTOINCREMENT,\\\\n                    instrument_id INTEGER NOT NULL,\\\\n                    timestamp TIMESTAMP NOT NULL,\\\\n                    value REAL NOT NULL,\\\\n                    units TEXT NOT NULL,\\\\n                    type TEXT NOT NULL, -- 'reading' or 'fft'\\\\n                    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id)\\\\n                )\\\\n            ''')\\\\n\\\\n    def _get_connection(self):\\\\n        return sqlite3.connect(self.db_path)\\\\n\\\\n    def store_reading(self, measurement_result: MeasurementResult):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Stores a time-domain measurement result in the database.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        with self._get_connection() as conn:\\\\n            # Get or create the instrument_id\\\\n            instrument_id = self._get_or_create_instrument_id(conn, measurement_result.instrument)\\\\n\\\\n            # Store each MeasurementValue\\\\n            for measurement in measurement_result:\\\\n                conn.execute('''\\\\n                    INSERT INTO measurements (instrument_id, timestamp, value, units, type)\\\\n                    VALUES (?, ?, ?, ?, ?)\\\\n                ''', (instrument_id, datetime.fromtimestamp(measurement.timestamp),\\\\n                      measurement.value, measurement_result.units, 'reading'))\\\\n\\\\n    def store_fft_result(self, fft_result: MeasurementResult):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Stores an FFT measurement result in the database.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        with self._get_connection() as conn:\\\\n            # Get or create the instrument_id\\\\n            instrument_id = self._get_or_create_instrument_id(conn, fft_result.instrument)\\\\n\\\\n            # Store each FFT result (frequency, magnitude)\\\\n            for measurement in fft_result:\\\\n                # Assuming timestamp field is reused to store frequency\\\\n                conn.execute('''\\\\n                    INSERT INTO measurements (instrument_id, timestamp, value, units, type)\\\\n                    VALUES (?, ?, ?, ?, ?)\\\\n                ''', (instrument_id, measurement.timestamp, measurement.value,\\\\n                      fft_result.units, 'fft'))\\\\n\\\\n    def _get_or_create_instrument_id(self, conn, instrument_name):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Retrieves the instrument ID for the given name, or creates it if it doesn't exist.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        cursor = conn.execute('SELECT instrument_id FROM instruments WHERE name = ?', (instrument_name,))\\\\n        result = cursor.fetchone()\\\\n        if result:\\\\n            return result[0]\\\\n        else:\\\\n            cursor.execute('INSERT INTO instruments (name) VALUES (?)', (instrument_name,))\\\\n            return cursor.lastrowid\\\\n\\\\n    def retrieve_measurements(self, instrument_name, measurement_type):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Retrieves measurements from the database by instrument name and measurement type.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        with self._get_connection() as conn:\\\\n            cursor = conn.execute('''\\\\n                SELECT m.timestamp, m.value, m.units\\\\n                FROM measurements m\\\\n                JOIN instruments i ON m.instrument_id = i.instrument_id\\\\n                WHERE i.name = ? AND m.type = ?\\\\n            ''', (instrument_name, measurement_type))\\\\n            return cursor.fetchall()\\\",\\n    \\\"pytestlab\\\\\\\\utilities.py\\\": \\\"import time\\\\nfrom pytestlab.errors import InstrumentNotFoundError, SCPIConnectionError, SCPICommunicationError, SCPIValueError\\\\n\\\\ndef delay(seconds):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Pauses the program for the given number of seconds.\\\\n    \\\\n    Args:\\\\n        seconds (float): Time to pause in seconds.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    time.sleep(seconds)\\\\n\\\\ndef validate_visa_resource(visa_resource):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Validates the VISA resource string format.\\\\n    \\\\n    Args:\\\\n        visa_resource (str): The VISA resource string.\\\\n        \\\\n    Raises:\\\\n        ValueError: If the VISA resource string is in an invalid format.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    if not visa_resource.startswith(\\\\\\\"TCPIP0::\\\\\\\"):\\\\n        raise ValueError(\\\\\\\"Invalid VISA resource format. Please use TCPIP0::<IP_ADDRESS>::INSTR format for LAN instruments.\\\\\\\")\\\\n\\\\ndef check_connection(instrument):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"Checks if the instrument connection is active.\\\\n    \\\\n    Args:\\\\n        instrument (object): The instrument object to check the connection for.\\\\n        \\\\n    Raises:\\\\n        SCPIConnectionError: If unable to connect to the instrument.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    try:\\\\n        response = instrument._query(\\\\\\\"*IDN?\\\\\\\")\\\\n        if response:\\\\n            print(\\\\\\\"Connection to the instrument is active.\\\\\\\")\\\\n    except Exception as e:\\\\n        raise SCPIConnectionError()\\\\n\\\\nclass InstrumentCollection:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"A class to manage a collection of instruments.\\\\n    \\\\n    Attributes:\\\\n        instruments (dict): A dictionary to store instrument objects by their names.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    def __init__(self):\\\\n        self.instruments = {}\\\\n\\\\n    def add(self, name, instrument):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Adds an instrument to the collection.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.instruments[name] = instrument\\\\n\\\\n    def get(self, name):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Gets an instrument by its name.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if name in self.instruments:\\\\n            return self.instruments[name]\\\\n        else:\\\\n            raise InstrumentNotFoundError(name)\\\\n\\\\n    # ... (continue with the remaining methods in the same manner)\\\\n\\\",\\n    \\\"pytestlab\\\\\\\\__init__.py\\\": \\\"\\\",\\n    \\\"pytestlab\\\\\\\\instruments\\\\\\\\AutoInstrument.py\\\": \\\"from pytestlab.instruments.Oscilloscope import Oscilloscope, DigitalOscilloscopeWithJitter\\\\nfrom pytestlab.instruments.DigitalMultimeter import DigitalMultimeter\\\\nfrom pytestlab.instruments.WaveformGenerator import WaveformGenerator\\\\nfrom pytestlab.instruments.DigitalPowerSupply import DigitalPowerSupply\\\\nfrom pytestlab.errors import InstrumentConfigurationError\\\\n\\\\ndef AutoInstrument(profile):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    Automatically instantiate and return an instrument object based on a given profile.\\\\n\\\\n    Args:\\\\n        profile (dict): A dictionary profile containing information about the instrument to be created. \\\\n                            The dictionary should contain a \\\\\\\"device_type\\\\\\\" key with a string value \\\\n                            specifying the type of the device (\\\\\\\"oscilloscope\\\\\\\", \\\\\\\"digital_multimeter\\\\\\\", \\\\n                            \\\\\\\"waveform_generator\\\\\\\", \\\\\\\"digital_power_supply\\\\\\\"). \\\\n                            Additional will be required depending on the device type.\\\\n                            \\\\n    Returns:\\\\n        Object: An instance of the corresponding instrument class, initialized based on the profile.\\\\n\\\\n    Raises:\\\\n        InstrumentConfigurationError: If the device type is not recognized or missing in the profile.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    match profile[\\\\\\\"device_type\\\\\\\"]:\\\\n        case \\\\\\\"oscilloscope\\\\\\\":\\\\n            if profile[\\\\\\\"jitter_analysis\\\\\\\"]:\\\\n                return DigitalOscilloscopeWithJitter(profile[\\\\\\\"visa_resource\\\\\\\"], profile)\\\\n            else:\\\\n                return Oscilloscope(profile[\\\\\\\"visa_resource\\\\\\\"], profile)\\\\n        case \\\\\\\"digital_multimeter\\\\\\\":\\\\n            return DigitalMultimeter(profile[\\\\\\\"visa_resource\\\\\\\"], profile)\\\\n        case \\\\\\\"waveform_generator\\\\\\\":\\\\n            return WaveformGenerator(profile[\\\\\\\"visa_resource\\\\\\\"], profile)\\\\n        case \\\\\\\"digital_power_supply\\\\\\\":\\\\n            return DigitalPowerSupply(profile[\\\\\\\"visa_resource\\\\\\\"], profile)\\\\n        case _:\\\\n            raise InstrumentConfigurationError()\\\\n\\\",\\n    \\\"pytestlab\\\\\\\\instruments\\\\\\\\DigitalMultimeter.py\\\": \\\"from pytestlab.instruments.instrument import SCPIInstrument, SCPIConnectionError, SCPICommunicationError\\\\n\\\\nclass DigitalMultimeter(SCPIInstrument):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    A class representing a Digital Multimeter that inherits from the SCPIInstrument class.\\\\n\\\\n    Provides methods for measuring voltage, current, resistance, frequency, and testing continuity.\\\\n\\\\n    Attributes:\\\\n        visa_resource (str): The VISA address of the device.\\\\n        description (dict): A dictionary containing additional information about the device, including supported channels.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, visa_resource, description):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Initializes a DigitalMultimeter instance.\\\\n\\\\n        Args:\\\\n            visa_resource (str): The VISA address of the device.\\\\n            description (dict): A dictionary containing additional information about the device.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        super().__init__(visa_resource)\\\\n        self.description = description\\\\n\\\\n    def measure_voltage(self, channel=1):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Measures the DC voltage on the specified channel.\\\\n\\\\n        Args:\\\\n            channel (int, optional): The channel number. Default is 1.\\\\n\\\\n        Returns:\\\\n            float: The measured voltage.\\\\n\\\\n        Raises:\\\\n            ValueError: If an invalid channel is specified.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if channel not in self.description[\\\\\\\"voltage_channels\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid voltage channel {channel}. Supported voltage channels: {self.description['voltage_channels']}\\\\\\\")\\\\n        voltage = self._query(f\\\\\\\"MEASURE:VOLTAGE:DC? (@{channel})\\\\\\\")\\\\n        return float(voltage)\\\\n\\\\n    def measure_current(self, channel=1):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Measures the DC current on the specified channel.\\\\n\\\\n        Args:\\\\n            channel (int, optional): The channel number. Default is 1.\\\\n\\\\n        Returns:\\\\n            float: The measured current.\\\\n\\\\n        Raises:\\\\n            ValueError: If an invalid channel is specified.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if channel not in self.description[\\\\\\\"current_channels\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid current channel {channel}. Supported current channels: {self.description['current_channels']}\\\\\\\")\\\\n        current = self._query(f\\\\\\\"MEASURE:CURRENT:DC? (@{channel})\\\\\\\")\\\\n        return float(current)\\\\n\\\\n    def measure_resistance(self, channel=1):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Measures the resistance on the specified channel.\\\\n\\\\n        Args:\\\\n            channel (int, optional): The channel number. Default is 1.\\\\n\\\\n        Returns:\\\\n            float: The measured resistance.\\\\n\\\\n        Raises:\\\\n            ValueError: If an invalid channel is specified.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if channel not in self.description[\\\\\\\"resistance_channels\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid resistance channel {channel}. Supported resistance channels: {self.description['resistance_channels']}\\\\\\\")\\\\n        resistance = self._query(f\\\\\\\"MEASURE:RESISTANCE? (@{channel})\\\\\\\")\\\\n        return float(resistance)\\\\n\\\\n    def measure_frequency(self, channel=1):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Measures the frequency on the specified channel.\\\\n\\\\n        Args:\\\\n            channel (int, optional): The channel number. Default is 1.\\\\n\\\\n        Returns:\\\\n            float: The measured frequency.\\\\n\\\\n        Raises:\\\\n            ValueError: If an invalid channel is specified.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if channel not in self.description[\\\\\\\"frequency_channels\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid frequency channel {channel}. Supported frequency channels: {self.description['frequency_channels']}\\\\\\\")\\\\n        frequency = self._query(f\\\\\\\"MEASURE:FREQUENCY? (@{channel})\\\\\\\")\\\\n        return float(frequency)\\\\n\\\\n    def test_continuity(self, channel=1):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Tests for electrical continuity on the specified channel.\\\\n\\\\n        Args:\\\\n            channel (int, optional): The channel number. Default is 1.\\\\n\\\\n        Returns:\\\\n            bool: True if continuity is present, False otherwise.\\\\n\\\\n        Raises:\\\\n            ValueError: If an invalid channel is specified.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if channel not in self.description[\\\\\\\"continuity_channels\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid continuity channel {channel}. Supported continuity channels: {self.description['continuity_channels']}\\\\\\\")\\\\n        continuity = self._query(f\\\\\\\"TEST:CONTINUITY? (@{channel})\\\\\\\")\\\\n        return bool(int(continuity))  # Assuming continuity returns 1 for True and 0 for False\\\\n\\\",\\n    \\\"pytestlab\\\\\\\\instruments\\\\\\\\DigitalPowerSupply.py\\\": \\\"from pytestlab.instruments.instrument import SCPIInstrument\\\\nfrom pytestlab.errors import SCPICommunicationError\\\\n\\\\nclass DigitalPowerSupply(SCPIInstrument):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    A class representing a Digital Power Supply that inherits from the SCPIInstrument class.\\\\n\\\\n    Provides methods for setting voltage and current, and for enabling or disabling the output.\\\\n\\\\n    Attributes:\\\\n        visa_resource (str): The VISA address of the device.\\\\n        description (dict): A dictionary containing additional information about the device.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, visa_resource, description):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Initializes a DigitalPowerSupply instance.\\\\n\\\\n        Args:\\\\n            visa_resource (str): The VISA address of the device.\\\\n            description (dict): A dictionary containing additional information about the device.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        super().__init__(visa_resource)\\\\n        self.description = description\\\\n\\\\n    def set_voltage(self, voltage, channel=1):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the voltage for the specified channel.\\\\n\\\\n        Args:\\\\n            voltage (float): The voltage value to set.\\\\n            channel (int, optional): The channel number. Default is 1.\\\\n\\\\n        Raises:\\\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_channel_range(channel, voltage, \\\\\\\"voltage\\\\\\\")\\\\n        self._send_command(f\\\\\\\"VOLTAGE{channel} {voltage}\\\\\\\")\\\\n\\\\n    def set_current(self, current, channel=1):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the current for the specified channel.\\\\n\\\\n        Args:\\\\n            current (float): The current value to set.\\\\n            channel (int, optional): The channel number. Default is 1.\\\\n\\\\n        Raises:\\\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_channel_range(channel, current, \\\\\\\"current\\\\\\\")\\\\n        self._send_command(f\\\\\\\"CURRENT{channel} {current}\\\\\\\")\\\\n\\\\n    def enable_output(self, channel=1):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Enables the output for the specified channel.\\\\n\\\\n        Args:\\\\n            channel (int, optional): The channel number. Default is 1.\\\\n\\\\n        Raises:\\\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._send_command(f\\\\\\\"OUTPUT{channel} ON\\\\\\\")\\\\n\\\\n    def disable_output(self, channel=1):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Disables the output for the specified channel.\\\\n\\\\n        Args:\\\\n            channel (int, optional): The channel number. Default is 1.\\\\n\\\\n        Raises:\\\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._send_command(f\\\\\\\"OUTPUT{channel} OFF\\\\\\\")\\\\n\\\",\\n    \\\"pytestlab\\\\\\\\instruments\\\\\\\\instrument.py\\\": \\\"import numpy as np\\\\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError\\\\nfrom pyscpi import usbtmc\\\\nimport time\\\\n\\\\nclass SCPIInstrument:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    A class representing an SCPI-compliant instrument.\\\\n\\\\n    Attributes:\\\\n        visa_resource (str): The VISA resource string that identifies the instrument.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Initialize the SCPIInstrument class.\\\\n\\\\n        Args:\\\\n            visa_resource (str): The VISA resource string to use for the connection.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if visa_resource:\\\\n            self.visa_resource = visa_resource\\\\n            self._connect()\\\\n        elif \\\\\\\"vendor_id\\\\\\\" in profile and \\\\\\\"product_id\\\\\\\" in profile:\\\\n            self.instrument = usbtmc.Instrument(profile[\\\\\\\"vendor_id\\\\\\\"], profile[\\\\\\\"product_id\\\\\\\"])\\\\n        else:\\\\n            raise ValueError(\\\\\\\"Either a VISA resource string or a vendor and product ID must be provided.\\\\\\\")\\\\n        self.profile = profile\\\\n        self._command_log = []\\\\n        self.debug_mode = debug_mode\\\\n\\\\n    def _connect(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Connect to the instrument using the VISA resource string.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            import pyvisa\\\\n            self.instrument = pyvisa.ResourceManager().open_resource(self.visa_resource)\\\\n        except Exception as e:\\\\n            raise SCPIConnectionError(f\\\\\\\"Failed to connect to the instrument: {str(e)}\\\\\\\")\\\\n\\\\n    def _read_to_np(self) -> bytes:\\\\n        chunk_size = 1024\\\\n        data = self.instrument.read_raw(chunk_size)\\\\n        np.frombuffer(data[10:], dtype=np.uint8)\\\\n        header = data[2:10].decode('utf-8')\\\\n        data = np.frombuffer(data[10:], dtype=np.uint8)\\\\n        self._log(header)\\\\n\\\\n        hpoints = int(header)\\\\n\\\\n        while len(data) < hpoints:\\\\n            data = np.append(data, np.frombuffer(\\\\n                self.instrument.read_raw(chunk_size), dtype=np.uint8))\\\\n\\\\n        return data[:-1]\\\\n\\\\n    def _send_command(self, command):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Send an SCPI command to the instrument.\\\\n\\\\n        Args:\\\\n            command (str): The SCPI command to send.\\\\n\\\\n        Raises:\\\\n            SCPICommunicationError: If sending the command fails.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            self.instrument.write(command)\\\\n            self._command_log.append({\\\\\\\"command\\\\\\\": command, \\\\\\\"success\\\\\\\": True, \\\\\\\"type\\\\\\\": \\\\\\\"write\\\\\\\", \\\\\\\"timestamp\\\\\\\":time.time})\\\\n        except Exception as e:\\\\n            raise SCPICommunicationError(f\\\\\\\"Failed to send command: {str(e)}\\\\\\\")\\\\n\\\\n    def _query(self, query):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Query the instrument and return the response.\\\\n\\\\n        Args:\\\\n            query (str): The SCPI query to send.\\\\n\\\\n        Returns:\\\\n            str: The instrument's response to the query.\\\\n\\\\n        Raises:\\\\n            SCPICommunicationError: If the query fails.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            response =  self.instrument.query(query)\\\\n            print(response)\\\\n            self._command_log.append({\\\\\\\"command\\\\\\\": query, \\\\\\\"success\\\\\\\": True, \\\\\\\"type\\\\\\\": \\\\\\\"query\\\\\\\", \\\\\\\"timestamp\\\\\\\":time.time})\\\\n            self.instrument.query(\\\\\\\"*OPC?\\\\\\\")\\\\n            return response\\\\n        except Exception as e:\\\\n            self._command_log.append({\\\\\\\"command\\\\\\\": query, \\\\\\\"success\\\\\\\": False, \\\\\\\"type\\\\\\\": \\\\\\\"query\\\\\\\", \\\\\\\"timestamp\\\\\\\":time.time})\\\\n            raise SCPICommunicationError(f\\\\\\\"Failed to query instrument: {str(e)}\\\\\\\")\\\\n        \\\\n    def _wait(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Blocks until all previous commands have been processed by the instrument.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.instrument.query(\\\\\\\"*OPC?\\\\\\\")\\\\n\\\\n    def _log(self, message):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Log a message.\\\\n\\\\n        Args:\\\\n            message (str): The message to log.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if self.debug_mode:\\\\n            print(message)\\\\n\\\\n    def _history(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Prints history of executed commands\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        for command in self._command_log:\\\\n            print(command)\\\\n    def id(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Query the instrument for its identification.\\\\n\\\\n        Returns:\\\\n            str: The identification string of the instrument.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return self._query(\\\\\\\"*IDN?\\\\\\\")\\\\n    \\\\n    def _check_valid_channel(self, selected_channel):\\\\n        valid_channels = self.profile[\\\\\\\"channels\\\\\\\"].keys()\\\\n        min_limit = min(valid_channels)\\\\n        max_limit = max(valid_channels)\\\\n        assert isinstance(selected_channel, int), f\\\\\\\"Channel must be an integer. Received: {selected_channel}\\\\\\\"\\\\n        assert selected_channel in valid_channels, f\\\\\\\"Invalid Channel Selected: {selected_channel}. Available Channels: {min_limit} to {max_limit}\\\\\\\"\\\\n\\\\n    def close(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Close the connection to the instrument.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.instrument.close()\\\\n\\\\n    def reset(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Reset the instrument to its default settings.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._send_command(\\\\\\\"*RST\\\\\\\")\\\\n\\\\n    def set_channel_voltage(self, channel, voltage):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Set the voltage for a specific channel.\\\\n\\\\n        Args:\\\\n            channel (int or str): The channel for which to set the voltage.\\\\n            voltage (float): The voltage value to set.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_valid_channel(channel)\\\\n        self._send_command(f\\\\\\\"CHAN{channel}:VOLT {voltage}\\\\\\\")\\\\n\\\\n    def get_channel_voltage(self, channel):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Get the voltage for a specific channel.\\\\n\\\\n        Args:\\\\n            channel (int or str): The channel for which to get the voltage.\\\\n\\\\n        Returns:\\\\n            float: The voltage value for the channel.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_valid_channel(channel)\\\\n        response = self._query(f\\\\\\\"CHAN{channel}:VOLT?\\\\\\\")\\\\n        return float(response)\\\\n\\\\n    def measure_frequency(self, channel):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Measure the frequency for a specific channel.\\\\n\\\\n        Args:\\\\n            channel (int or str): The channel for which to measure the frequency.\\\\n\\\\n        Returns:\\\\n            float: The measured frequency value for the channel.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_valid_channel(channel)\\\\n        response = self._query(f\\\\\\\"MEAS:FREQ? CHAN{channel}\\\\\\\")\\\\n        return float(response)\\\\n\\\",\\n    \\\"pytestlab\\\\\\\\instruments\\\\\\\\InstrumentManager.py\\\": \\\"import time\\\\nfrom pytestlab import InstrumentCollection\\\\n\\\\nclass InstrumentManager:\\\\n    def __init__(self):\\\\n        self.instrument_collection = InstrumentCollection()\\\\n\\\\n    # Instrument management methods\\\\n    def add_instrument(self, name, instrument):\\\\n        # Add an instrument to the manager's collection\\\\n        self.instrument[name] = instrument\\\\n\\\\n    def remove_instrument(self, name):\\\\n        # Remove an instrument from the manager's collection\\\\n        del self.instruments[name]\\\\n\\\\n    def get_instrument(self, name):\\\\n        # Get an instrument from the manager's collection\\\\n        return self.instruments[name]\\\\n\\\\n    def list_instruments(self):\\\\n        # List all instruments currently added to the manager\\\\n        print(self.instrument_collection)\\\\n\\\\n    def disconnect_all_instruments(self):\\\\n        # Disconnect all instruments in the manager's collection\\\\n        for i in self.instruments:\\\\n            self.instruments[i].close()\\\\n        pass\\\\n\\\\n    def is_all_instruments_connected(self):\\\\n        # Check if all instruments are connected\\\\n        pass\\\\n\\\\n    def is_instrument_connected(self, name):\\\\n        # Check if a specific instrument is connected\\\\n        pass\\\\n    # Measurement methods\\\\n    def measure_voltage(self, voltage, channel=1):\\\\n        # Perform a voltage measurement\\\\n        pass\\\\n\\\\n    def measure_current(self, current, channel=1):\\\\n        # Perform a current measurement\\\\n        pass\\\\n\\\\n    def measure_power(self, power, channel=1):\\\\n        # Perform a power measurement\\\\n        pass\\\\n\\\\n    def measure_eye_diagram(self, test_pattern, voltage=1.0, current=0.5, channel=1, eye_duration=0.1):\\\\n        power_supply = self.instrument_collection[\\\\\\\"power_supply\\\\\\\"]\\\\n        oscilloscope = self.instrument_collection[\\\\\\\"oscilloscope\\\\\\\"]\\\\n        pattern_generator = self.instrument_collection[\\\\\\\"pattern_generator\\\\\\\"]\\\\n\\\\n        power_supply.set_voltage(voltage, channel)\\\\n        power_supply.set_current(current, channel)\\\\n        power_supply.enable_output(channel)\\\\n\\\\n        pattern_generator.load_pattern(test_pattern)\\\\n        pattern_generator.enable_output()\\\\n\\\\n        oscilloscope.set_channel(channel)\\\\n        oscilloscope.start_measurement()\\\\n\\\\n        # Wait for the test pattern to stabilize and the oscilloscope to capture data\\\\n        time.sleep(eye_duration)\\\\n\\\\n        oscilloscope.stop_measurement()\\\\n        data = oscilloscope.get_measurement_data()\\\\n\\\\n        power_supply.disable_output()\\\\n        pattern_generator.disable_output()\\\\n\\\\n        #Data needs to be processed to generate Eye Diagram by frontend\\\\n        # eye_diagram = process_eye_data(data)\\\\n        return data\\\\n        # return eye_diagram\\\\n\\\\n    def perform_s21_measurement(self, frequency, power_level, channel=1, measurement_time=0.1):\\\\n        signal_generator = self.instrument_collection[\\\\\\\"signal_generator\\\\\\\"]\\\\n        vna = self.instrument_collection[\\\\\\\"vna\\\\\\\"]\\\\n\\\\n        signal_generator.set_frequency(frequency)\\\\n        signal_generator.set_power_level(power_level)\\\\n        signal_generator.enable_output()\\\\n\\\\n        vna.set_channel(channel)\\\\n        vna.set_frequency(frequency)\\\\n        vna.set_power_level(power_level)\\\\n        vna.set_s_parameter(\\\\\\\"S21\\\\\\\")\\\\n        vna.start_measurement()\\\\n\\\\n        # Wait for the measurement to stabilize and complete\\\\n        time.sleep(measurement_time)\\\\n\\\\n        s21_result = vna.get_measurement_data(\\\\\\\"S21\\\\\\\")\\\\n\\\\n        signal_generator.disable_output()\\\\n        vna.stop_measurement()\\\\n\\\\n        return s21_result\\\\n\\\\n        \\\\n    # Calibration methods\\\\n    def calibrate_power_supply(self):\\\\n        # Calibrate the power supply\\\\n        pass\\\\n\\\\n    def calibrate_oscilloscope(self):\\\\n        # Calibrate the oscilloscope\\\\n        pass\\\\n\\\\n    def calibrate_vna(self):\\\\n        # Calibrate the Vector Network Analyzer\\\\n        pass\\\\n\\\\n    # Data handling methods\\\\n    def save_measurement_data(self, data, file_name):\\\\n        # Save measurement data to a file\\\\n        pass\\\\n\\\\n    def load_measurement_data(self, file_name):\\\\n        # Load measurement data from a file\\\\n        pass\\\\n\\\\n    # Instrument configuration methods\\\\n    def configure_power_supply(self, settings):\\\\n        # Configure power supply settings (e.g., voltage limits, current limits)\\\\n        pass\\\\n\\\\n    def configure_oscilloscope(self, settings):\\\\n        # Configure oscilloscope settings (e.g., timebase, trigger settings)\\\\n        pass\\\\n\\\\n    def configure_vna(self, settings):\\\\n        # Configure Vector Network Analyzer settings (e.g., frequency range, calibration)\\\\n        pass\\\\n\\\\n    # Additional utility methods as needed\\\\n    def check_instrument_compatibility(self):\\\\n        # Check if the connected instruments are compatible for the planned measurements\\\\n        pass\\\\n\\\\n    def perform_full_system_check(self):\\\\n        # Perform a comprehensive system check before starting measurements\\\\n        pass\\\\n\\\\n    def report_system_status(self):\\\\n        # Generate a report on the status of connected instruments and overall system health\\\\n        pass\\\\n\\\",\\n    \\\"pytestlab\\\\\\\\instruments\\\\\\\\Oscilloscope.py\\\": \\\"import time\\\\nfrom typing import List\\\\nfrom pytestlab.instruments.instrument import SCPIInstrument\\\\nfrom pytestlab.MeasurementDatabase import MeasurementResult, Preamble, MeasurementValue\\\\nfrom pytestlab.errors import SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\\\\nimport numpy as np\\\\nclass Oscilloscope(SCPIInstrument):\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    Provides an interface for controlling and acquiring data from an oscilloscope using SCPI commands.\\\\n\\\\n    This class inherits from SCPIInstrument and implements specific methods to interact with \\\\n    oscilloscope features such as voltage measurement and timebase scaling.\\\\n\\\\n    Attributes:\\\\n    visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\\\\n    profile (dict): Information about the instrument model.\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Initialize the Oscilloscope class with the given VISA resource and profile information.\\\\n        \\\\n        Args:\\\\n        visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\\\\n        profile (dict): Information about the instrument model.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        super().__init__(visa_resource=visa_resource, profile=profile, debug_mode=debug_mode)\\\\n        assert \\\\\\\"model\\\\\\\" in self.profile, \\\\\\\"Oscilloscope model not specified in profile.\\\\\\\"\\\\n\\\\n    def _read_preamble(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Reads the preamble from the oscilloscope.\\\\n\\\\n        :param inst: The instrument object from pyscpi or pyvisa\\\\n        :param debug: Print debug messages\\\\n        :return: A Preamble object\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n        peram = self._query(':WAVeform:PREamble?')\\\\n        peram = peram.split(',')\\\\n        self._log(peram)\\\\n\\\\n        pre = Preamble(peram[0], peram[1], int(peram[2]), float(peram[4]), float(\\\\n            peram[5]), float(peram[6]), float(peram[7]), float(peram[8]), float(peram[9]))\\\\n\\\\n        return pre\\\\n\\\\n    def _read_wave_data(self, channel: int, points: int) -> np.ndarray:\\\\n\\\\n        self._wait()\\\\n        self._send_command(f':WAVeform:SOURce CHANnel{channel}')\\\\n        self._query('*OPC?')\\\\n        self._log('Reading channel ' + str(channel))\\\\n\\\\n        self._send_command(':WAVeform:FORMat BYTE')\\\\n        self._send_command(':WAVeform:POINts:MODE MAXimum')\\\\n\\\\n        self._log('Reading points')\\\\n\\\\n        if points > 0:\\\\n            self._send_command(f':WAVeform:POINts {points}')\\\\n        else:\\\\n            self._send_command(':WAVeform:POINts MAXimum')\\\\n\\\\n        self._wait()\\\\n\\\\n        self._log('Reading data')\\\\n\\\\n        self._send_command(':WAVeform:DATA?')\\\\n        data = self._read_to_np()\\\\n\\\\n        return data\\\\n    \\\\n    def auto_scale(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Auto scale the oscilloscope display.\\\\n        \\\\n        This method sends an SCPI command to the oscilloscope to auto scale the display.\\\\n        \\\\n        Example:\\\\n        >>> auto_scale()\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._send_command(\\\\\\\":AUToscale\\\\\\\")\\\\n\\\\n    def set_time_axis(self, scale: float, position: float) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the time axis of the Oscilloscope. (x-axis)\\\\n\\\\n        :param scale: scale The scale of the axis in seconds \\\\n        :param position: The position of the time axis from the trigger in seconds\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    \\\\n        self._send_command(f':TIMebase:SCALe {scale}')\\\\n        self._send_command(f':TIMebase:POSition {position}')\\\\n        self._wait()\\\\n    \\\\n    def set_channel_axis(self, channel: int, scale: float, offset: float) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the channel axis of the oscilloscope. (y-axis)\\\\n\\\\n        :param channel: The channel to set\\\\n        :param scale: The scale of the channel axis in volts\\\\n        :param offset: The offset of the channel in volts\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._send_command(f':CHANnel{channel}:SCALe {scale}')\\\\n        self._send_command(f':CHANnel{channel}:OFFSet {offset}')\\\\n        self._wait()\\\\n        \\\\n    def measure_voltage_peak_to_peak(self, channel):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Measure the peak-to-peak voltage for a specified channel.\\\\n        \\\\n        This method sends an SCPI query to the oscilloscope to measure the peak-to-peak voltage \\\\n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\\\\n        \\\\n        Args:\\\\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\\\\n        \\\\n        Returns:\\\\n        MeasurementResult: An object containing the peak-to-peak voltage measurement for the specified channel.\\\\n        \\\\n        Example:\\\\n        >>> measure_voltage_peak_to_peak(\\\\\\\"CH1\\\\\\\")\\\\n        <MeasurementResult object at 0x7f1ec2a4f510>\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_valid_channel(channel)\\\\n\\\\n\\\\n        measurement_result = MeasurementResult(self.profile[\\\\\\\"model\\\\\\\"], \\\\\\\"V\\\\\\\", \\\\\\\"peak to peak voltage\\\\\\\")\\\\n\\\\n        response = self._query(f\\\\\\\"MEAS:VPP? CHAN{channel}\\\\\\\")\\\\n        measurement_result.add(response)\\\\n        return measurement_result\\\\n\\\\n    def measure_rms_voltage(self, channel: int) -> MeasurementResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Measure the root-mean-square (RMS) voltage for a specified channel.\\\\n        \\\\n        This method sends an SCPI query to the oscilloscope to measure the RMS voltage \\\\n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\\\\n        \\\\n        Args:\\\\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\\\\n        \\\\n        Returns:\\\\n        MeasurementResult: An object containing the RMS voltage measurement for the specified channel.\\\\n        \\\\n        Example:\\\\n        >>> measure_rms_voltage(\\\\\\\"CH1\\\\\\\")\\\\n        <MeasurementResult object at 0x7f1ec2a4f590>\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        #Error Handling\\\\n        self._check_valid_channel(channel)\\\\n\\\\n\\\\n        measurement_result = MeasurementResult(self.profile[\\\\\\\"model\\\\\\\"], \\\\\\\"V\\\\\\\", \\\\\\\"rms voltage\\\\\\\")\\\\n        response = self._query(f\\\\\\\"MEAS:VRMS? CHAN{channel}\\\\\\\")\\\\n        measurement_result.add(response)\\\\n        return measurement_result\\\\n\\\\n    def read_channels(self, channels: List[int], points=10000, runAfter=True, timebase=None):\\\\n        if timebase is not None:\\\\n            self.set_timebase_scale(timebase)\\\\n\\\\n        self._log(points)\\\\n        self._log(\\\\\\\"starting\\\\\\\")\\\\n\\\\n        for channel in channels:\\\\n            self._check_valid_channel(channel)\\\\n\\\\n        # Prepare the MeasurementResult dictionary\\\\n        sampling_rate = float(self.get_sampling_rate())\\\\n        measurement_results = {channel: MeasurementResult(instrument=f\\\\\\\"{self.profile['manufacturer']}:{self.profile['model']}\\\\\\\", units=\\\\\\\"V\\\\\\\", measurement_type=\\\\\\\"Voltage\\\\\\\", sampling_rate=sampling_rate, realtime_timestamps=True)\\\\n                            for channel in channels}\\\\n\\\\n        # Setup and digitize commands\\\\n        channel_commands = ', '.join(f\\\\\\\"CHANnel{channel}\\\\\\\" for channel in channels)\\\\n        self._send_command(f\\\\\\\"DIGitize {channel_commands}\\\\\\\")\\\\n        self._send_command(f':WAVeform:SOURce CHANnel{channels[0]}')\\\\n\\\\n        # Read preamble to get scaling factors\\\\n        pream = self._read_preamble()\\\\n\\\\n        # Prepare the time axis once, as it is the same for all channels\\\\n        time_values = (np.arange(0, pream.points, 1) - pream.xref) * pream.xinc + pream.xorg\\\\n\\\\n        for i, channel in enumerate(channels):\\\\n            data = self._read_wave_data(channel, points)\\\\n            if len(data) != pream.points:\\\\n                print('ERROR: points mismatch, please investigate')\\\\n\\\\n            # Calculate the voltage values\\\\n            voltages = (data - pream.yref) * pream.yinc + pream.yorg\\\\n\\\\n            # Populate the MeasurementResult object for this channel\\\\n            for voltage, time_val in zip(voltages, time_values):\\\\n                measurement_results[channel].add(MeasurementValue(voltage, timestamp=time_val))\\\\n\\\\n        if runAfter:\\\\n            self._send_command(\\\\\\\":RUN\\\\\\\")\\\\n\\\\n        return measurement_results\\\\n    \\\\n    # def set_probe_attenuation(self, channel, attenuation):\\\\n    #     \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    #     Sets the probe attenuation for a given channel.\\\\n\\\\n    #     \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    #     self._check_valid_channel(channel)\\\\n    #     # Set the probe attenuation for the specified channel\\\\n    #     self._send_command(f\\\\\\\"CHANnel{channel}:PROBe {attenuation}\\\\\\\")\\\\n\\\\n    def get_sampling_rate(self):\\\\n        # Send the SCPI command to query the current sampling rate\\\\n        response = self._query(\\\\\\\":ACQuire:SRATe?\\\\\\\")\\\\n        \\\\n        # Parse the response to get the sampling rate value.\\\\n        sampling_rate = float(response)\\\\n        \\\\n        return MeasurementValue(sampling_rate, \\\\\\\"Hz\\\\\\\")\\\\n    \\\\n    def set_probe_scale(self, channel, scale):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the probe scale for a given channel.\\\\n\\\\n        Parameters:\\\\n            channel (int): The oscilloscope channel to set the scale for.\\\\n            scale (float): The probe scale value (e.g., 10.0 for 10:1, 1.0 for 1:1).\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_valid_channel(channel)\\\\n\\\\n        # The command format is hypothetical and needs to be adjusted \\\\n        # to match the specific oscilloscope command set.\\\\n        command = f\\\\\\\":PROBe:CH{channel}:ATTenuation {scale}\\\\\\\"\\\\n        self._send_command(command)\\\\n\\\\n        # Confirm the action to the log\\\\n        self._log(f\\\\\\\"Set probe scale to {scale}:1 for channel {channel}.\\\\\\\")\\\\n\\\\n    def set_timebase_scale(self, scale):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Set the timebase scale of the oscilloscope.\\\\n        \\\\n        This method sends an SCPI command to adjust the timebase scale on the oscilloscope display.\\\\n        \\\\n        Args:\\\\n        scale (float): The timebase scale in seconds per division.\\\\n        \\\\n        Example:\\\\n        >>> set_timebase_scale(0.002)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._send_command(f\\\\\\\"TIM:SCAL {scale}\\\\\\\")\\\\n\\\\n    def get_timebase_scale(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Retrieve the current timebase scale setting from the oscilloscope.\\\\n        \\\\n        This method sends an SCPI query to get the current timebase scale and encapsulates \\\\n        the result into a MeasurementResult object.\\\\n        \\\\n        Returns:\\\\n        MeasurementResult: An object containing the current timebase scale setting.\\\\n        \\\\n        Example:\\\\n        >>> get_timebase_scale()\\\\n        <MeasurementResult object at 0x7f1ec2a4f650>\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n        measurement_result = MeasurementResult(self.profile[\\\\\\\"model\\\\\\\"], \\\\\\\"s\\\\\\\", \\\\\\\"timebase scale\\\\\\\")\\\\n        response = self._query(\\\\\\\"TIM:SCAL?\\\\\\\")\\\\n\\\\n        measurement_result.add(response)\\\\n        return measurement_result\\\\n\\\\n    def set_acquisition_time(self, time):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Set the total acquisition time for the oscilloscope.\\\\n\\\\n        ARGS;\\\\n            time (float): The total acquisition time in seconds.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Set the total time for acquisition\\\\n        self._send_command(f\\\\\\\":TIMebase:MAIN:RANGe {time}\\\\\\\")\\\\n\\\\n    def set_sample_rate(self, rate):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the sample rate for the oscilloscope.\\\\n\\\\n        Args:\\\\n        rate (str): The desired sample rate. Valid values are 'MAX' and 'AUTO'.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        rate = rate.upper()\\\\n        valid_values = [\\\\\\\"MAX\\\\\\\", \\\\\\\"AUTO\\\\\\\"]\\\\n        if rate not in valid_values:\\\\n            raise ValueError(f\\\\\\\"Invalid Valid: supported = {valid_values}\\\\\\\")\\\\n        # Set the sample rate for acquisition\\\\n        self._send_command(f\\\\\\\"ACQuire:SRATe {rate}\\\\\\\")\\\\n\\\\n    def set_bandwidth_limit(self, channel, bandwidth):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        \\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_valid_channel(channel)\\\\n        # Limit the bandwidth to a specified frequency to reduce noise\\\\n        self._send_command(f\\\\\\\"CHANnel{channel}:BANDwidth {bandwidth}\\\\\\\")\\\\n\\\\n    # def set_filtering(self, channel, filter_type, frequency):\\\\n    #     self._check_valid_channel(channel)\\\\n    #     # Configure a filter on the channel to isolate the desired frequency components\\\\n    #     if self.profile[\\\\\\\"channels\\\\\\\"][channel][\\\\\\\"filtering\\\\\\\"] != \\\\\\\"available\\\\\\\":\\\\n    #         raise ValueError(f\\\\\\\"Filtering is not available on Channel {channel}.\\\\\\\")\\\\n        \\\\n    #     if channel not in self.profile[\\\\\\\"channels\\\\\\\"]:\\\\n    #         raise ValueError(f\\\\\\\"Invalid channel {channel}. Supported channels: {self.profile['channels']}\\\\\\\")\\\\n\\\\n    #     self._send_command(f\\\\\\\"CHANnel{channel}:FILTer:{filter_type} {frequency}\\\\\\\")\\\\n\\\\n    def set_trigger(self, channel, trigger_level):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the trigger level for a given channel.\\\\n\\\\n        Parameters:\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_valid_channel(channel)\\\\n        # Set the trigger level for the specified channel\\\\n        self._send_command(f\\\\\\\"TRIGger:LEVel CHANnel{channel},{trigger_level}\\\\\\\")\\\\n\\\\n    # def set_trigger_mode(self, mode):\\\\n    #     \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        \\\\n    #     \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    #     if mode not in self.profile[\\\\\\\"trigger_modes\\\\\\\"]:\\\\n    #         raise ValueError(f\\\\\\\"Invalid trigger mode {mode}. Supported trigger modes: {self.profile['trigger_modes']}\\\\\\\")\\\\n    #     # Set the trigger mode to either edge or pulse\\\\n    #     self._send_command(f\\\\\\\"TRIGger:MODE {mode}\\\\\\\")\\\\n\\\\n    def set_trigger_source(self, channel):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        \\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._check_valid_channel(channel)\\\\n        # Set the trigger source to the specified channel\\\\n        self._send_command(f\\\\\\\"TRIGger:SOURce CHANnel{channel}\\\\\\\")\\\\n\\\\n    # def set_trigger_edge_slope(self, slope):\\\\n    #     \\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\\n    #     # Set the edge slope to either rising or falling\\\\n    #     self._send_command(f\\\\\\\"TRIGger:EDGE:SLOPe {slope}\\\\\\\")\\\\n\\\\n    # def set_trigger_pulse_polarity(self, polarity):\\\\n    #     # Set the pulse polarity to either positive or negative\\\\n    #     self._send_command(f\\\\\\\"TRIGger:PULSe:POLarity {polarity}\\\\\\\")\\\\n\\\\n    # def set_trigger_pulse_width(self, width):\\\\n    #     # Set the pulse width to the specified value\\\\n    #     self._send_command(f\\\\\\\"TRIGger:PULSe:WIDth {width}\\\\\\\")\\\\n\\\\n    # def set_trigger_pulse_delay(self, delay):\\\\n    #     # Set the pulse delay to the specified value\\\\n    #     self._send_command(f\\\\\\\"TRIGger:PULSe:DELay {delay}\\\\\\\")\\\\n\\\\n    # def set_trigger_pulse_transition(self, transition):\\\\n    #     # Set the pulse transition to either positive or negative\\\\n    #     self._send_command(f\\\\\\\"TRIGger:PULSe:TRANsition {transition}\\\\\\\")\\\\n\\\\n    # def set_trigger_pulse_condition(self, condition):\\\\n    #     # Set the pulse condition to either width or delay\\\\n    #     self._send_command(f\\\\\\\"TRIGger:PULSe:CONdition {condition}\\\\\\\")\\\\n\\\\n    def wave_gen(self, state: bool):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Enable or disable the waveform generator of the oscilloscope.\\\\n\\\\n        This method sends an SCPI command to enable or disable the function generator in the oscilloscope.\\\\n        \\\\n        Args:\\\\n        state (str): The desired state ('ON' or 'OFF') for the waveform generator.\\\\n        \\\\n        Raises:\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\\\\n        \\\\n        Example:\\\\n        >>> set_wave_gen('ON')\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        # if state not in self.profile[\\\\\\\"function_generator\\\\\\\"]:\\\\n        #     raise ValueError(f\\\\\\\"Invalid state {state}. Supported states: {self.profile['function_generator']}\\\\\\\")\\\\n        \\\\n        self._send_command(f\\\\\\\"WGEN:OUTP {'ON' if state else 'OFF'}\\\\\\\")\\\\n\\\\n    def set_wave_gen_func(self, state):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Set the waveform function for the oscilloscope's waveform generator.\\\\n\\\\n        This method sends an SCPI command to change the function (e.g., 'SINE', 'SQUARE') of the waveform generator.\\\\n        \\\\n        Args:\\\\n        state (str): The desired function ('SINE', 'SQUARE', etc.) for the waveform generator.\\\\n\\\\n        Raises:\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\\\\n\\\\n        Example:\\\\n        >>> set_wave_gen_func('SINE')\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        if state not in self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"waveform_types\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid state {state}. Supported states: {self.profile['function_generator']['waveform_types']}\\\\\\\")\\\\n        \\\\n        self._send_command(f\\\\\\\"WGEN:FUNC {state}\\\\\\\")\\\\n\\\\n    def set_wave_gen_freq(self, freq):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Set the frequency for the waveform generator.\\\\n\\\\n        This method sends an SCPI command to set the frequency of the waveform generator.\\\\n        \\\\n        Args:\\\\n        freq (float): The desired frequency for the waveform generator in Hz.\\\\n\\\\n        Raises:\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the frequency is out of range.\\\\n\\\\n        Example:\\\\n        >>> set_wave_gen_freq(1000.0)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        if freq < self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"frequency\\\\\\\"][\\\\\\\"min\\\\\\\"] or freq > self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"frequency\\\\\\\"][\\\\\\\"max\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\\\\\\\")\\\\n\\\\n        self._send_command(f\\\\\\\"WGEN:FREQ {freq}\\\\\\\")\\\\n\\\\n    def set_wave_gen_amp(self, amp):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Set the amplitude for the waveform generator.\\\\n\\\\n        This method sends an SCPI command to set the amplitude of the waveform generator.\\\\n        \\\\n        Args:\\\\n        amp (float): The desired amplitude for the waveform generator in volts.\\\\n\\\\n        Raises:\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the amplitude is out of range.\\\\n\\\\n        Example:\\\\n        >>> set_wave_gen_amp(1.0)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        if amp < self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"amplitude\\\\\\\"][\\\\\\\"min\\\\\\\"] or amp > self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"amplitude\\\\\\\"][\\\\\\\"max\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\\\\\\\")\\\\n\\\\n        self._send_command(f\\\\\\\"WGEN:VOLT {amp}\\\\\\\")\\\\n\\\\n    def set_wave_gen_offset(self, offset):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Set the voltage offset for the waveform generator.\\\\n\\\\n        This method sends an SCPI command to set the voltage offset of the waveform generator.\\\\n        \\\\n        Args:\\\\n        offset (float): The desired voltage offset for the waveform generator in volts.\\\\n\\\\n        Raises:\\\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the offset is out of range.\\\\n\\\\n        Example:\\\\n        >>> set_wave_gen_offset(0.1)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        if offset < self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"offset\\\\\\\"][\\\\\\\"min\\\\\\\"] or offset > self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"offset\\\\\\\"][\\\\\\\"max\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\\\\\\\")\\\\n        \\\\n        self._send_command(f\\\\\\\"WGEN:VOLT:OFFSet {offset}\\\\\\\")\\\\n\\\\n    def set_wgen_sin(self, amp: float, offset: float, freq: float) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Sets the waveform generator to a sine wave. (Only available on specific models)\\\\n\\\\n        :param amp: The amplitude of the sine wave in volts\\\\n        :param offset: The offset of the sine wave in volts\\\\n        :param freq: The frequency of the sine wave in Hz. The frequency can be adjusted from 100 mHz to 20 MHz.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        if offset < self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"offset\\\\\\\"][\\\\\\\"min\\\\\\\"] or offset > self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"offset\\\\\\\"][\\\\\\\"max\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\\\\\\\")\\\\n        if amp < self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"amplitude\\\\\\\"][\\\\\\\"min\\\\\\\"] or amp > self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"amplitude\\\\\\\"][\\\\\\\"max\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\\\\\\\")\\\\n        if freq < self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"frequency\\\\\\\"][\\\\\\\"min\\\\\\\"] or freq > self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"frequency\\\\\\\"][\\\\\\\"max\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\\\\\\\")\\\\n\\\\n        self._send_command('WGEN:FUNCtion SINusoid')\\\\n        self._send_command(f':WGEN:VOLTage {amp}')\\\\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\\\\n        self._send_command(f':WGEN:FREQuency {freq}')\\\\n\\\\n\\\\n    def set_wgen_square(self, v0: float, v1: float, freq: float, dutyCycle: int) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Sets the waveform generator to a square wave. (Only available on specific models)\\\\n\\\\n        :param v0: The voltage of the low state in volts\\\\n        :param v1: The voltage of the high state in volts\\\\n        :param freq: The frequency of the square wave in Hz. The frequency can be adjusted from 100 mHz to 10 MHz.\\\\n        :param dutyCycle: The duty cycle can be adjusted from 1% to 99% up to 500 kHz. At higher frequencies, the adjustment range narrows so as not to allow pulse widths less than 20 ns.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        \\\\n        self._send_command('WGEN:FUNCtion SQUare')\\\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\\\n        self._send_command(f':WGEN:FREQuency {freq}')\\\\n        self._send_command(f':WGEN:FUNCtion:SQUare:DCYCle {dutyCycle}')\\\\n\\\\n\\\\n    def set_wgen_ramp(self, v0: float, v1: float, freq: float, symmetry: int) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Sets the waveform generator to a ramp wave. (Only available on specific models)\\\\n\\\\n        :param v0: The voltage of the low state in volts\\\\n        :param v1: The voltage of the high state in volts\\\\n        :param freq: The frequency of the ramp wave in Hz. The frequency can be adjusted from 100 mHz to 100 kHz.\\\\n        :param symmetry: Symmetry represents the amount of time per cycle that the ramp waveform is rising and can be adjusted from 0% to 100%.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        \\\\n        self._send_command('WGEN:FUNCtion RAMP')\\\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\\\n        self._send_command(f':WGEN:FREQuency {freq}')\\\\n        self._send_command(f':WGEN:FUNCtion:RAMP:SYMMetry {symmetry}')\\\\n\\\\n\\\\n    def set_wgen_pulse(self, v0: float, v1: float, period: float, pulseWidth: float) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Sets the waveform generator to a pulse wave. (Only available on specific models)\\\\n\\\\n        :param v0: The voltage of the low state in volts\\\\n        :param v1: The voltage of the high state in volts\\\\n        :param period: The period of the pulse wave in seconds. The period can be adjusted from 10 ns to 10 s.\\\\n        :param pulseWidth: The pulse width can be adjusted from 20 ns to the period minus 20 ns.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n\\\\n        self._send_command('WGEN:FUNCtion PULSe')\\\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\\\n        self._send_command(f':WGEN:PERiod {period}')\\\\n        self._send_command(f':WGEN:FUNCtion:PULSe:WIDTh {pulseWidth}')\\\\n\\\\n\\\\n    def set_wgen_dc(self, offset: float) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Sets the waveform generator to a DC wave. (Only available on specific models)\\\\n\\\\n        :param offset: The offset of the DC wave in volts\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        if offset < self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"offset\\\\\\\"][\\\\\\\"min\\\\\\\"] or offset > self.profile[\\\\\\\"function_generator\\\\\\\"][\\\\\\\"offset\\\\\\\"][\\\\\\\"max\\\\\\\"]:\\\\n            raise ValueError(f\\\\\\\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\\\\\\\")\\\\n        \\\\n        self._send_command('WGEN:FUNCtion DC')\\\\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\\\\n\\\\n\\\\n    def set_wgen_noise(self, v0: float, v1: float, offset: float) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Sets the waveform generator to a noise wave. (Only available on specific models)\\\\n\\\\n        :param v0: The voltage of the low state in volts\\\\n        :param v1: The voltage of the high state in volts\\\\n        :param offset: The offset of the noise wave in volts\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        \\\\n        if \\\\\\\"function_generator\\\\\\\" not in self.profile:\\\\n            raise ValueError(f\\\\\\\"Waveform generator is not available on this oscilloscope.\\\\\\\")\\\\n        \\\\n        self._send_command('WGEN:FUNCtion NOISe')\\\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\\\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\\\\n\\\\n    def display_channel(self, channels, state=True) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Display the specified channels on the oscilloscope.\\\\n        \\\\n        This method sends an SCPI command to the oscilloscope to display the specified channels.\\\\n        \\\\n        Args:\\\\n        channels (list): A list of channels to display on the oscilloscope.\\\\n        \\\\n        Raises:\\\\n        ValueError: If the oscilloscope model does not support the specified channel(s).\\\\n        \\\\n        Example:\\\\n        >>> display_channel([\\\\\\\"CH1\\\\\\\", \\\\\\\"CH2\\\\\\\"])\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        for channel in channels:\\\\n            self._check_valid_channel(channel)\\\\n        # Implement SCPI commands to display the specified channels\\\\n        self._send_command(f\\\\\\\"CHAN:{channels}:DISP {'ON' if state else 'OFF'}\\\\\\\")\\\\n\\\\n\\\\n    def fft_display(self, state=True):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Switches on the FFT display\\\\n\\\\n        :param state: The state of the FFT display\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        assert \\\\\\\"fft\\\\\\\" in self.profile, \\\\\\\"FFT is not available on this oscilloscope.\\\\\\\"\\\\n\\\\n        self._send_command(f\\\\\\\":FFT:DISPlay {'ON' if state else 'OFF'}\\\\\\\")\\\\n        self._log(f\\\\\\\"FFT display {'enabled' if state else 'disabled'}.\\\\\\\")\\\\n\\\\n    def function_display(self, state=True):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Switches on the function display\\\\n\\\\n        :param state: The state of the function display\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        \\\\n        self._send_command(f\\\\\\\":FUNCtion:DISPlay {'ON' if state else 'OFF'}\\\\\\\")\\\\n        self._log(f\\\\\\\"Function display {'enabled' if state else 'disabled'}.\\\\\\\")\\\\n\\\\n    def configure_fft(self, source_channel: int, scale: float = None, offset: float = None, window_type: str = 'HANNing', units: str = 'DECibel', display: bool = True):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Configure the oscilloscope to perform an FFT on the specified channel with the given parameters.\\\\n\\\\n        :param source_channel: The channel number to perform FFT on.\\\\n        :param scale: The scale of the FFT display in dB. Defaults to None.\\\\n        :param offset: The offset of the FFT display. Defaults to None.\\\\n        :param window_type: The windowing function to apply. Defaults to 'HANNing'.\\\\n        :param units: The unit of measurement for the FFT (DECibel or VRMS). Defaults to 'DECibel'.\\\\n        :param display: A boolean to turn the FFT display ON or OFF. Defaults to True.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n\\\\n        # Ensure the oscilloscope supports FFT and the specified channel is valid\\\\n        assert \\\\\\\"fft\\\\\\\" in self.profile, \\\\\\\"FFT is not available on this oscilloscope.\\\\\\\"\\\\n        assert source_channel in self.profile[\\\\\\\"channels\\\\\\\"], f\\\\\\\"Invalid channel {source_channel}. Supported channels: {self.profile['channels']}\\\\\\\"\\\\n        assert window_type in self.profile[\\\\\\\"fft\\\\\\\"][\\\\\\\"window_types\\\\\\\"], f\\\\\\\"Invalid window type {window_type}. Supported window types: {self.profile['fft']['window_types']}\\\\\\\"\\\\n        assert units in self.profile[\\\\\\\"fft\\\\\\\"][\\\\\\\"units\\\\\\\"], f\\\\\\\"Invalid units {units}. Supported units: {self.profile['fft']['units']}\\\\\\\"\\\\n\\\\n        # Set the FFT source to the specified channel\\\\n        self._send_command(f':FFT:SOURce1 CHANnel{source_channel}')\\\\n        # Configure the FFT window type\\\\n        self._send_command(f':FFT:WINDow {window_type}')\\\\n        # Configure the FFT vertical type (units)\\\\n        self._send_command(f':FFT:VTYPe {units}')\\\\n        # Set the scale if provided\\\\n        if scale is not None:\\\\n            self._send_command(f':FFT:SCALe {scale}dB')\\\\n        # Set the offset if provided\\\\n        if offset is not None:\\\\n            self._send_command(f':FFT:OFFSet {offset}')\\\\n        # Turn the FFT display on or off based on the parameter\\\\n        display_state = '1' if display else '0'\\\\n        self._send_command(f':FFT:DISPlay {display_state}')\\\\n\\\\n        self._log(f\\\\\\\"FFT configured for channel {source_channel}.\\\\\\\")\\\\n\\\\n    def _convert_binary_block_to_data(self, binary_block):\\\\n        # Process the binary data header to determine the size of the block\\\\n        header_len = int(binary_block[1])  # Assuming the length of the length field itself is 1 byte\\\\n        expected_data_points = int(binary_block[2:2+header_len])\\\\n\\\\n        # Use _read_to_np to read the binary data into a NumPy array\\\\n        data = self._read_to_np()\\\\n\\\\n        # Ensure that we've read the correct number of data points\\\\n        assert len(data) == expected_data_points, \\\\\\\"Data size mismatch\\\\\\\"\\\\n\\\\n        # Data is now in a NumPy array format and can be reshaped or processed as needed\\\\n        # For FRANalysis, the data often comes in pairs representing frequency and response (magnitude/phase)\\\\n        # so we need to reshape the array accordingly\\\\n        data_points_per_entry = 2  # Assuming each data point consists of a frequency and a corresponding value\\\\n        structured_data = data.reshape((-1, data_points_per_entry))\\\\n        \\\\n    def perform_franalysis(self, input_channel, output_channel, start_freq, stop_freq, points=1000, mode='SWEep'):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Perform a frequency response analysis on the oscilloscope.\\\\n\\\\n        :param input_channel: The channel number to use as the input.\\\\n        :param output_channel: The channel number to use as the output.\\\\n        :param start_freq: The start frequency of the analysis in Hz.\\\\n        :param stop_freq: The stop frequency of the analysis in Hz.\\\\n        :param points: The number of points to use for the analysis.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        # Validate input\\\\n        self._check_valid_channel(input_channel)\\\\n        self._check_valid_channel(output_channel)\\\\n        assert mode in ['SWEep', 'SINGle'], 'Mode should be \\\\\\\"SWEep\\\\\\\" or \\\\\\\"SINGle\\\\\\\"'\\\\n        assert 10 <= start_freq < stop_freq <= 20000000, 'Frequency range should be within 10 Hz to 20 MHz'\\\\n        assert points > 0, 'Number of points must be positive'\\\\n\\\\n        # Enable FRANalysis\\\\n        self._send_command(\\\\\\\":FRANalysis:ENABle 1\\\\\\\")\\\\n\\\\n        # Set the start and stop frequencies\\\\n        self._send_command(f\\\\\\\":FRANalysis:FREQuency:STARt {start_freq}Hz\\\\\\\")\\\\n        self._send_command(f\\\\\\\":FRANalysis:FREQuency:STOP {stop_freq}Hz\\\\\\\")\\\\n\\\\n        # Set the mode\\\\n        self._send_command(f\\\\\\\":FRANalysis:FREQuency:MODE {mode}\\\\\\\")\\\\n\\\\n        # If single frequency mode, set the single frequency, otherwise set points for sweep\\\\n        if mode == 'SINGle':\\\\n            self._send_command(f\\\\\\\":FRANalysis:FREQuency:SINGle {start_freq}Hz\\\\\\\")\\\\n        else:\\\\n            # Not directly provided in the command summary, assuming there's a command for points\\\\n            assert points > 0, 'Number of points must be positive'\\\\n            # TODO remove this hard-coded limit - only for DSOX1204G\\\\n            assert points <= 1000, 'Number of points must be less than 1000'\\\\n            self._send_command(f\\\\\\\":FRANalysis:SWEep:POINts {points}\\\\\\\")\\\\n\\\\n        # Initiate FRANalysis\\\\n        self._send_command(\\\\\\\":FRANalysis:RUN\\\\\\\")\\\\n\\\\n        # Wait for analysis to complete and then read the data\\\\n        # The waiting mechanism is not detailed, assuming there's a method for it\\\\n        self._wait()\\\\n        # Read the FRANalysis data (binary block format)\\\\n        franalysis_data = self._query(\\\\\\\":FRANalysis:DATA?\\\\\\\")\\\\n\\\\n        # Process the binary block data into a structured format\\\\n        # Assuming a helper function to convert binary block to numerical data\\\\n        data = self._read_preamble()\\\\n        # data = self._convert_binary_block_to_data(franalysis_data)\\\\n\\\\n        # Disable FRANalysis after completion\\\\n        self._send_command(\\\\\\\":FRANalysis:ENABle 0\\\\\\\")\\\\n\\\\n        # Return the processed data\\\\n        return data\\\\n    \\\\n    def read_fft_data(self) -> MeasurementResult:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Perform the FFT and read the data from the oscilloscope, returning it as a MeasurementResult.\\\\n\\\\n        :return: A MeasurementResult object containing the FFT data.\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._log('Initiating FFT data read.')\\\\n        \\\\n        # The oscilloscope setup for FFT should be done before calling this method\\\\n        # Make sure that the acquisition is already started or in continuous mode\\\\n        \\\\n        # Assuming :FUNCtion:DATA? returns the FFT data from the oscilloscope\\\\n        self._send_command(':FUNCtion:DATA?')\\\\n        fft_data = self._read_to_np()\\\\n        \\\\n        # Now, instead of just returning fft_data, we need to encapsulate it into MeasurementValue objects\\\\n        # and then add these to a MeasurementResult object.\\\\n\\\\n        # For this example, let's assume 'self.sampling_rate' is set and represents the sampling rate used for FFT\\\\n        if self.sampling_rate is None:\\\\n            raise ValueError(\\\\\\\"Sampling rate must be set to read FFT data.\\\\\\\")\\\\n        \\\\n        # Compute the frequency bins for the FFT data\\\\n        freq = np.fft.fftfreq(len(fft_data), 1 / self.sampling_rate)\\\\n        \\\\n        units = self._query(\\\\\\\":FFT:VTYPe?\\\\\\\")\\\\n        # Create a new MeasurementResult for the FFT results\\\\n        fft_measurement_result = MeasurementResult(\\\\n            instrument=self.instrument,  # Replace with actual attribute, if different\\\\n            units=units,  \\\\n            measurement_type=\\\\\\\"Frequency Spectrum\\\\\\\",\\\\n            sampling_rate=self.sampling_rate  # Including the sampling rate for reference\\\\n        )\\\\n        \\\\n        # Populate the MeasurementResult with MeasurementValue objects\\\\n        for f, magnitude in zip(freq, fft_data):\\\\n            fft_measurement_value = MeasurementValue(value=magnitude)\\\\n            # Normally, timestamp would be set to the time the measurement was taken\\\\n            # In this case, we can repurpose it to store the frequency, if that's acceptable for your design\\\\n            fft_measurement_value.timestamp = f\\\\n            fft_measurement_result.add(fft_measurement_value)\\\\n        \\\\n        return fft_measurement_result\\\\n\\\\n# class DigitalOscilloscopeWithJitter(Oscilloscope):\\\\n\\\\n#     def __init__(self, visa_resource, profile):\\\\n#         super().__init__(visa_resource, profile)\\\\n\\\\n#     def _available_jitter_measurements(self, jitter_type):\\\\n#         if jitter_type not in self.profile[\\\\\\\"jitter_analysis\\\\\\\"][\\\\\\\"available_types\\\\\\\"]:\\\\n#             raise ValueError(f\\\\\\\"Invalid jitter type {jitter_type}. Supported jitter types: {self.profile['jitter_analysis']}\\\\\\\")\\\\n\\\\n#     def setup_rms_jitter_measurement(self, channel):\\\\n#         self._available_jitter_measurements(\\\\\\\"rms\\\\\\\")\\\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\\\n#         self._send_command(f\\\\\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\\\\\")\\\\n#         self._send_command(\\\\\\\"MEASure:JITTer:MODE RMS\\\\\\\")\\\\n\\\\n#     def setup_peak_to_peak_jitter_measurement(self, channel):\\\\n#         self._available_jitter_measurements(\\\\\\\"peak_to_peak\\\\\\\")\\\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\\\n#         self._send_command(f\\\\\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\\\\\")\\\\n#         self._send_command(\\\\\\\"MEASure:JITTer:MODE PK2PK\\\\\\\")\\\\n\\\\n#     def setup_period_jitter_measurement(self, channel):\\\\n#         self._available_jitter_measurements(\\\\\\\"period\\\\\\\")\\\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\\\n#         self._send_command(f\\\\\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\\\\\")\\\\n#         self._send_command(\\\\\\\"MEASure:JITTer:MODE PERiod\\\\\\\")\\\\n\\\\n#     def setup_cycle_to_cycle_jitter_measurement(self, channel):\\\\n#         self._available_jitter_measurements(\\\\\\\"cycle_to_cycle\\\\\\\")\\\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\\\n#         self._send_command(f\\\\\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\\\\\")\\\\n#         self._send_command(\\\\\\\"MEASure:JITTer:MODE CCYCle\\\\\\\")\\\\n\\\\n#     def configure_trigger(self, trigger_source, trigger_level):\\\\n#         # Implement SCPI commands to configure trigger settings for jitter measurement\\\\n#         self._send_command(f\\\\\\\"TRIGger:SOURce CHANnel{trigger_source}\\\\\\\")\\\\n#         self._send_command(f\\\\\\\"TRIGger:LEVel CHANnel{trigger_source},{trigger_level}\\\\\\\")\\\\n\\\\n#     def acquire_jitter_data(self):\\\\n#         # Implement SCPI commands to acquire jitter data from the oscilloscope\\\\n#         self._send_command(\\\\\\\"ACQuire:STATE RUN\\\\\\\")\\\\n\\\\n#     def analyze_jitter_data(self):\\\\n#         measurement_result = MeasurementResult(self.profile[\\\\\\\"model\\\\\\\"], \\\\\\\"s\\\\\\\", \\\\\\\"jitter\\\\\\\")\\\\n#         jitter_value = self._query_command(\\\\\\\"MEASure:JITTer?\\\\\\\")\\\\n#         measurement_result.add_measurement(jitter_value)\\\\n#         return measurement_result\\\\n    \\\\n#     def perform_rms_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\\\n#         self.setup_rms_jitter_measurement(channel)\\\\n#         self.configure_trigger(trigger_source, trigger_level)\\\\n#         self.acquire_jitter_data()\\\\n#         return self.analyze_jitter_data()\\\\n    \\\\n#     def perform_peak_to_peak_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\\\n#         \\\\\\\"\\\\\\\"\\\\\\\"\\\\n#         Perform a peak-to-peak jitter measurement on a specified channel with given trigger settings.\\\\n        \\\\n#         This method sets up the measurement, configures the trigger, acquires the jitter data and \\\\n#         then analyzes the data to return a MeasurementResult object containing the results of \\\\n#         the jitter measurement.\\\\n        \\\\n#         Args:\\\\n#         channel (str/int): The identifier for the channel on which the measurement is to be performed.\\\\n#                         This could be an integer representing the channel number or a string representing\\\\n#                         the channel name, depending on the implementation.\\\\n#         trigger_source (str/int): The identifier for the trigger source. This could be an integer or a \\\\n#                                 string representing the source depending on the implementation.\\\\n#         trigger_level (float): The trigger level for the measurement in volts. This value sets the voltage \\\\n#                             level at which the trigger event occurs.\\\\n        \\\\n#         Returns:\\\\n#         MeasurementResult: An object containing the results of the peak-to-peak jitter measurement.\\\\n        \\\\n#         Raises:\\\\n#         NotImplementedError: If any of the method calls within this function (e.g., setup_peak_to_peak_jitter_measurement, \\\\n#                             configure_trigger, acquire_jitter_data, analyze_jitter_data) are not implemented.\\\\n#         MeasurementError: If there is an error during the measurement process.\\\\n        \\\\n#         Example:\\\\n#         >>> perform_peak_to_peak_jitter_measurement(\\\\\\\"CH1\\\\\\\", \\\\\\\"External\\\\\\\", 0.5)\\\\n#         <MeasurementResult object at 0x7f9bd8134f50>\\\\n#         \\\\\\\"\\\\\\\"\\\\\\\"\\\\n#         self.setup_peak_to_peak_jitter_measurement(channel)\\\\n#         self.configure_trigger(trigger_source, trigger_level)\\\\n#         self.acquire_jitter_data()\\\\n#         return self.analyze_jitter_data()\\\\n\\\\n        \\\\n#     def perform_period_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\\\n#         self.setup_period_jitter_measurement(channel)\\\\n#         self.configure_trigger(trigger_source, trigger_level)\\\\n#         self.acquire_jitter_data()\\\\n#         return self.analyze_jitter_data()\\\\n\\\\n#     def perform_cycle_to_cycle_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\\\n#         self.setup_cycle_to_cycle_jitter_measurement(channel)\\\\n#         self.configure_trigger(trigger_source, trigger_level)\\\\n#         self.acquire_jitter_data()\\\\n#         return self.analyze_jitter_data()\\\\n        \\\",\\n    \\\"pytestlab\\\\\\\\instruments\\\\\\\\WaveformGenerator.py\\\": \\\"from pytestlab.instruments.instrument import SCPIInstrument\\\\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\\\\nimport numpy as np\\\\n\\\\nclass WaveformGenerator(SCPIInstrument):\\\\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Initialize a WaveformGenerator instance with a device profile.\\\\n\\\\n        Args:\\\\n            profile (dict): A dictionary containing device profile information.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        super().__init__(visa_resource=visa_resource, profile=profile, debug_mode=debug_mode)\\\\n        assert \\\\\\\"model\\\\\\\" in self.profile, \\\\\\\"Waveform Generator model not specified in profile.\\\\\\\"\\\\n\\\\n    def _validate_waveform(self, waveform_type):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Validate if the waveform type is supported by the device.\\\\n\\\\n        Args:\\\\n            waveform_type (str): The type of waveform to validate.\\\\n\\\\n        Raises:\\\\n            ValueError: If the waveform type is not supported.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        standard_waveforms = [w.upper() for w in self.profile.get('waveforms', {}).get('standard', [])]\\\\n        if waveform_type.upper() not in standard_waveforms:\\\\n            raise ValueError(f\\\\\\\"Invalid waveform type: {waveform_type}. Supported types: {standard_waveforms}\\\\\\\")\\\\n\\\\n    def _validate_frequency(self, frequency):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Validate if the frequency is within the device's supported range.\\\\n\\\\n        Args:\\\\n            frequency (float): The frequency to validate.\\\\n\\\\n        Raises:\\\\n            ValueError: If the frequency is out of range.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        max_frequency = self.profile.get('max_frequency')\\\\n        if frequency > max_frequency:\\\\n            raise ValueError(f\\\\\\\"Frequency out of range. Max supported frequency: {max_frequency}\\\\\\\")\\\\n\\\\n    def _validate_amplitude(self, amplitude):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Validate if the amplitude is within the device's supported range.\\\\n\\\\n        Args:\\\\n            amplitude (float): The amplitude to validate.\\\\n\\\\n        Raises:\\\\n            ValueError: If the amplitude is out of range.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        min_amplitude = self.profile.get('amplitude', {}).get('min', 0)\\\\n        max_amplitude = self.profile.get('amplitude', {}).get('max', float('inf'))\\\\n        if not min_amplitude <= amplitude <= max_amplitude:\\\\n            raise ValueError(f\\\\\\\"Amplitude out of range. Supported range: {min_amplitude} to {max_amplitude}\\\\\\\")\\\\n\\\\n    def _validate_offset(self, offset):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Validate if the offset is within the device's supported range.\\\\n\\\\n        Args:\\\\n            offset (float): The offset to validate.\\\\n\\\\n        Raises:\\\\n            ValueError: If the offset is out of range.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        min_offset = self.profile.get('dc_offset', {}).get('min', float('-inf'))\\\\n        max_offset = self.profile.get('dc_offset', {}).get('max', float('inf'))\\\\n        if not min_offset <= offset <= max_offset:\\\\n            raise ValueError(f\\\\\\\"Offset out of range. Supported range: {min_offset} to {max_offset}\\\\\\\")\\\\n\\\\n    def set_arbitrary_waveform(self, channel, waveform, scale=True):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the arbitrary waveform for the specified channel.\\\\n\\\\n        Args:\\\\n            channel (int or str): The channel for which to set the waveform.\\\\n            waveform (list): The arbitrary waveform to set.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._log(f\\\\\\\"Setting arbitrary waveform for channel {channel}\\\\\\\")\\\\n        waveform_np = np.array(waveform)\\\\n        awg_max_voltage = self.profile[\\\\\\\"amplitude\\\\\\\"][\\\\\\\"max\\\\\\\"]\\\\n        awg_min_voltage = self.profile[\\\\\\\"amplitude\\\\\\\"][\\\\\\\"min\\\\\\\"]\\\\n\\\\n        max_length = self.profile[\\\\\\\"waveforms\\\\\\\"][\\\\\\\"arbitrary\\\\\\\"][\\\\\\\"max_length\\\\\\\"]\\\\n        if scale:\\\\n            waveform_normalized = (waveform - np.min(waveform)) / (np.max(waveform) - np.min(waveform))\\\\n            waveform_scaled = waveform_normalized * (awg_max_voltage - awg_min_voltage) + awg_min_voltage\\\\n            waveform_np = np.array(waveform_scaled)\\\\n            self._log(f\\\\\\\"Waveform scaled to {awg_min_voltage} to {awg_max_voltage} V\\\\\\\")\\\\n            if len(waveform_np) > max_length:\\\\n                # squash into max_length by approximating\\\\n                waveform_np = waveform_np[::int(len(waveform_np) / max_length)] # TODO: improve this approximation\\\\n                self._log(f\\\\\\\"Waveform squashed to {max_length} samples\\\\\\\")\\\\n        else:\\\\n            self._log(f\\\\\\\"Waveform not scaled\\\\\\\")\\\\n            if len(waveform_np) > max_length:\\\\n                self._log(f\\\\\\\"Waveform length exceeds maximum length: {max_length}\\\\\\\")\\\\n                raise ValueError(f\\\\\\\"Waveform length exceeds maximum length: {max_length}\\\\\\\")\\\\n            if np.max(waveform_np) > awg_max_voltage or np.min(waveform_np) < awg_min_voltage:\\\\n                self._log(f\\\\\\\"Waveform exceeds amplitude range: {awg_min_voltage} to {awg_max_voltage}\\\\\\\")\\\\n                raise ValueError(f\\\\\\\"Waveform exceeds amplitude range: {awg_min_voltage} to {awg_max_voltage}\\\\\\\")\\\\n\\\\n        binary_waveform = waveform_np.tobytes()\\\\n\\\\n        self._send_command(f\\\\\\\"SOURCE{channel}:DATA:VOL:CLEAR\\\\\\\")  # Clear the volatile memory\\\\n        self._send_command(f\\\\\\\"SOURCE{channel}:FUNCTION ARBITRAR\\\\\\\")  # Set the source to arbitrary waveform\\\\n        self._send_command(f\\\\\\\"SOURCE{channel}:DATA:ARB:DAC {binary_waveform}, (@1)\\\\\\\")\\\\n\\\\n        self._log(f\\\\\\\"Waveform set\\\\\\\")\\\\n\\\\n    def set_waveform(self, channel, waveform_type):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the waveform type for the specified channel after validation.\\\\n\\\\n        Args:\\\\n            channel (int or str): The channel for which to set the waveform.\\\\n            waveform_type (str): The type of waveform to set.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._validate_waveform(waveform_type)\\\\n        self._send_command(f\\\\\\\"SOUR{channel}:FUNC {waveform_type.upper()}\\\\\\\")\\\\n        self._log(f\\\\\\\"Waveform set to {waveform_type}\\\\\\\")\\\\n\\\\n    def set_frequency(self, channel, frequency):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the frequency for the specified channel after validation.\\\\n\\\\n        Args:\\\\n            channel (int or str): The channel for which to set the frequency.\\\\n            frequency (float): The frequency to set.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._validate_frequency(frequency)\\\\n        self._send_command(f\\\\\\\"SOUR{channel}:FREQ {frequency}\\\\\\\")\\\\n        self._log(f\\\\\\\"Frequency set to {frequency} Hz\\\\\\\")\\\\n\\\\n    def set_amplitude(self, channel, amplitude):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the amplitude for the specified channel after validation.\\\\n\\\\n        Args:\\\\n            channel (int or str): The channel for which to set the amplitude.\\\\n            amplitude (float): The amplitude to set.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._validate_amplitude(amplitude)\\\\n        self._send_command(f\\\\\\\"SOUR{channel}:AMPL {amplitude}\\\\\\\")\\\\n\\\\n    def set_offset(self, channel, offset):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Sets the offset for the specified channel after validation.\\\\n\\\\n        Args:\\\\n            channel (int or str): The channel for which to set the offset.\\\\n            offset (float): The offset to set.\\\\n\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self._validate_offset(offset)\\\\n        self._send_command(f\\\\\\\"SOUR{channel}:OFFS {offset}\\\\\\\")\\\\n\\\\n# # Similar approach can be taken for PatternGenerator\\\\n# class PatternGenerator(SCPIInstrument):\\\\n#     def __init__(self, profile):\\\\n#         \\\\\\\"\\\\\\\"\\\\\\\"\\\\n#         Initialize a PatternGenerator instance with a device profile.\\\\n\\\\n#         Args:\\\\n#             profile (dict): A dictionary containing device profile information.\\\\n\\\\n#         \\\\\\\"\\\\\\\"\\\\\\\"\\\\n#         super().__init__()\\\\n#         self.profile = profile\\\\n\\\\n#     def _validate_pattern(self, pattern):\\\\n#         \\\\\\\"\\\\\\\"\\\\\\\"\\\\n#         Validate if the pattern is supported by the device.\\\\n\\\\n#         Args:\\\\n#             pattern (str): The type of pattern to validate.\\\\n\\\\n#         Raises:\\\\n#             ValueError: If the pattern is not supported.\\\\n\\\\n#         \\\\\\\"\\\\\\\"\\\\\\\"\\\\n#         standard_patterns = [p.upper() for p in self.profile.get('waveforms', {}).get('standard', [])]\\\\n#         if pattern.upper() not in standard_patterns:\\\\n#             raise ValueError(f\\\\\\\"Invalid pattern: {pattern}. Supported types: {standard_patterns}\\\\\\\")\\\\n\\\\n#     def set_pattern(self, channel, pattern):\\\\n#         \\\\\\\"\\\\\\\"\\\\\\\"\\\\n#         Sets the pattern for the specified channel after validation.\\\\n\\\\n#         Args:\\\\n#             channel (int or str): The channel for which to set the pattern.\\\\n#             pattern (str): The type of pattern to set.\\\\n\\\\n#         \\\\\\\"\\\\\\\"\\\\\\\"\\\\n#         self._validate_pattern(pattern)\\\\n#         self._send_command(f\\\\\\\"SOUR{channel}:FUNC {pattern.upper()}\\\\\\\")\\\\n\\\",\\n    \\\"pytestlab\\\\\\\\profiles\\\\\\\\__init__.py\\\": \\\"\\\",\\n    \\\"pytestlab\\\\\\\\profiles\\\\\\\\keysight\\\\\\\\infiniium.py\\\": \\\"\\\\noscilloscope_profile = {\\\\n    \\\\\\\"MXR054A\\\\\\\": {\\\\n    \\\\\\\"manufacturer\\\\\\\": \\\\\\\"Keysight\\\\\\\",\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR054A\\\\\\\", \\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"500 MHz\\\\\\\",\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n    },\\\\n    \\\\\\\"MXR058A\\\\\\\": {\\\\n    \\\\\\\"manufacturer\\\\\\\": \\\\\\\"Keysight\\\\\\\",\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR058A\\\\\\\", \\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n      1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n      2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },  \\\\n      3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n      4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n      5: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n      6: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }, \\\\n      7: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n      8: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"500 MHz\\\\\\\",  \\\\n    \\\\\\\"analog_channels\\\\\\\": 8,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n\\\\n    \\\\\\\"MXR104A\\\\\\\": {\\\\n    # Same as MXR054A except:\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR104A\\\\\\\",\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"1 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n\\\\n  \\\\\\\"MXR108A\\\\\\\": {\\\\n    # Same as MXR058A except: \\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR108A\\\\\\\",\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"1 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n\\\\n  \\\\\\\"MXR204A\\\\\\\": {\\\\n    # Same as MXR054A except:\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR204A\\\\\\\",\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"2 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n\\\\n  \\\\\\\"MXR208A\\\\\\\": {\\\\n    # Same as MXR058A except:\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR208A\\\\\\\",\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"2 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n\\\\n  \\\\\\\"MXR254A\\\\\\\": {\\\\n    # Same as MXR054A except:\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR254A\\\\\\\",\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"2.5 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n  \\\\n  \\\\\\\"MXR258A\\\\\\\": {\\\\n    # Same as MXR058A except:\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR258A\\\\\\\",\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"2.5 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n\\\\n  \\\\\\\"MXR404A\\\\\\\": {\\\\n    # Same as MXR054A except:\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR404A\\\\\\\", \\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"4 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n\\\\n  \\\\\\\"MXR408A\\\\\\\": {\\\\n    # Same as MXR058A except:\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR408A\\\\\\\",\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"4 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n\\\\n  \\\\\\\"MXR604A\\\\\\\": {\\\\n    # Same as MXR054A except:\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR604A\\\\\\\",\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"6 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  },\\\\n\\\\n  \\\\\\\"MXR608A\\\\\\\": {\\\\n    # Same as MXR058A except:\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"MXR608A\\\\\\\",\\\\n    \\\\\\\"bandwidth\\\\\\\": \\\\\\\"6 GHz\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,               \\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],   \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,  \\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Input Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5.0,\\\\n        \\\\\\\"max\\\\\\\": 5.0, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"AC\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10, 100]\\\\n        }\\\\n    },\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min_scale\\\\\\\": 5e-12,\\\\n        \\\\\\\"max_scale\\\\\\\": 200,\\\\n        \\\\\\\"time_units\\\\\\\": [\\\\\\\"s\\\\\\\", \\\\\\\"ms\\\\\\\", \\\\\\\"us\\\\\\\", \\\\\\\"ns\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"trigger\\\\\\\": {\\\\n        \\\\\\\"available_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSE\\\\\\\", \\\\\\\"TIMEOUT\\\\\\\", \\\\\\\"WINDOW\\\\\\\"],\\\\n        \\\\\\\"slope\\\\\\\": [\\\\\\\"RISING\\\\\\\", \\\\\\\"FALLING\\\\\\\", \\\\\\\"EITHER\\\\\\\"],\\\\n        \\\\\\\"external_trigger_input\\\\\\\": [\\\\\\\"AUX\\\\\\\"] \\\\n    },\\\\n    \\\\\\\"analog_channels\\\\\\\": 4,\\\\n    \\\\\\\"sampling_rate\\\\\\\": \\\\\\\"16 GSa/s\\\\\\\",\\\\n    \\\\\\\"standard_memory\\\\\\\": \\\\\\\"200 Mpts/ch\\\\\\\",\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": \\\\\\\"> 200,000 wfms/sec\\\\\\\",\\\\n    \\\\\\\"jitter_analysis\\\\\\\": {\\\\n        \\\\\\\"available_types\\\\\\\": [\\\\\\\"RMS\\\\\\\"],\\\\n        \\\\\\\"jitter_sources\\\\\\\": [\\\\\\\"Time Interval Error\\\\\\\"],\\\\n        \\\\\\\"analysis_depth\\\\\\\": 1e6,\\\\n        \\\\\\\"histogram_bins\\\\\\\": 256, \\\\n        \\\\\\\"modulation_analysis\\\\\\\": False,\\\\n        \\\\\\\"real_time_analysis\\\\\\\": False,\\\\n        \\\\\\\"min_jitter_measurement\\\\\\\": 1e-12,\\\\n        \\\\\\\"max_jitter_measurement\\\\\\\": 1e-3\\\\n    }\\\\n  }\\\\n}\\\",\\n    \\\"pytestlab\\\\\\\\profiles\\\\\\\\keysight\\\\\\\\smartbench.py\\\": \\\"oscilloscope_profile = {\\\\n    \\\\\\\"DSOX1204A\\\\\\\":{\\\\n    \\\\\\\"manufacturer\\\\\\\": \\\\\\\"Keysight\\\\\\\",\\\\n    \\\\\\\"vendor_id\\\\\\\": 0x2A8D,\\\\n    \\\\\\\"product_id\\\\\\\": 0x0396,\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"DSOX1204A\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Analog Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5,\\\\n        \\\\\\\"max\\\\\\\": 5,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"DC\\\\\\\", \\\\\\\"AC\\\\\\\"], \\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10]\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Analog Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5,\\\\n        \\\\\\\"max\\\\\\\": 5,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"DC\\\\\\\", \\\\\\\"AC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Analog Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5,\\\\n        \\\\\\\"max\\\\\\\": 5,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"DC\\\\\\\", \\\\\\\"AC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Analog Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5,\\\\n        \\\\\\\"max\\\\\\\": 5, \\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"DC\\\\\\\", \\\\\\\"AC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10]\\\\n        }\\\\n    },\\\\n    \\\\\\\"bandwidth\\\\\\\": 70e6,\\\\n    \\\\\\\"sampling_rate\\\\\\\": 2e9,\\\\n    \\\\\\\"memory\\\\\\\": 2e6,\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": 2e5,\\\\n    \\\\\\\"trigger_modes\\\\\\\": [\\\\\\\"Edge\\\\\\\", \\\\\\\"Pulse Width\\\\\\\", \\\\\\\"Video\\\\\\\", \\\\\\\"I2C\\\\\\\", \\\\\\\"SPI\\\\\\\", \\\\\\\"UART/RS232\\\\\\\", \\\\\\\"CAN\\\\\\\", \\\\\\\"LIN\\\\\\\"],\\\\n    \\\\\\\"timebase\\\\\\\": {  \\\\n        \\\\\\\"min\\\\\\\": 5e-9,\\\\n        \\\\\\\"max\\\\\\\": 50\\\\n    }\\\\n    },\\\\n    \\\\\\\"DSOX1204G\\\\\\\": {\\\\n    \\\\\\\"manufacturer\\\\\\\": \\\\\\\"Keysight\\\\\\\",\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"DSOX1204G\\\\\\\",\\\\n    \\\\\\\"vendor_id\\\\\\\": 0x2A8D,\\\\n    \\\\\\\"product_id\\\\\\\": 0x0396,\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"Oscilloscope\\\\\\\",\\\\n    \\\\\\\"channels\\\\\\\": {\\\\n        1: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Analog Channel 1\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5,\\\\n        \\\\\\\"max\\\\\\\": 5,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"DC\\\\\\\", \\\\\\\"AC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10],\\\\n        \\\\\\\"timebase\\\\\\\": {\\\\n            \\\\\\\"range\\\\\\\": {\\\\n            \\\\\\\"min\\\\\\\": 5e-9,\\\\n            \\\\\\\"max\\\\\\\": 50\\\\n            },\\\\n            \\\\\\\"horizontal_resolution\\\\\\\": 1e-12\\\\n        }\\\\n        },\\\\n        2: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Analog Channel 2\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5,\\\\n        \\\\\\\"max\\\\\\\": 5,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"DC\\\\\\\", \\\\\\\"AC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10]\\\\n        },\\\\n        3: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Analog Channel 3\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5,\\\\n        \\\\\\\"max\\\\\\\": 5,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"DC\\\\\\\", \\\\\\\"AC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10]\\\\n        },\\\\n        4: {\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"Analog Channel 4\\\\\\\",\\\\n        \\\\\\\"min\\\\\\\": -5,\\\\n        \\\\\\\"max\\\\\\\": 5,\\\\n        \\\\\\\"input_coupling\\\\\\\": [\\\\\\\"DC\\\\\\\", \\\\\\\"AC\\\\\\\"],\\\\n        \\\\\\\"input_impedance\\\\\\\": 1e6,\\\\n        \\\\\\\"probe_attenuation\\\\\\\": [1, 10]\\\\n        }\\\\n    },\\\\n    \\\\\\\"bandwidth\\\\\\\": 70e6,\\\\n    \\\\\\\"sampling_rate\\\\\\\": 2e9,\\\\n    \\\\\\\"memory\\\\\\\": 2e6,\\\\n    \\\\\\\"waveform_update_rate\\\\\\\": 2e5,\\\\n    \\\\\\\"trigger_modes\\\\\\\": [\\\\\\\"EDGE\\\\\\\", \\\\\\\"PULSe\\\\\\\", \\\\\\\"VIDEo\\\\\\\", \\\\\\\"I2C\\\\\\\", \\\\\\\"SPI\\\\\\\", \\\\\\\"UART\\\\\\\", \\\\\\\"RS232\\\\\\\", \\\\\\\"CAN\\\\\\\", \\\\\\\"LIN\\\\\\\"],\\\\n    \\\\\\\"timebase\\\\\\\": {\\\\n        \\\\\\\"min\\\\\\\": 5e-9,\\\\n        \\\\\\\"max\\\\\\\": 50\\\\n    },\\\\n    \\\\\\\"fft\\\\\\\": {\\\\n        \\\\\\\"window_types\\\\\\\": [\\\\\\\"RECTangular\\\\\\\", \\\\\\\"HANNing\\\\\\\", \\\\\\\"FLATtop\\\\\\\", \\\\\\\"BHARris\\\\\\\"],\\\\n        \\\\\\\"units\\\\\\\": [\\\\\\\"DECibel\\\\\\\", \\\\\\\"VRMS\\\\\\\"]\\\\n    },\\\\n    \\\\\\\"function_generator\\\\\\\": {\\\\n        \\\\\\\"waveform_types\\\\\\\": [\\\\\\\"SINusoid\\\\\\\", \\\\\\\"SQUare\\\\\\\", \\\\\\\"RAMp\\\\\\\", \\\\\\\"PULse\\\\\\\", \\\\\\\"NOISe\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n        \\\\\\\"supported_states\\\\\\\": [\\\\\\\"ON\\\\\\\", \\\\\\\"OFF\\\\\\\"],\\\\n        \\\\\\\"offset\\\\\\\": { \\\\n        \\\\\\\"min\\\\\\\": -5,\\\\n        \\\\\\\"max\\\\\\\": 5\\\\n        },\\\\n        \\\\\\\"frequency\\\\\\\": {\\\\n        \\\\\\\"min\\\\\\\": 0.1,\\\\n        \\\\\\\"max\\\\\\\": 20e6\\\\n        },\\\\n        \\\\\\\"amplitude\\\\\\\": {\\\\n        \\\\\\\"min\\\\\\\": 2e-3,\\\\n        \\\\\\\"max\\\\\\\": 20    \\\\n        }\\\\n    }\\\\n    }\\\\n}\\\\n\\\\npower_supply_profile = {\\\\n  \\\\\\\"EDU36311A\\\\\\\": {\\\\n    \\\\\\\"manufacturer\\\\\\\": \\\\\\\"Keysight\\\\\\\",\\\\n    \\\\\\\"vendor_id\\\\\\\": 0x2a8d,\\\\n    \\\\\\\"product_id\\\\\\\": 0x8f01,\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"EDU36311A\\\\\\\",\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"powersupply\\\\\\\",\\\\n    \\\\n    \\\\\\\"outputs\\\\\\\": {\\\\n      1: {\\\\n        \\\\\\\"voltage\\\\\\\": {\\\\n          \\\\\\\"min\\\\\\\": 0,\\\\n          \\\\\\\"max\\\\\\\": 6\\\\n        },\\\\n        \\\\\\\"current\\\\\\\": {\\\\n          \\\\\\\"min\\\\\\\": 0, \\\\n          \\\\\\\"max\\\\\\\": 5\\\\n        }\\\\n      },\\\\n      2: {\\\\n        \\\\\\\"voltage\\\\\\\": {\\\\n          \\\\\\\"min\\\\\\\": 0,\\\\n          \\\\\\\"max\\\\\\\": 30\\\\n        },\\\\n        \\\\\\\"current\\\\\\\": {\\\\n          \\\\\\\"min\\\\\\\": 0,\\\\n          \\\\\\\"max\\\\\\\": 1\\\\n        }\\\\n      },\\\\n      3: {\\\\n        \\\\\\\"voltage\\\\\\\": {\\\\n          \\\\\\\"min\\\\\\\": 0,\\\\n          \\\\\\\"max\\\\\\\": 30\\\\n        },\\\\n        \\\\\\\"current\\\\\\\": {\\\\n          \\\\\\\"min\\\\\\\": 0,\\\\n          \\\\\\\"max\\\\\\\": 1  \\\\n        }\\\\n      }\\\\n    },\\\\n    \\\\n    \\\\\\\"total_power\\\\\\\": 90, \\\\n    \\\\\\\"line_regulation\\\\\\\": 0.01, \\\\n    \\\\\\\"load_regulation\\\\\\\": 0.2,\\\\n    \\\\\\\"programming_accuracy\\\\\\\": {\\\\n      \\\\\\\"voltage\\\\\\\": 0.05,\\\\n      \\\\\\\"current\\\\\\\": 0.2  \\\\n    },\\\\n    \\\\n    \\\\\\\"readback_accuracy\\\\\\\": {\\\\n      \\\\\\\"voltage\\\\\\\": 0.05,\\\\n      \\\\\\\"current\\\\\\\": 0.2\\\\n    },\\\\n    \\\\n    \\\\\\\"interfaces\\\\\\\": [\\\\\\\"USB\\\\\\\", \\\\\\\"LAN\\\\\\\"],\\\\n    \\\\\\\"remote_control\\\\\\\": [\\\\\\\"SCPI\\\\\\\", \\\\\\\"IVI\\\\\\\", \\\\\\\"Web Browser\\\\\\\"]\\\\n  }\\\\n}\\\\n\\\\nawg_profile = {\\\\n  \\\\\\\"EDU33212A\\\\\\\": {\\\\n    \\\\\\\"manufacturer\\\\\\\": \\\\\\\"Keysight\\\\\\\",\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"EDU33212A\\\\\\\", \\\\n    \\\\\\\"vendor_id\\\\\\\": 0x2a8d,\\\\n    \\\\\\\"product_id\\\\\\\": 0x8d01,\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"Arbitrary Waveform Generator\\\\\\\",\\\\n    \\\\n    \\\\\\\"channels\\\\\\\": 1,\\\\n    \\\\\\\"max_frequency\\\\\\\": 20e6, \\\\n    \\\\n    \\\\\\\"waveforms\\\\\\\": {\\\\n      \\\\\\\"standard\\\\\\\": [\\\\\\\"sine\\\\\\\", \\\\\\\"square\\\\\\\", \\\\\\\"ramp\\\\\\\", \\\\\\\"pulse\\\\\\\", \\\\\\\"triangle\\\\\\\", \\\\\\\"noise\\\\\\\", \\\\\\\"PRBS\\\\\\\", \\\\\\\"DC\\\\\\\"],\\\\n      \\\\\\\"built-in\\\\\\\": [\\\\\\\"cardiac\\\\\\\", \\\\\\\"exponential_fall\\\\\\\", \\\\\\\"exponential_rise\\\\\\\", \\\\\\\"gaussian_pulse\\\\\\\", \\\\n                  \\\\\\\"haversine\\\\\\\", \\\\\\\"lorentz\\\\\\\", \\\\\\\"dlorentz\\\\\\\", \\\\\\\"negative_ramp\\\\\\\", \\\\\\\"sinc\\\\\\\"],\\\\n      \\\\\\\"arbitrary\\\\\\\": {\\\\n        \\\\\\\"memory\\\\\\\": 8e6, \\\\n        \\\\\\\"max_length\\\\\\\": 1e6,\\\\n        \\\\\\\"sampling_rate\\\\\\\": {\\\\n          \\\\\\\"min\\\\\\\": 1e-6,\\\\n          \\\\\\\"max\\\\\\\": 250e6\\\\n        },\\\\n        \\\\\\\"resolution\\\\\\\": 16\\\\n      }\\\\n    },\\\\n    \\\\n    \\\\\\\"modulation_types\\\\\\\": [\\\\\\\"AM\\\\\\\", \\\\\\\"FM\\\\\\\", \\\\\\\"PM\\\\\\\", \\\\\\\"FSK\\\\\\\", \\\\\\\"BPSK\\\\\\\", \\\\\\\"PWM\\\\\\\"],\\\\n    \\\\n    \\\\\\\"amplitude\\\\\\\": {\\\\n      \\\\\\\"min\\\\\\\": 1e-3,\\\\n      \\\\\\\"max\\\\\\\": 10\\\\n    },\\\\n    \\\\n    \\\\\\\"dc_offset\\\\\\\": {\\\\n      \\\\\\\"min\\\\\\\": -5,\\\\n      \\\\\\\"max\\\\\\\": 5  \\\\n    },\\\\n\\\\n    \\\\\\\"accuracy\\\\\\\": {\\\\n      \\\\\\\"amplitude\\\\\\\": 0.02, \\\\n      \\\\\\\"frequency\\\\\\\": 1e-6\\\\n    },\\\\n    \\\\n    \\\\\\\"interfaces\\\\\\\": [\\\\\\\"USB\\\\\\\", \\\\\\\"LAN\\\\\\\"], \\\\n    \\\\\\\"remote_control\\\\\\\": [\\\\\\\"SCPI\\\\\\\", \\\\\\\"IVI\\\\\\\", \\\\\\\"Web Browser\\\\\\\"]\\\\n  }\\\\n}\\\\n\\\\nmultimeter_profile = {\\\\n    \\\\\\\"EDU34450A\\\\\\\": {\\\\n    \\\\\\\"manufacturer\\\\\\\": \\\\\\\"Keysight\\\\\\\",\\\\n    \\\\\\\"model\\\\\\\": \\\\\\\"EDU34450A\\\\\\\",\\\\n    \\\\\\\"vendor_id\\\\\\\": 0x2a8d,\\\\n    \\\\\\\"product_id\\\\\\\": 0x8e01,\\\\n    \\\\\\\"device_type\\\\\\\": \\\\\\\"multimeter\\\\\\\",\\\\n\\\\n    \\\\\\\"channels\\\\\\\": 1,\\\\n    \\\\\\\"resolution\\\\\\\": 5.5,\\\\n    \\\\\\\"max_voltage\\\\\\\": 1000,\\\\n    \\\\\\\"max_current\\\\\\\": 10,\\\\n    \\\\\\\"max_resistance\\\\\\\": 100e6,\\\\n    \\\\\\\"max_capacitance\\\\\\\": 10e-6,\\\\n    \\\\\\\"max_frequency\\\\\\\": 1e6,\\\\n    }\\\\n  }\\\"\\n}\",\n    \"README.md\": \"# PyTestLab\\n\\nA Python library for test and measurement  automation and measurement data management.\\n\",\n    \"setup.py\": \"from setuptools import setup, find_packages\\n\\nsetup(\\n    name='pytestlab',\\n    version='0.0.1',\\n    description='A Python library for instrument automation and measurement data management.',\\n    author='Emmanuel Olowe',\\n    author_email='e.a.olowe@ed.ac.uk',\\n    # url='https://github.com/labiium/PyTestLab',\\n    # packages=find_packages(),\\n    # install_requires=[\\n    #     'numpy',\\n    #     # 'scipy',\\n    #     'pandas',\\n    #     # 'pyvisa',\\n    # ],\\n    classifiers=[\\n        'Development Status :: 3 - Alpha',\\n        'Intended Audience :: Developers',\\n        'License :: OSI Approved :: MIT License',\\n        'Programming Language :: Python :: 3',\\n        'Programming Language :: Python :: 3.6',\\n        'Programming Language :: Python :: 3.7',\\n        'Programming Language :: Python :: 3.8',\\n        'Programming Language :: Python :: 3.9',\\n        'Programming Language :: Python :: 3.10',\\n        'Programming Language :: Python :: 3.11',\\n    ],\\n)\\n\",\n    \"examples\\\\description.json\": \"{\\n    \\\"methods\\\": [\\n        {\\n            \\\"name\\\": \\\"add_instrument\\\",\\n            \\\"description\\\": \\\"Add an instrument to the manager's collection.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"name\\\",\\n                    \\\"type\\\": \\\"str\\\",\\n                    \\\"description\\\": \\\"The name of the instrument.\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"instrument\\\",\\n                    \\\"type\\\": \\\"object\\\",\\n                    \\\"description\\\": \\\"The instrument object to be added.\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"remove_instrument\\\",\\n            \\\"description\\\": \\\"Remove an instrument from the manager's collection.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"name\\\",\\n                    \\\"type\\\": \\\"str\\\",\\n                    \\\"description\\\": \\\"The name of the instrument to be removed.\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"get_instrument\\\",\\n            \\\"description\\\": \\\"Get an instrument by name from the manager's collection.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"name\\\",\\n                    \\\"type\\\": \\\"str\\\",\\n                    \\\"description\\\": \\\"The name of the instrument to retrieve.\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"list_instruments\\\",\\n            \\\"description\\\": \\\"List all instruments currently added to the manager.\\\",\\n            \\\"parameters\\\": []\\n        },\\n        {\\n            \\\"name\\\": \\\"connect_all_instruments\\\",\\n            \\\"description\\\": \\\"Connect all instruments in the manager's collection.\\\",\\n            \\\"parameters\\\": []\\n        },\\n        {\\n            \\\"name\\\": \\\"disconnect_all_instruments\\\",\\n            \\\"description\\\": \\\"Disconnect all instruments in the manager's collection.\\\",\\n            \\\"parameters\\\": []\\n        },\\n        {\\n            \\\"name\\\": \\\"is_all_instruments_connected\\\",\\n            \\\"description\\\": \\\"Check if all instruments are connected.\\\",\\n            \\\"parameters\\\": []\\n        },\\n        {\\n            \\\"name\\\": \\\"is_instrument_connected\\\",\\n            \\\"description\\\": \\\"Check if a specific instrument is connected.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"name\\\",\\n                    \\\"type\\\": \\\"str\\\",\\n                    \\\"description\\\": \\\"The name of the instrument to check.\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"measure_voltage\\\",\\n            \\\"description\\\": \\\"Perform a voltage measurement.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"voltage\\\",\\n                    \\\"type\\\": \\\"float\\\",\\n                    \\\"description\\\": \\\"The voltage to measure.\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"channel\\\",\\n                    \\\"type\\\": \\\"int\\\",\\n                    \\\"description\\\": \\\"The channel number to measure (default: 1).\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"measure_current\\\",\\n            \\\"description\\\": \\\"Perform a current measurement.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"current\\\",\\n                    \\\"type\\\": \\\"float\\\",\\n                    \\\"description\\\": \\\"The current to measure.\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"channel\\\",\\n                    \\\"type\\\": \\\"int\\\",\\n                    \\\"description\\\": \\\"The channel number to measure (default: 1).\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"measure_power\\\",\\n            \\\"description\\\": \\\"Perform a power measurement.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"power\\\",\\n                    \\\"type\\\": \\\"float\\\",\\n                    \\\"description\\\": \\\"The power to measure.\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"channel\\\",\\n                    \\\"type\\\": \\\"int\\\",\\n                    \\\"description\\\": \\\"The channel number to measure (default: 1).\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"measure_eye_diagram\\\",\\n            \\\"description\\\": \\\"Perform an Eye Diagram measurement.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"test_pattern\\\",\\n                    \\\"type\\\": \\\"str\\\",\\n                    \\\"description\\\": \\\"The test pattern to use.\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"voltage\\\",\\n                    \\\"type\\\": \\\"float\\\",\\n                    \\\"description\\\": \\\"The voltage for the power supply (default: 1.0 V).\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"current\\\",\\n                    \\\"type\\\": \\\"float\\\",\\n                    \\\"description\\\": \\\"The current for the power supply (default: 0.5 A).\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"channel\\\",\\n                    \\\"type\\\": \\\"int\\\",\\n                    \\\"description\\\": \\\"The channel number to use (default: 1).\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"eye_duration\\\",\\n                    \\\"type\\\": \\\"float\\\",\\n                    \\\"description\\\": \\\"The duration of the eye diagram measurement (default: 0.1 s).\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"perform_s21_measurement\\\",\\n            \\\"description\\\": \\\"Perform an S21 measurement.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"frequency\\\",\\n                    \\\"type\\\": \\\"float\\\",\\n                    \\\"description\\\": \\\"The frequency for the measurement.\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"power_level\\\",\\n                    \\\"type\\\": \\\"float\\\",\\n                    \\\"description\\\": \\\"The power level for the measurement.\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"channel\\\",\\n                    \\\"type\\\": \\\"int\\\",\\n                    \\\"description\\\": \\\"The channel number to use (default: 1).\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"measurement_time\\\",\\n                    \\\"type\\\": \\\"float\\\",\\n                    \\\"description\\\": \\\"The measurement time (default: 0.1 s).\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"calibrate_power_supply\\\",\\n            \\\"description\\\": \\\"Calibrate the power supply.\\\",\\n            \\\"parameters\\\": []\\n        },\\n        {\\n            \\\"name\\\": \\\"calibrate_oscilloscope\\\",\\n            \\\"description\\\": \\\"Calibrate the oscilloscope.\\\",\\n            \\\"parameters\\\": []\\n        },\\n        {\\n            \\\"name\\\": \\\"calibrate_vna\\\",\\n            \\\"description\\\": \\\"Calibrate the Vector Network Analyzer.\\\",\\n            \\\"parameters\\\": []\\n        },\\n        {\\n            \\\"name\\\": \\\"save_measurement_data\\\",\\n            \\\"description\\\": \\\"Save measurement data to a file.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"data\\\",\\n                    \\\"type\\\": \\\"dict\\\",\\n                    \\\"description\\\": \\\"The measurement data to save.\\\"\\n                },\\n                {\\n                    \\\"name\\\": \\\"file_name\\\",\\n                    \\\"type\\\": \\\"str\\\",\\n                    \\\"description\\\": \\\"The name of the file to save the data to.\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"load_measurement_data\\\",\\n            \\\"description\\\": \\\"Load measurement data from a file.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"file_name\\\",\\n                    \\\"type\\\": \\\"str\\\",\\n                    \\\"description\\\": \\\"The name of the file to load the data from.\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"configure_power_supply\\\",\\n            \\\"description\\\": \\\"Configure power supply settings.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"settings\\\",\\n                    \\\"type\\\": \\\"dict\\\",\\n                    \\\"description\\\": \\\"A dictionary containing power supply settings.\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"configure_oscilloscope\\\",\\n            \\\"description\\\": \\\"Configure oscilloscope settings.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"settings\\\",\\n                    \\\"type\\\": \\\"dict\\\",\\n                    \\\"description\\\": \\\"A dictionary containing oscilloscope settings.\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"configure_vna\\\",\\n            \\\"description\\\": \\\"Configure Vector Network Analyzer settings.\\\",\\n            \\\"parameters\\\": [\\n                {\\n                    \\\"name\\\": \\\"settings\\\",\\n                    \\\"type\\\": \\\"dict\\\",\\n                    \\\"description\\\": \\\"A dictionary containing VNA settings.\\\"\\n                }\\n            ]\\n        },\\n        {\\n            \\\"name\\\": \\\"check_instrument_compatibility\\\",\\n            \\\"description\\\": \\\"Check if the connected instruments are compatible for the planned measurements.\\\",\\n            \\\"parameters\\\": []\\n        },\\n        {\\n            \\\"name\\\": \\\"perform_full_system_check\\\",\\n            \\\"description\\\": \\\"Perform a comprehensive system check before starting measurements.\\\",\\n            \\\"parameters\\\": []\\n        },\\n        {\\n            \\\"name\\\": \\\"report_system_status\\\",\\n            \\\"description\\\": \\\"Generate a report on the status of connected instruments and overall system health.\\\",\\n            \\\"parameters\\\": []\\n        }\\n    ]\\n}\",\n    \"examples\\\\digital_multimeter_example.py\": \"from pytestlab.instruments.DigitalMultimeter import DigitalMultimeter\\nimport json\\n# connect to the digital multimeter\\npath_to_description = \\\"/examples/instrument_descriptions/digital_multi_meter.json\\\"\\ndescription = json.load(open(path_to_description, \\\"r\\\"))\\n\\ndigital_multimeter = DigitalMultimeter(description[\\\"visa_resource\\\"], description)\\n\\n# print the id of the digital multimeter\\nprint(digital_multimeter.id())\\n\\n# reset the digital multimeter\\ndigital_multimeter.reset()\\n\\n# set the voltage of channel 1 to 1.5V\\ndigital_multimeter.set_channel_voltage(1, 1.5)\\n\\n# get the voltage of channel 1\\nprint(digital_multimeter.get_channel_voltage(1))\\n\\n\\n# measure the frequency of channel 1\\nprint(digital_multimeter.measure_frequency(1))\\n\\n# close the connection to the digital multimeter\\ndigital_multimeter.close()\",\n    \"examples\\\\oscilloscope_jitter_example.py\": \"from pytestlab.instruments.Oscilloscope import Oscilloscope\\nfrom pytestlab.instruments.InstrumentManager import InstrumentManager\\n\\n# connect to the oscilloscope\\noscilloscope = Oscilloscope(\\\"USB0::0x0957::0x1799::MY58100838::INSTR\\\")\\n\\n# reset oscilloscope\\noscilloscope.reset()\\n\\nprint(oscilloscope.id())\\n\\n# get the voltage of channel 1\\nprint(oscilloscope.get_channel_voltage(1))\\n\\n# measure the frequency of channel 1\\nprint(oscilloscope.measure_frequency(1))\\n\\n# rms jitter measurement\\nprint(oscilloscope.perform_rms_jitter_measurement(1, 0.5))\\n\\n# peak-to-peak jitter measurement\\nprint(oscilloscope.perform_peak_to_peak_jitter_measurement(1, 0.5))\\n\\n# rise time measurement\\nprint(oscilloscope.perform_rise_time_measurement(1, 0.5))\\n\\n# fall time measurement\\nprint(oscilloscope.perform_fall_time_measurement(1, 0.5))\\n\\n# eye diagram measurement\",\n    \"examples\\\\__init__.py\": \"\",\n    \"examples\\\\instrument_descrptions\\\\.oscilloscope_description.py\": \"oscilloscope_description = {\\n    \\\"manufacturer\\\": \\\"Keysight\\\",    # Manufacturer name\\n    \\\"model\\\": \\\"Magic Oscilloscope with 2 Channels\\\",    # Model name/number\\n    \\\"device_type\\\": \\\"oscilloscope\\\", # Device type\\n    \\\"visa_resource\\\": \\\"USB0::0x0957::0x1799::MY58100838::INSTR\\\",   # VISA resource string\\n    \\\"channels\\\": {\\n        1: {\\n            \\\"description\\\": \\\"Input Channel 1\\\",\\n            \\\"min\\\": -5.0,             # Minimum voltage (in volts) supported on Channel 1\\n            \\\"max\\\": 5.0,              # Maximum voltage (in volts) supported on Channel 1\\n            \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\", \\\"GND\\\"],   # List of supported input coupling modes\\n            \\\"input_impedance\\\": 1e6,   # Input impedance (in ohms) for Channel 1\\n            \\\"probe_attenuation\\\": [1, 10, 100],       # List of supported probe attenuation ratios\\n            # Add more channel-specific settings and limitations as needed\\n        },\\n        2: {\\n            \\\"description\\\": \\\"Input Channel 2\\\",\\n            \\\"min\\\": -5.0,             # Minimum voltage (in volts) supported on Channel 2\\n            \\\"max\\\": 5.0,              # Maximum voltage (in volts) supported on Channel 2\\n            \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\", \\\"GND\\\"],   # List of supported input coupling modes\\n            \\\"input_impedance\\\": 1e6,   # Input impedance (in ohms) for Channel 2\\n            \\\"probe_attenuation\\\": [1, 10, 100],       # List of supported probe attenuation ratios\\n            # Add more channel-specific settings and limitations as needed\\n        },\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 1e-9,         # Minimum timebase scale (in seconds) supported\\n        \\\"max_scale\\\": 10.0,         # Maximum timebase scale (in seconds) supported\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"],   # List of supported time units\\n        # Add more timebase-related settings and limitations as needed\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"VIDEO\\\", \\\"USB\\\", \\\"RS232\\\"],   # List of supported trigger modes\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\"],          # List of supported trigger slope options\\n        \\\"external_trigger_input\\\": [\\\"EXT\\\", \\\"EXT/10\\\", \\\"EXT/100\\\"],  # List of supported external trigger inputs\\n        # Add more trigger-related settings and limitations as needed\\n    },\\n    \\\"bandwidth\\\": \\\"0.5 - 6 GHz\\\",            # Oscilloscope bandwidth (in Hz)\\n    \\\"analog_channels\\\": [4, 8],             # Number of analog channels supported (upgradeable)\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",           # Oscilloscope sampling rate (in samples per second)\\n    \\\"standard_memory\\\": \\\"200Mpts/ch\\\",       # Standard memory per channel (in points)\\n    \\\"waveform_update_rate\\\": \\\">200,000 wfms/sec\\\",  # Waveform update rate (in waveforms per second)\\n    # Jitter analysis\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\", \\\"Peak-to-Peak\\\"],   # Types of jitter measurement\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\", \\\"Phase Noise\\\"], # List of selectable jitter sources\\n        \\\"analysis_depth\\\": 1e6,         # Maximum number of cycles or edges that can be analyzed\\n        \\\"histogram_bins\\\": 256,         # Number of histogram bins for jitter distribution\\n        \\\"modulation_analysis\\\": True,   # Supports modulation analysis or not\\n        \\\"real_time_analysis\\\": True,    # Supports real-time jitter analysis or not\\n        \\\"min_jitter_measurement\\\": 1e-12,   # Minimum measurable jitter (in seconds)\\n        \\\"max_jitter_measurement\\\": 1e-3,    # Maximum measurable jitter (in seconds)\\n        # Add more jitter-related settings and limitations as needed\\n    }\\n    # Add more settings and limitations as needed\\n}\\n\",\n    \"examples\\\\instrument_descrptions\\\\digital_multimeter.py\": \"digital_multimeter_description = {\\n    \\\"voltage_channels\\\": [1, 2],   # Supported voltage measurement channels: 1, 2\\n    \\\"current_channels\\\": [1],      # Supported current measurement channels: 1\\n    \\\"voltage_range\\\": 1000,        # Voltage measurement range (in Volts)\\n    \\\"current_range\\\": 10,          # Current measurement range (in Amperes)\\n}\",\n    \"examples\\\\instrument_descrptions\\\\digital_power_supply.py\": \"digital_power_supply_description = {\\n    \\\"channels\\\": {\\n        1: {\\\"min_voltage\\\": 0, \\\"max_voltage\\\": 30},   # Channel 1 voltage range: 0 V to 30 V\\n        2: {\\\"min_voltage\\\": 0, \\\"max_voltage\\\": 30},   # Channel 2 voltage range: 0 V to 30 V\\n    },\\n    \\\"max_current\\\": 5,   # Maximum current (in Amperes) supported by the power supply\\n}\",\n    \"examples\\\\instrument_descrptions\\\\oscilloscope.json\": \"{\\n    \\\"manufacturer\\\": \\\"Keysight\\\",\\n    \\\"model\\\": \\\"Magic Oscilloscope with 2 Channels\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"visa_resource\\\": \\\"USB0::0x0957::0x1799::MY58100838::INSTR\\\",\\n    \\\"channels\\\": {\\n        \\\"1\\\": {\\n            \\\"description\\\": \\\"Input Channel 1\\\",\\n            \\\"min\\\": -5.0,\\n            \\\"max\\\": 5.0,\\n            \\\"input_coupling\\\": [\\n                \\\"AC\\\",\\n                \\\"DC\\\",\\n                \\\"GND\\\"\\n            ],\\n            \\\"input_impedance\\\": 1000000,\\n            \\\"probe_attenuation\\\": [\\n                1,\\n                10,\\n                100\\n            ]\\n        },\\n        \\\"2\\\": {\\n            \\\"description\\\": \\\"Input Channel 2\\\",\\n            \\\"min\\\": -5.0,\\n            \\\"max\\\": 5.0,\\n            \\\"input_coupling\\\": [\\n                \\\"AC\\\",\\n                \\\"DC\\\",\\n                \\\"GND\\\"\\n            ],\\n            \\\"input_impedance\\\": 1000000,\\n            \\\"probe_attenuation\\\": [\\n                1,\\n                10,\\n                100\\n            ]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 1e-9,\\n        \\\"max_scale\\\": 10.0,\\n        \\\"time_units\\\": [\\n            \\\"s\\\",\\n            \\\"ms\\\",\\n            \\\"us\\\",\\n            \\\"ns\\\"\\n        ]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\n            \\\"EDGE\\\",\\n            \\\"PULSE\\\",\\n            \\\"VIDEO\\\",\\n            \\\"USB\\\",\\n            \\\"RS232\\\"\\n        ],\\n        \\\"slope\\\": [\\n            \\\"RISING\\\",\\n            \\\"FALLING\\\"\\n        ],\\n        \\\"external_trigger_input\\\": [\\n            \\\"EXT\\\",\\n            \\\"EXT/10\\\",\\n            \\\"EXT/100\\\"\\n        ]\\n    },\\n    \\\"bandwidth\\\": \\\"0.5 - 6 GHz\\\",\\n    \\\"analog_channels\\\": [\\n        4,\\n        8\\n    ],\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\">200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\n            \\\"RMS\\\",\\n            \\\"Peak-to-Peak\\\"\\n        ],\\n        \\\"jitter_sources\\\": [\\n            \\\"Time Interval Error\\\",\\n            \\\"Phase Noise\\\"\\n        ],\\n        \\\"analysis_depth\\\": 1000000,\\n        \\\"histogram_bins\\\": 256,\\n        \\\"modulation_analysis\\\": true,\\n        \\\"real_time_analysis\\\": true,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n}\",\n    \"examples\\\\instrument_descrptions\\\\train.jsonl\": \"  {\\n    \\\"query\\\": \\\"Automate a frequency measurement on channel 4 with 10 Hz.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a frequency measurement on channel 4. The signal generator will be set to 10 Hz, the output will be enabled, the frequency will be measured, and then the output will be disabled.\\\\n```python\\\\nsignal_generator.set_frequency(10, channel=4)\\\\nsignal_generator.enable_output(channel=4)\\\\nmanager.measure_frequency(10, channel=4)\\\\nsignal_generator.disable_output(channel=4)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a resistance measurement with 100 ohms.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a resistance measurement. The multimeter will be set to measure resistance, a 100-ohm resistor will be connected, and the resistance will be measured.\\\\n```python\\\\nmultimeter.set_to_resistance()\\\\nmanager.connect_resistor(100)\\\\nresistance = multimeter.measure_resistance()\\\\nprint('Measured resistance:', resistance)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a jitter measurement on channel 5 with a peak-to-peak value of 10 ns.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a jitter measurement on channel 5. The oscilloscope will be set to measure jitter with a peak-to-peak value of 10 ns.\\\\n```python\\\\noscilloscope.set_to_jitter(channel=5)\\\\nmanager.set_jitter_pp(10, channel=5)\\\\njitter = oscilloscope.measure_jitter()\\\\nprint('Measured jitter:', jitter)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a rise time measurement on channel 1 with 5 ms.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a rise time measurement on channel 1. The oscilloscope will be set to measure rise time with a value of 5 ms.\\\\n```python\\\\noscilloscope.set_to_rise_time(channel=1)\\\\nmanager.set_rise_time(5, channel=1)\\\\nrise_time = oscilloscope.measure_rise_time()\\\\nprint('Measured rise time:', rise_time)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a fall time measurement on channel 2 with 5 ms.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a fall time measurement on channel 2. The oscilloscope will be set to measure fall time with a value of 5 ms.\\\\n```python\\\\noscilloscope.set_to_fall_time(channel=2)\\\\nmanager.set_fall_time(5, channel=2)\\\\nfall_time = oscilloscope.measure_fall_time()\\\\nprint('Measured fall time:', fall_time)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a Bit Error Rate (BER) measurement with a bit sequence 10101010.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a Bit Error Rate (BER) measurement. The bit sequence 10101010 is sent, and the received bit sequence is checked for errors.\\\\n```python\\\\nmanager.send_bit_sequence('10101010')\\\\nber = manager.measure_ber('10101010')\\\\nprint('Measured BER:', ber)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a power measurement on channel 3 with 5 Watts.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a power measurement on channel 3. The power meter will be set to 5 Watts, the output will be enabled, the power will be measured, and then the output will be disabled.\\\\n```python\\\\npower_meter.set_power(5, channel=3)\\\\npower_meter.enable_output(channel=3)\\\\nmanager.measure_power(5, channel=3)\\\\npower_meter.disable_output(channel=3)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform an impedance measurement with 50 Ohms.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs an impedance measurement. The multimeter will be set to measure impedance, a 50-ohm load will be connected, and the impedance will be measured.\\\\n```python\\\\nmultimeter.set_to_impedance()\\\\nmanager.connect_load(50)\\\\nimpedance = multimeter.measure_impedance()\\\\nprint('Measured impedance:', impedance)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a voltage peak-to-peak measurement on channel 1 with 5 V.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a voltage peak-to-peak measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the voltage will be measured, and then the output will be disabled.\\\\n```python\\\\npower_supply.set_voltage(5, channel=1)\\\\npower_supply.enable_output(channel=1)\\\\nmanager.measure_voltage_pp(5, channel=1)\\\\npower_supply.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a current peak-to-peak measurement on channel 2 with 2 A.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a current peak-to-peak measurement on channel 2. The digital power supply will be set to 2 A, the output will be enabled, the current will be measured, and then the output will be disabled.\\\\n```python\\\\npower_supply.set_current(2, channel=2)\\\\npower_supply.enable_output(channel=2)\\\\nmanager.measure_current_pp(2, channel=2)\\\\npower_supply.disable_output(channel=2)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a pulse width measurement on channel 1 with 5 ms.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a pulse width measurement on channel 1. The pulse generator will be set to 5 ms, the output will be enabled, the pulse width will be measured, and then the output will be disabled.\\\\n```python\\\\npulse_generator.set_pulse_width(5, channel=1)\\\\npulse_generator.enable_output(channel=1)\\\\nmanager.measure_pulse_width(5, channel=1)\\\\npulse_generator.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a phase shift measurement between channels 1 and 2.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a phase shift measurement between channels 1 and 2. The oscilloscope will be set to measure phase shift, and the phase shift will be measured.\\\\n```python\\\\noscilloscope.set_to_phase_shift()\\\\nphase_shift = oscilloscope.measure_phase_shift(channel1=1, channel2=2)\\\\nprint('Measured phase shift:', phase_shift)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a duty cycle measurement on channel 1 with 50%.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a duty cycle measurement on channel 1. The signal generator will be set to a duty cycle of 50%, the output will be enabled, the duty cycle will be measured, and then the output will be disabled.\\\\n```python\\\\nsignal_generator.set_duty_cycle(50, channel=1)\\\\nsignal_generator.enable_output(channel=1)\\\\nmanager.measure_duty_cycle(50, channel=1)\\\\nsignal_generator.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a Signal to Noise Ratio (SNR) measurement with a signal of 5 V and noise of 0.5 V.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a Signal to Noise Ratio (SNR) measurement. The signal of 5 V and noise of 0.5 V is set, and the SNR is measured.\\\\n```python\\\\nmanager.set_signal_and_noise(signal=5, noise=0.5)\\\\nsnr = manager.measure_snr()\\\\nprint('Measured SNR:', snr)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a voltage RMS measurement on channel 1 with 5 V.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a voltage RMS measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the RMS voltage will be measured, and then the output will be disabled.\\\\n```python\\\\npower_supply.set_voltage(5, channel=1)\\\\npower_supply.enable_output(channel=1)\\\\nmanager.measure_voltage_rms(5, channel=1)\\\\npower_supply.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a current RMS measurement on channel 2 with 2 A.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a current RMS measurement on channel 2. The digital power supply will be set to 2 A, the output will be enabled, the RMS current will be measured, and then the output will be disabled.\\\\n```python\\\\npower_supply.set_current(2, channel=2)\\\\npower_supply.enable_output(channel=2)\\\\nmanager.measure_current_rms(2, channel=2)\\\\npower_supply.disable_output(channel=2)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a power factor measurement on channel 1.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a power factor measurement on channel 1. The power meter will be set to measure power factor on channel 1.\\\\n```python\\\\npower_meter.set_to_power_factor(channel=1)\\\\npower_factor = power_meter.measure_power_factor()\\\\nprint('Measured power factor:', power_factor)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a Total Harmonic Distortion (THD) measurement on channel 1.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a Total Harmonic Distortion (THD) measurement on channel 1. The spectrum analyzer will be set to measure THD on channel 1.\\\\n```python\\\\nspectrum_analyzer.set_to_thd(channel=1)\\\\nthd = spectrum_analyzer.measure_thd()\\\\nprint('Measured THD:', thd)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a signal amplitude measurement on channel 1 with 5 V.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a signal amplitude measurement on channel 1. The signal generator will be set to 5 V, the output will be enabled, the signal amplitude will be measured, and then the output will be disabled.\\\\n```python\\\\nsignal_generator.set_amplitude(5, channel=1)\\\\nsignal_generator.enable_output(channel=1)\\\\nmanager.measure_signal_amplitude(5, channel=1)\\\\nsignal_generator.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a latency measurement between channel 1 and channel 2.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a latency measurement between channel 1 and channel 2. The oscilloscope will be set to measure latency between the two channels.\\\\n```python\\\\noscilloscope.set_to_latency()\\\\nlatency = oscilloscope.measure_latency(channel1=1, channel2=2)\\\\nprint('Measured latency:', latency)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a cross-correlation measurement between channel 1 and channel 2.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a cross-correlation measurement between channel 1 and channel 2. The oscilloscope will be set to measure cross-correlation between the two channels.\\\\n```python\\\\noscilloscope.set_to_cross_correlation()\\\\ncross_correlation = oscilloscope.measure_cross_correlation(channel1=1, channel2=2)\\\\nprint('Measured cross-correlation:', cross_correlation)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform an attenuation measurement on channel 1 with 5 dB.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs an attenuation measurement on channel 1. The signal generator will be set to 5 dB, the output will be enabled, the attenuation will be measured, and then the output will be disabled.\\\\n```python\\\\nsignal_generator.set_attenuation(5, channel=1)\\\\nsignal_generator.enable_output(channel=1)\\\\nmanager.measure_attenuation(5, channel=1)\\\\nsignal_generator.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a bandwidth measurement on channel 1 with 5 MHz.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a bandwidth measurement on channel 1. The signal generator will be set to 5 MHz, the output will be enabled, the bandwidth will be measured, and then the output will be disabled.\\\\n```python\\\\nsignal_generator.set_bandwidth(5, channel=1)\\\\nsignal_generator.enable_output(channel=1)\\\\nmanager.measure_bandwidth(5, channel=1)\\\\nsignal_generator.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a gain measurement on channel 1 with 5 dB.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a gain measurement on channel 1. The signal generator will be set to 5 dB, the output will be enabled, the gain will be measured, and then the output will be disabled.\\\\n```python\\\\nsignal_generator.set_gain(5, channel=1)\\\\nsignal_generator.enable_output(channel=1)\\\\nmanager.measure_gain(5, channel=1)\\\\nsignal_generator.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a frequency response measurement on channel 1 from 1 Hz to 1 MHz.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a frequency response measurement on channel 1. The spectrum analyzer will be set from 1 Hz to 1 MHz, the frequency response will be measured, and then the output will be disabled.\\\\n```python\\\\nspectrum_analyzer.set_frequency_range(1, 1e6, channel=1)\\\\nfrequency_response = spectrum_analyzer.measure_frequency_response(channel=1)\\\\nprint('Measured frequency response:', frequency_response)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a delay measurement between channel 1 and channel 2 with 5 ms.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a delay measurement between channel 1 and channel 2. The oscilloscope will be set to measure delay, and the delay will be measured.\\\\n```python\\\\noscilloscope.set_to_delay()\\\\ndelay = oscilloscope.measure_delay(channel1=1, channel2=2)\\\\nprint('Measured delay:', delay)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a power measurement on channel 1 with 5 W.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a power measurement on channel 1. The digital power supply will be set to 5 W, the output will be enabled, the power will be measured, and then the output will be disabled.\\\\n```python\\\\npower_supply.set_power(5, channel=1)\\\\npower_supply.enable_output(channel=1)\\\\nmanager.measure_power(5, channel=1)\\\\npower_supply.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a modulation depth measurement on channel 1 with 50%.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a modulation depth measurement on channel 1. The signal generator will be set to 50%, the output will be enabled, the modulation depth will be measured, and then the output will be disabled.\\\\n```python\\\\nsignal_generator.set_modulation_depth(50, channel=1)\\\\nsignal_generator.enable_output(channel=1)\\\\nmanager.measure_modulation_depth(50, channel=1)\\\\nsignal_generator.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a peak to peak voltage measurement on channel 1 with 5 V.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a peak to peak voltage measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the peak to peak voltage will be measured, and then the output will be disabled.\\\\n```python\\\\npower_supply.set_voltage(5, channel=1)\\\\npower_supply.enable_output(channel=1)\\\\nmanager.measure_peak_to_peak_voltage(5, channel=1)\\\\npower_supply.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a duty cycle measurement on channel 1 with 50%.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a duty cycle measurement on channel 1. The signal generator will be set to 50%, the output will be enabled, the duty cycle will be measured, and then the output will be disabled.\\\\n```python\\\\nsignal_generator.set_duty_cycle(50, channel=1)\\\\nsignal_generator.enable_output(channel=1)\\\\nmanager.measure_duty_cycle(50, channel=1)\\\\nsignal_generator.disable_output(channel=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Automate a temperature measurement on sensor 1 with 25 C.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command automates a temperature measurement on sensor 1. The digital thermometer will be set to 25 C, the measurement will be taken, and then the output will be disabled.\\\\n```python\\\\nthermometer.set_temperature(25, sensor=1)\\\\nmanager.measure_temperature(25, sensor=1)\\\\n```\\\"\\n  },\\n  {\\n    \\\"query\\\": \\\"Perform a phase shift measurement between channel 1 and channel 2 with 90 degrees.\\\",\\n    \\\"command_with_explanation\\\": \\\"This command performs a phase shift measurement between channel 1 and channel 2. The oscilloscope will be set to measure phase shift, and the phase shift will be measured.\\\\n```python\\\\noscilloscope.set_to_phase_shift()\\\\nphase_shift = oscilloscope.measure_phase_shift(channel1=1, channel2=2)\\\\nprint('Measured phase shift:', phase_shift)\\\\n```\\\"\\n  }\\n\",\n    \"examples\\\\instrument_descrptions\\\\waveform_generator_description.py\": \"waveform_generator_description = {\\n    \\\"channels\\\": {\\n        1: {\\\"min\\\": 1, \\\"max\\\": 2},   # Channel 1 voltage range: 1 V to 2 V\\n        2: {\\\"min\\\": 1, \\\"max\\\": 2},   # Channel 2 voltage range: 1 V to 2 V\\n    },\\n    \\\"waveform_types\\\": [\\\"SINE\\\", \\\"SQUARE\\\", \\\"TRIANGLE\\\", \\\"RAMP\\\"],  # Supported waveform types\\n}\",\n    \"pytestlab\\\\errors.py\": \"class SCPIConnectionError(Exception):\\n    \\\"\\\"\\\"For SCPI instrument connection errors.\\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"Failed to connect to the instrument.\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\\nclass SCPICommunicationError(Exception):\\n    \\\"\\\"\\\"For SCPI communication errors.\\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"Error in SCPI communication.\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\\nclass SCPIValueError(ValueError):\\n    \\\"\\\"\\\"For invalid SCPI values or settings.\\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"Invalid value for SCPI command.\\\"):\\n        self.message = message\\n        super().__init__(self.message)\\n\\nclass InstrumentNotFoundError(Exception):\\n    \\\"\\\"\\\"For instrument not found errors.\\\"\\\"\\\"\\n\\n    def __init__(self, name):\\n        super().__init__(f\\\"Instrument {name} not found in the manager's collection.\\\")\\n\\n\\nclass IntrumentConfigurationError(Exception):\\n    \\\"\\\"\\\"For instrument configuration errors.\\\"\\\"\\\"\\n\\n    def __init__(self, message=\\\"Invalid Instrument configuration.\\\"):\\n        self.message = message\\n        super().__init__(self.message)\",\n    \"pytestlab\\\\MeasurementDatabase.py\": \"import sqlite3\\nimport time\\nimport numpy as np\\nfrom datetime import datetime\\nfrom dataclasses import dataclass\\nimport matplotlib.pyplot as plt\\n\\n@dataclass\\nclass Preamble:\\n    \\\"\\\"\\\"A class to store the preamble data from the oscilloscope channel.\\n\\n    :param format: The format of the data\\n    :param type: The type of the data\\n    :param points: The number of points\\n    :param xinc: The x increment\\n    :param xorg: The x origin\\n    :param xref: The x reference\\n    :param yinc: The y increment\\n    :param yorg: The y origin\\n    :param yref: The y reference\\n    \\\"\\\"\\\"\\n\\n    format: str\\n    type: str\\n    points: int\\n    xinc: float\\n    xorg: float\\n    xref: float\\n    yinc: float\\n    yorg: float\\n    yref: float\\n\\nclass MeasurementValue:\\n    \\\"\\\"\\\"A class to represent a single measurement value and its timestamp.\\n    \\n    Attributes:\\n        value (float): The measurement value.\\n        units (str): The units of the measurement value (e.g. \\\"V\\\", \\\"A\\\", \\\"Ohm\\\", \\\"Hz\\\").\\n        timestamp (float): The timestamp when the measurement was taken.\\n    \\\"\\\"\\\"\\n    def __init__(self, value, units=\\\"units\\\", timestamp=None):\\n        self.value = float(value)\\n        self.units = units\\n        self.timestamp = timestamp if timestamp else time.time()\\n\\n    def __str__(self):\\n        return f\\\"{self.value}\\\"\\n\\n    def __float__(self):\\n        return self.value\\n    \\nclass MeasurementResult:\\n    \\\"\\\"\\\"A class to represent a collection of measurement values.\\n    \\n    Attributes:\\n        values (list): A list of MeasurementValue objects.\\n        units (str): The units of the measurements.\\n        instrument (str): The name of the instrument used for the measurements.\\n        measurement_type (str): The type of measurement.\\n    \\\"\\\"\\\"\\n    def __init__(self, instrument, units, measurement_type, sampling_rate=None, realtime_timestamps=False):\\n        self.values = []\\n        self.units = units\\n        self.instrument = instrument\\n        self.timestamp = time.time()\\n        self.realtime_timestamps = realtime_timestamps\\n        self.measurement_type = measurement_type\\n        self.sampling_rate = sampling_rate\\n\\n    def __str__(self):\\n        string = \\\"\\\"\\n        for value in self.values:\\n            string += f\\\"{value} {self.units}\\\\n\\\"\\n\\n        # remove last newline\\n        string = string[:-1]\\n        return string\\n    \\n    def __repr__(self):\\n        return str(self)\\n    \\n    def add(self, value):\\n        \\\"\\\"\\\"Adds a new MeasurementValue to the collection.\\\"\\\"\\\"\\n        ## append to numpy array\\n        if value.units != self.units and self.units != \\\"units\\\" and value.units != \\\"units\\\":\\n            raise ValueError(\\\"MeasurementValue units must match MeasurementResult units.\\\")\\n        self.values = np.append(self.values, value)\\n\\n    def set_values(self, values):\\n        \\\"\\\"\\\"Sets the MeasurementValues in the collection.\\\"\\\"\\\"\\n        self.values = values\\n\\n    def get(self, index):\\n        \\\"\\\"\\\"Gets the MeasurementValue at a specified index.\\\"\\\"\\\"\\n        return self.values[index]\\n\\n    def get_all(self):\\n        \\\"\\\"\\\"Returns all the MeasurementValues in the collection.\\\"\\\"\\\"\\n        return self.values\\n\\n    def clear(self):\\n        \\\"\\\"\\\"Clears all the MeasurementValues from the collection.\\\"\\\"\\\"\\n        self.values.clear()\\n    \\n    def plot(self, title=None, xlabel=None, ylabel=None):\\n        \\\"\\\"\\\"\\n        Generates a plot of the measurement values.\\n\\n        Args:\\n            title (str, optional): The title of the plot.\\n            xlabel (str, optional): The label for the x-axis.\\n            ylabel (str, optional): The label for the y-axis.\\n        \\\"\\\"\\\"\\n        timestamps = [value.timestamp for value in self.values]\\n        measurements = [value.value for value in self.values]\\n        \\n        plt.figure(figsize=(10, 5))\\n        if self.realtime_timestamps:\\n            plt.plot(timestamps, measurements, marker='o')\\n        else:\\n            plt.plot(measurements, marker='o')\\n        if title:\\n            plt.title(title)\\n        \\n        xlabel = xlabel if xlabel else \\\"Time (s)\\\"\\n        ylabel = ylabel if ylabel else f\\\"Measurement ({self.units})\\\"\\n        \\n        plt.xlabel(xlabel)\\n        plt.ylabel(ylabel)\\n        plt.grid(True)\\n        plt.show()\\n\\n    def perform_fft(self):\\n        \\\"\\\"\\\"Performs FFT on the measurement values and returns a MeasurementResult object\\n        for the frequency spectrum.\\n\\n        Returns:\\n            MeasurementResult: An object with frequencies as its measurement values.\\n        \\\"\\\"\\\"\\n        # check if is a time-domain measurement\\n        if self.measurement_type == \\\"Frequency Spectrum\\\":\\n            raise ValueError(\\\"Cannot perform FFT on Frequency Spectrum measurement.\\\")\\n        if self.sampling_rate is None:\\n            raise ValueError(\\\"Sampling rate must be set to perform FFT.\\\")\\n\\n        # Extract the measurement values and convert them to a numpy array\\n        data = np.array([value.value for value in self.values])\\n\\n        # Perform the FFT\\n        fft_result = np.fft.fft(data)\\n\\n        # Compute the frequency bins\\n        freq = np.fft.fftfreq(len(fft_result), 1 / self.sampling_rate)\\n\\n        # Calculate the magnitudes\\n        magnitudes = np.abs(fft_result)\\n\\n\\n        # Create a new MeasurementResult for the FFT results\\n        fft_measurement_result = MeasurementResult(\\n            instrument=self.instrument,\\n            units=self.units,\\n            measurement_type=\\\"Frequency Spectrum\\\",\\n            sampling_rate=self.sampling_rate,  #  for reference\\n            realtime_timestamps=self.realtime_timestamps\\n        )\\n\\n        # Populate the FFT MeasurementResult with frequency and magnitude pairs\\n        for f, magnitude in zip(freq, magnitudes):\\n            fft_measurement_value = MeasurementValue(value=magnitude)\\n            # Normally we would set the timestamp to the frequency value\\n            # Misuse the timestamp here for plotting purposes\\n            fft_measurement_value.timestamp = f\\n            fft_measurement_result.add(fft_measurement_value)\\n\\n        return fft_measurement_result\\n    \\n    def __len__(self):\\n        return len(self.values)\\n\\n    def __getitem__(self, index):\\n        return self.values[index]\\n\\n    def __iter__(self):\\n        return iter(self.values)\\n\\n    def __delitem__(self, index):\\n        del self.values[index]\\n\\nclass MeasurementDatabase:\\n    \\\"\\\"\\\"\\n    A class for managing a SQLite database that stores measurement results.\\n    \\\"\\\"\\\"\\n    def __init__(self, db_path):\\n        self.db_path = db_path\\n        self._create_tables()\\n\\n    def _create_tables(self):\\n        with self._get_connection() as conn:\\n            conn.execute('''\\n                CREATE TABLE IF NOT EXISTS instruments (\\n                    instrument_id INTEGER PRIMARY KEY AUTOINCREMENT,\\n                    name TEXT NOT NULL UNIQUE\\n                )\\n            ''')\\n            conn.execute('''\\n                CREATE TABLE IF NOT EXISTS measurements (\\n                    measurement_id INTEGER PRIMARY KEY AUTOINCREMENT,\\n                    instrument_id INTEGER NOT NULL,\\n                    timestamp TIMESTAMP NOT NULL,\\n                    value REAL NOT NULL,\\n                    units TEXT NOT NULL,\\n                    type TEXT NOT NULL, -- 'reading' or 'fft'\\n                    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id)\\n                )\\n            ''')\\n\\n    def _get_connection(self):\\n        return sqlite3.connect(self.db_path)\\n\\n    def store_reading(self, measurement_result: MeasurementResult):\\n        \\\"\\\"\\\"\\n        Stores a time-domain measurement result in the database.\\n        \\\"\\\"\\\"\\n        with self._get_connection() as conn:\\n            # Get or create the instrument_id\\n            instrument_id = self._get_or_create_instrument_id(conn, measurement_result.instrument)\\n\\n            # Store each MeasurementValue\\n            for measurement in measurement_result:\\n                conn.execute('''\\n                    INSERT INTO measurements (instrument_id, timestamp, value, units, type)\\n                    VALUES (?, ?, ?, ?, ?)\\n                ''', (instrument_id, datetime.fromtimestamp(measurement.timestamp),\\n                      measurement.value, measurement_result.units, 'reading'))\\n\\n    def store_fft_result(self, fft_result: MeasurementResult):\\n        \\\"\\\"\\\"\\n        Stores an FFT measurement result in the database.\\n        \\\"\\\"\\\"\\n        with self._get_connection() as conn:\\n            # Get or create the instrument_id\\n            instrument_id = self._get_or_create_instrument_id(conn, fft_result.instrument)\\n\\n            # Store each FFT result (frequency, magnitude)\\n            for measurement in fft_result:\\n                # Assuming timestamp field is reused to store frequency\\n                conn.execute('''\\n                    INSERT INTO measurements (instrument_id, timestamp, value, units, type)\\n                    VALUES (?, ?, ?, ?, ?)\\n                ''', (instrument_id, measurement.timestamp, measurement.value,\\n                      fft_result.units, 'fft'))\\n\\n    def _get_or_create_instrument_id(self, conn, instrument_name):\\n        \\\"\\\"\\\"\\n        Retrieves the instrument ID for the given name, or creates it if it doesn't exist.\\n        \\\"\\\"\\\"\\n        cursor = conn.execute('SELECT instrument_id FROM instruments WHERE name = ?', (instrument_name,))\\n        result = cursor.fetchone()\\n        if result:\\n            return result[0]\\n        else:\\n            cursor.execute('INSERT INTO instruments (name) VALUES (?)', (instrument_name,))\\n            return cursor.lastrowid\\n\\n    def retrieve_measurements(self, instrument_name, measurement_type):\\n        \\\"\\\"\\\"\\n        Retrieves measurements from the database by instrument name and measurement type.\\n        \\\"\\\"\\\"\\n        with self._get_connection() as conn:\\n            cursor = conn.execute('''\\n                SELECT m.timestamp, m.value, m.units\\n                FROM measurements m\\n                JOIN instruments i ON m.instrument_id = i.instrument_id\\n                WHERE i.name = ? AND m.type = ?\\n            ''', (instrument_name, measurement_type))\\n            return cursor.fetchall()\",\n    \"pytestlab\\\\utilities.py\": \"import time\\nfrom pytestlab.errors import InstrumentNotFoundError, SCPIConnectionError, SCPICommunicationError, SCPIValueError\\n\\ndef delay(seconds):\\n    \\\"\\\"\\\"Pauses the program for the given number of seconds.\\n    \\n    Args:\\n        seconds (float): Time to pause in seconds.\\n    \\\"\\\"\\\"\\n    time.sleep(seconds)\\n\\ndef validate_visa_resource(visa_resource):\\n    \\\"\\\"\\\"Validates the VISA resource string format.\\n    \\n    Args:\\n        visa_resource (str): The VISA resource string.\\n        \\n    Raises:\\n        ValueError: If the VISA resource string is in an invalid format.\\n    \\\"\\\"\\\"\\n    if not visa_resource.startswith(\\\"TCPIP0::\\\"):\\n        raise ValueError(\\\"Invalid VISA resource format. Please use TCPIP0::<IP_ADDRESS>::INSTR format for LAN instruments.\\\")\\n\\ndef check_connection(instrument):\\n    \\\"\\\"\\\"Checks if the instrument connection is active.\\n    \\n    Args:\\n        instrument (object): The instrument object to check the connection for.\\n        \\n    Raises:\\n        SCPIConnectionError: If unable to connect to the instrument.\\n    \\\"\\\"\\\"\\n    try:\\n        response = instrument._query(\\\"*IDN?\\\")\\n        if response:\\n            print(\\\"Connection to the instrument is active.\\\")\\n    except Exception as e:\\n        raise SCPIConnectionError()\\n\\nclass InstrumentCollection:\\n    \\\"\\\"\\\"A class to manage a collection of instruments.\\n    \\n    Attributes:\\n        instruments (dict): A dictionary to store instrument objects by their names.\\n    \\\"\\\"\\\"\\n    def __init__(self):\\n        self.instruments = {}\\n\\n    def add(self, name, instrument):\\n        \\\"\\\"\\\"Adds an instrument to the collection.\\\"\\\"\\\"\\n        self.instruments[name] = instrument\\n\\n    def get(self, name):\\n        \\\"\\\"\\\"Gets an instrument by its name.\\\"\\\"\\\"\\n        if name in self.instruments:\\n            return self.instruments[name]\\n        else:\\n            raise InstrumentNotFoundError(name)\\n\\n    # ... (continue with the remaining methods in the same manner)\\n\",\n    \"pytestlab\\\\__init__.py\": \"\",\n    \"pytestlab\\\\instruments\\\\AutoInstrument.py\": \"from pytestlab.instruments.Oscilloscope import Oscilloscope, DigitalOscilloscopeWithJitter\\nfrom pytestlab.instruments.DigitalMultimeter import DigitalMultimeter\\nfrom pytestlab.instruments.WaveformGenerator import WaveformGenerator\\nfrom pytestlab.instruments.DigitalPowerSupply import DigitalPowerSupply\\nfrom pytestlab.errors import InstrumentConfigurationError\\n\\ndef AutoInstrument(profile):\\n    \\\"\\\"\\\"\\n    Automatically instantiate and return an instrument object based on a given profile.\\n\\n    Args:\\n        profile (dict): A dictionary profile containing information about the instrument to be created. \\n                            The dictionary should contain a \\\"device_type\\\" key with a string value \\n                            specifying the type of the device (\\\"oscilloscope\\\", \\\"digital_multimeter\\\", \\n                            \\\"waveform_generator\\\", \\\"digital_power_supply\\\"). \\n                            Additional will be required depending on the device type.\\n                            \\n    Returns:\\n        Object: An instance of the corresponding instrument class, initialized based on the profile.\\n\\n    Raises:\\n        InstrumentConfigurationError: If the device type is not recognized or missing in the profile.\\n    \\\"\\\"\\\"\\n    match profile[\\\"device_type\\\"]:\\n        case \\\"oscilloscope\\\":\\n            if profile[\\\"jitter_analysis\\\"]:\\n                return DigitalOscilloscopeWithJitter(profile[\\\"visa_resource\\\"], profile)\\n            else:\\n                return Oscilloscope(profile[\\\"visa_resource\\\"], profile)\\n        case \\\"digital_multimeter\\\":\\n            return DigitalMultimeter(profile[\\\"visa_resource\\\"], profile)\\n        case \\\"waveform_generator\\\":\\n            return WaveformGenerator(profile[\\\"visa_resource\\\"], profile)\\n        case \\\"digital_power_supply\\\":\\n            return DigitalPowerSupply(profile[\\\"visa_resource\\\"], profile)\\n        case _:\\n            raise InstrumentConfigurationError()\\n\",\n    \"pytestlab\\\\instruments\\\\DigitalMultimeter.py\": \"from pytestlab.instruments.instrument import SCPIInstrument, SCPIConnectionError, SCPICommunicationError\\n\\nclass DigitalMultimeter(SCPIInstrument):\\n    \\\"\\\"\\\"\\n    A class representing a Digital Multimeter that inherits from the SCPIInstrument class.\\n\\n    Provides methods for measuring voltage, current, resistance, frequency, and testing continuity.\\n\\n    Attributes:\\n        visa_resource (str): The VISA address of the device.\\n        description (dict): A dictionary containing additional information about the device, including supported channels.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, visa_resource, description):\\n        \\\"\\\"\\\"\\n        Initializes a DigitalMultimeter instance.\\n\\n        Args:\\n            visa_resource (str): The VISA address of the device.\\n            description (dict): A dictionary containing additional information about the device.\\n        \\\"\\\"\\\"\\n        super().__init__(visa_resource)\\n        self.description = description\\n\\n    def measure_voltage(self, channel=1):\\n        \\\"\\\"\\\"\\n        Measures the DC voltage on the specified channel.\\n\\n        Args:\\n            channel (int, optional): The channel number. Default is 1.\\n\\n        Returns:\\n            float: The measured voltage.\\n\\n        Raises:\\n            ValueError: If an invalid channel is specified.\\n        \\\"\\\"\\\"\\n        if channel not in self.description[\\\"voltage_channels\\\"]:\\n            raise ValueError(f\\\"Invalid voltage channel {channel}. Supported voltage channels: {self.description['voltage_channels']}\\\")\\n        voltage = self._query(f\\\"MEASURE:VOLTAGE:DC? (@{channel})\\\")\\n        return float(voltage)\\n\\n    def measure_current(self, channel=1):\\n        \\\"\\\"\\\"\\n        Measures the DC current on the specified channel.\\n\\n        Args:\\n            channel (int, optional): The channel number. Default is 1.\\n\\n        Returns:\\n            float: The measured current.\\n\\n        Raises:\\n            ValueError: If an invalid channel is specified.\\n        \\\"\\\"\\\"\\n        if channel not in self.description[\\\"current_channels\\\"]:\\n            raise ValueError(f\\\"Invalid current channel {channel}. Supported current channels: {self.description['current_channels']}\\\")\\n        current = self._query(f\\\"MEASURE:CURRENT:DC? (@{channel})\\\")\\n        return float(current)\\n\\n    def measure_resistance(self, channel=1):\\n        \\\"\\\"\\\"\\n        Measures the resistance on the specified channel.\\n\\n        Args:\\n            channel (int, optional): The channel number. Default is 1.\\n\\n        Returns:\\n            float: The measured resistance.\\n\\n        Raises:\\n            ValueError: If an invalid channel is specified.\\n        \\\"\\\"\\\"\\n        if channel not in self.description[\\\"resistance_channels\\\"]:\\n            raise ValueError(f\\\"Invalid resistance channel {channel}. Supported resistance channels: {self.description['resistance_channels']}\\\")\\n        resistance = self._query(f\\\"MEASURE:RESISTANCE? (@{channel})\\\")\\n        return float(resistance)\\n\\n    def measure_frequency(self, channel=1):\\n        \\\"\\\"\\\"\\n        Measures the frequency on the specified channel.\\n\\n        Args:\\n            channel (int, optional): The channel number. Default is 1.\\n\\n        Returns:\\n            float: The measured frequency.\\n\\n        Raises:\\n            ValueError: If an invalid channel is specified.\\n        \\\"\\\"\\\"\\n        if channel not in self.description[\\\"frequency_channels\\\"]:\\n            raise ValueError(f\\\"Invalid frequency channel {channel}. Supported frequency channels: {self.description['frequency_channels']}\\\")\\n        frequency = self._query(f\\\"MEASURE:FREQUENCY? (@{channel})\\\")\\n        return float(frequency)\\n\\n    def test_continuity(self, channel=1):\\n        \\\"\\\"\\\"\\n        Tests for electrical continuity on the specified channel.\\n\\n        Args:\\n            channel (int, optional): The channel number. Default is 1.\\n\\n        Returns:\\n            bool: True if continuity is present, False otherwise.\\n\\n        Raises:\\n            ValueError: If an invalid channel is specified.\\n        \\\"\\\"\\\"\\n        if channel not in self.description[\\\"continuity_channels\\\"]:\\n            raise ValueError(f\\\"Invalid continuity channel {channel}. Supported continuity channels: {self.description['continuity_channels']}\\\")\\n        continuity = self._query(f\\\"TEST:CONTINUITY? (@{channel})\\\")\\n        return bool(int(continuity))  # Assuming continuity returns 1 for True and 0 for False\\n\",\n    \"pytestlab\\\\instruments\\\\DigitalPowerSupply.py\": \"from pytestlab.instruments.instrument import SCPIInstrument\\nfrom pytestlab.errors import SCPICommunicationError\\n\\nclass DigitalPowerSupply(SCPIInstrument):\\n    \\\"\\\"\\\"\\n    A class representing a Digital Power Supply that inherits from the SCPIInstrument class.\\n\\n    Provides methods for setting voltage and current, and for enabling or disabling the output.\\n\\n    Attributes:\\n        visa_resource (str): The VISA address of the device.\\n        description (dict): A dictionary containing additional information about the device.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, visa_resource, description):\\n        \\\"\\\"\\\"\\n        Initializes a DigitalPowerSupply instance.\\n\\n        Args:\\n            visa_resource (str): The VISA address of the device.\\n            description (dict): A dictionary containing additional information about the device.\\n        \\\"\\\"\\\"\\n        super().__init__(visa_resource)\\n        self.description = description\\n\\n    def set_voltage(self, voltage, channel=1):\\n        \\\"\\\"\\\"\\n        Sets the voltage for the specified channel.\\n\\n        Args:\\n            voltage (float): The voltage value to set.\\n            channel (int, optional): The channel number. Default is 1.\\n\\n        Raises:\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\n        \\\"\\\"\\\"\\n        self._check_channel_range(channel, voltage, \\\"voltage\\\")\\n        self._send_command(f\\\"VOLTAGE{channel} {voltage}\\\")\\n\\n    def set_current(self, current, channel=1):\\n        \\\"\\\"\\\"\\n        Sets the current for the specified channel.\\n\\n        Args:\\n            current (float): The current value to set.\\n            channel (int, optional): The channel number. Default is 1.\\n\\n        Raises:\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\n        \\\"\\\"\\\"\\n        self._check_channel_range(channel, current, \\\"current\\\")\\n        self._send_command(f\\\"CURRENT{channel} {current}\\\")\\n\\n    def enable_output(self, channel=1):\\n        \\\"\\\"\\\"\\n        Enables the output for the specified channel.\\n\\n        Args:\\n            channel (int, optional): The channel number. Default is 1.\\n\\n        Raises:\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\n        \\\"\\\"\\\"\\n        self._send_command(f\\\"OUTPUT{channel} ON\\\")\\n\\n    def disable_output(self, channel=1):\\n        \\\"\\\"\\\"\\n        Disables the output for the specified channel.\\n\\n        Args:\\n            channel (int, optional): The channel number. Default is 1.\\n\\n        Raises:\\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\\n        \\\"\\\"\\\"\\n        self._send_command(f\\\"OUTPUT{channel} OFF\\\")\\n\",\n    \"pytestlab\\\\instruments\\\\instrument.py\": \"import numpy as np\\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError\\nfrom pyscpi import usbtmc\\nimport time\\n\\nclass SCPIInstrument:\\n    \\\"\\\"\\\"\\n    A class representing an SCPI-compliant instrument.\\n\\n    Attributes:\\n        visa_resource (str): The VISA resource string that identifies the instrument.\\n    \\\"\\\"\\\"\\n\\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\\n        \\\"\\\"\\\"\\n        Initialize the SCPIInstrument class.\\n\\n        Args:\\n            visa_resource (str): The VISA resource string to use for the connection.\\n        \\\"\\\"\\\"\\n        if visa_resource:\\n            self.visa_resource = visa_resource\\n            self._connect()\\n        elif \\\"vendor_id\\\" in profile and \\\"product_id\\\" in profile:\\n            self.instrument = usbtmc.Instrument(profile[\\\"vendor_id\\\"], profile[\\\"product_id\\\"])\\n        else:\\n            raise ValueError(\\\"Either a VISA resource string or a vendor and product ID must be provided.\\\")\\n        self.profile = profile\\n        self._command_log = []\\n        self.debug_mode = debug_mode\\n\\n    def _connect(self):\\n        \\\"\\\"\\\"Connect to the instrument using the VISA resource string.\\\"\\\"\\\"\\n        try:\\n            import pyvisa\\n            self.instrument = pyvisa.ResourceManager().open_resource(self.visa_resource)\\n        except Exception as e:\\n            raise SCPIConnectionError(f\\\"Failed to connect to the instrument: {str(e)}\\\")\\n\\n    def _read_to_np(self) -> bytes:\\n        chunk_size = 1024\\n        data = self.instrument.read_raw(chunk_size)\\n        np.frombuffer(data[10:], dtype=np.uint8)\\n        header = data[2:10].decode('utf-8')\\n        data = np.frombuffer(data[10:], dtype=np.uint8)\\n        self._log(header)\\n\\n        hpoints = int(header)\\n\\n        while len(data) < hpoints:\\n            data = np.append(data, np.frombuffer(\\n                self.instrument.read_raw(chunk_size), dtype=np.uint8))\\n\\n        return data[:-1]\\n\\n    def _send_command(self, command):\\n        \\\"\\\"\\\"\\n        Send an SCPI command to the instrument.\\n\\n        Args:\\n            command (str): The SCPI command to send.\\n\\n        Raises:\\n            SCPICommunicationError: If sending the command fails.\\n        \\\"\\\"\\\"\\n        try:\\n            self.instrument.write(command)\\n            self._command_log.append({\\\"command\\\": command, \\\"success\\\": True, \\\"type\\\": \\\"write\\\", \\\"timestamp\\\":time.time})\\n        except Exception as e:\\n            raise SCPICommunicationError(f\\\"Failed to send command: {str(e)}\\\")\\n\\n    def _query(self, query):\\n        \\\"\\\"\\\"\\n        Query the instrument and return the response.\\n\\n        Args:\\n            query (str): The SCPI query to send.\\n\\n        Returns:\\n            str: The instrument's response to the query.\\n\\n        Raises:\\n            SCPICommunicationError: If the query fails.\\n        \\\"\\\"\\\"\\n        try:\\n            response =  self.instrument.query(query)\\n            print(response)\\n            self._command_log.append({\\\"command\\\": query, \\\"success\\\": True, \\\"type\\\": \\\"query\\\", \\\"timestamp\\\":time.time})\\n            self.instrument.query(\\\"*OPC?\\\")\\n            return response\\n        except Exception as e:\\n            self._command_log.append({\\\"command\\\": query, \\\"success\\\": False, \\\"type\\\": \\\"query\\\", \\\"timestamp\\\":time.time})\\n            raise SCPICommunicationError(f\\\"Failed to query instrument: {str(e)}\\\")\\n        \\n    def _wait(self):\\n        \\\"\\\"\\\"\\n        Blocks until all previous commands have been processed by the instrument.\\n        \\\"\\\"\\\"\\n        self.instrument.query(\\\"*OPC?\\\")\\n\\n    def _log(self, message):\\n        \\\"\\\"\\\"\\n        Log a message.\\n\\n        Args:\\n            message (str): The message to log.\\n        \\\"\\\"\\\"\\n        if self.debug_mode:\\n            print(message)\\n\\n    def _history(self):\\n        \\\"\\\"\\\"\\n        Prints history of executed commands\\n        \\\"\\\"\\\"\\n        for command in self._command_log:\\n            print(command)\\n    def id(self):\\n        \\\"\\\"\\\"\\n        Query the instrument for its identification.\\n\\n        Returns:\\n            str: The identification string of the instrument.\\n        \\\"\\\"\\\"\\n        return self._query(\\\"*IDN?\\\")\\n    \\n    def _check_valid_channel(self, selected_channel):\\n        valid_channels = self.profile[\\\"channels\\\"].keys()\\n        min_limit = min(valid_channels)\\n        max_limit = max(valid_channels)\\n        assert isinstance(selected_channel, int), f\\\"Channel must be an integer. Received: {selected_channel}\\\"\\n        assert selected_channel in valid_channels, f\\\"Invalid Channel Selected: {selected_channel}. Available Channels: {min_limit} to {max_limit}\\\"\\n\\n    def close(self):\\n        \\\"\\\"\\\"Close the connection to the instrument.\\\"\\\"\\\"\\n        self.instrument.close()\\n\\n    def reset(self):\\n        \\\"\\\"\\\"Reset the instrument to its default settings.\\\"\\\"\\\"\\n        self._send_command(\\\"*RST\\\")\\n\\n    def set_channel_voltage(self, channel, voltage):\\n        \\\"\\\"\\\"\\n        Set the voltage for a specific channel.\\n\\n        Args:\\n            channel (int or str): The channel for which to set the voltage.\\n            voltage (float): The voltage value to set.\\n        \\\"\\\"\\\"\\n        self._check_valid_channel(channel)\\n        self._send_command(f\\\"CHAN{channel}:VOLT {voltage}\\\")\\n\\n    def get_channel_voltage(self, channel):\\n        \\\"\\\"\\\"\\n        Get the voltage for a specific channel.\\n\\n        Args:\\n            channel (int or str): The channel for which to get the voltage.\\n\\n        Returns:\\n            float: The voltage value for the channel.\\n        \\\"\\\"\\\"\\n        self._check_valid_channel(channel)\\n        response = self._query(f\\\"CHAN{channel}:VOLT?\\\")\\n        return float(response)\\n\\n    def measure_frequency(self, channel):\\n        \\\"\\\"\\\"\\n        Measure the frequency for a specific channel.\\n\\n        Args:\\n            channel (int or str): The channel for which to measure the frequency.\\n\\n        Returns:\\n            float: The measured frequency value for the channel.\\n        \\\"\\\"\\\"\\n        self._check_valid_channel(channel)\\n        response = self._query(f\\\"MEAS:FREQ? CHAN{channel}\\\")\\n        return float(response)\\n\",\n    \"pytestlab\\\\instruments\\\\InstrumentManager.py\": \"import time\\nfrom pytestlab import InstrumentCollection\\n\\nclass InstrumentManager:\\n    def __init__(self):\\n        self.instrument_collection = InstrumentCollection()\\n\\n    # Instrument management methods\\n    def add_instrument(self, name, instrument):\\n        # Add an instrument to the manager's collection\\n        self.instrument[name] = instrument\\n\\n    def remove_instrument(self, name):\\n        # Remove an instrument from the manager's collection\\n        del self.instruments[name]\\n\\n    def get_instrument(self, name):\\n        # Get an instrument from the manager's collection\\n        return self.instruments[name]\\n\\n    def list_instruments(self):\\n        # List all instruments currently added to the manager\\n        print(self.instrument_collection)\\n\\n    def disconnect_all_instruments(self):\\n        # Disconnect all instruments in the manager's collection\\n        for i in self.instruments:\\n            self.instruments[i].close()\\n        pass\\n\\n    def is_all_instruments_connected(self):\\n        # Check if all instruments are connected\\n        pass\\n\\n    def is_instrument_connected(self, name):\\n        # Check if a specific instrument is connected\\n        pass\\n    # Measurement methods\\n    def measure_voltage(self, voltage, channel=1):\\n        # Perform a voltage measurement\\n        pass\\n\\n    def measure_current(self, current, channel=1):\\n        # Perform a current measurement\\n        pass\\n\\n    def measure_power(self, power, channel=1):\\n        # Perform a power measurement\\n        pass\\n\\n    def measure_eye_diagram(self, test_pattern, voltage=1.0, current=0.5, channel=1, eye_duration=0.1):\\n        power_supply = self.instrument_collection[\\\"power_supply\\\"]\\n        oscilloscope = self.instrument_collection[\\\"oscilloscope\\\"]\\n        pattern_generator = self.instrument_collection[\\\"pattern_generator\\\"]\\n\\n        power_supply.set_voltage(voltage, channel)\\n        power_supply.set_current(current, channel)\\n        power_supply.enable_output(channel)\\n\\n        pattern_generator.load_pattern(test_pattern)\\n        pattern_generator.enable_output()\\n\\n        oscilloscope.set_channel(channel)\\n        oscilloscope.start_measurement()\\n\\n        # Wait for the test pattern to stabilize and the oscilloscope to capture data\\n        time.sleep(eye_duration)\\n\\n        oscilloscope.stop_measurement()\\n        data = oscilloscope.get_measurement_data()\\n\\n        power_supply.disable_output()\\n        pattern_generator.disable_output()\\n\\n        #Data needs to be processed to generate Eye Diagram by frontend\\n        # eye_diagram = process_eye_data(data)\\n        return data\\n        # return eye_diagram\\n\\n    def perform_s21_measurement(self, frequency, power_level, channel=1, measurement_time=0.1):\\n        signal_generator = self.instrument_collection[\\\"signal_generator\\\"]\\n        vna = self.instrument_collection[\\\"vna\\\"]\\n\\n        signal_generator.set_frequency(frequency)\\n        signal_generator.set_power_level(power_level)\\n        signal_generator.enable_output()\\n\\n        vna.set_channel(channel)\\n        vna.set_frequency(frequency)\\n        vna.set_power_level(power_level)\\n        vna.set_s_parameter(\\\"S21\\\")\\n        vna.start_measurement()\\n\\n        # Wait for the measurement to stabilize and complete\\n        time.sleep(measurement_time)\\n\\n        s21_result = vna.get_measurement_data(\\\"S21\\\")\\n\\n        signal_generator.disable_output()\\n        vna.stop_measurement()\\n\\n        return s21_result\\n\\n        \\n    # Calibration methods\\n    def calibrate_power_supply(self):\\n        # Calibrate the power supply\\n        pass\\n\\n    def calibrate_oscilloscope(self):\\n        # Calibrate the oscilloscope\\n        pass\\n\\n    def calibrate_vna(self):\\n        # Calibrate the Vector Network Analyzer\\n        pass\\n\\n    # Data handling methods\\n    def save_measurement_data(self, data, file_name):\\n        # Save measurement data to a file\\n        pass\\n\\n    def load_measurement_data(self, file_name):\\n        # Load measurement data from a file\\n        pass\\n\\n    # Instrument configuration methods\\n    def configure_power_supply(self, settings):\\n        # Configure power supply settings (e.g., voltage limits, current limits)\\n        pass\\n\\n    def configure_oscilloscope(self, settings):\\n        # Configure oscilloscope settings (e.g., timebase, trigger settings)\\n        pass\\n\\n    def configure_vna(self, settings):\\n        # Configure Vector Network Analyzer settings (e.g., frequency range, calibration)\\n        pass\\n\\n    # Additional utility methods as needed\\n    def check_instrument_compatibility(self):\\n        # Check if the connected instruments are compatible for the planned measurements\\n        pass\\n\\n    def perform_full_system_check(self):\\n        # Perform a comprehensive system check before starting measurements\\n        pass\\n\\n    def report_system_status(self):\\n        # Generate a report on the status of connected instruments and overall system health\\n        pass\\n\",\n    \"pytestlab\\\\instruments\\\\Oscilloscope.py\": \"import time\\nfrom typing import List\\nfrom pytestlab.instruments.instrument import SCPIInstrument\\nfrom pytestlab.MeasurementDatabase import MeasurementResult, Preamble, MeasurementValue\\nfrom pytestlab.errors import SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\\nimport numpy as np\\nclass Oscilloscope(SCPIInstrument):\\n    \\\"\\\"\\\"\\n    Provides an interface for controlling and acquiring data from an oscilloscope using SCPI commands.\\n\\n    This class inherits from SCPIInstrument and implements specific methods to interact with \\n    oscilloscope features such as voltage measurement and timebase scaling.\\n\\n    Attributes:\\n    visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\\n    profile (dict): Information about the instrument model.\\n    \\\"\\\"\\\"\\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\\n        \\\"\\\"\\\"\\n        Initialize the Oscilloscope class with the given VISA resource and profile information.\\n        \\n        Args:\\n        visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\\n        profile (dict): Information about the instrument model.\\n        \\\"\\\"\\\"\\n        super().__init__(visa_resource=visa_resource, profile=profile, debug_mode=debug_mode)\\n        assert \\\"model\\\" in self.profile, \\\"Oscilloscope model not specified in profile.\\\"\\n\\n    def _read_preamble(self):\\n        \\\"\\\"\\\"Reads the preamble from the oscilloscope.\\n\\n        :param inst: The instrument object from pyscpi or pyvisa\\n        :param debug: Print debug messages\\n        :return: A Preamble object\\n\\n        \\\"\\\"\\\"\\n\\n        peram = self._query(':WAVeform:PREamble?')\\n        peram = peram.split(',')\\n        self._log(peram)\\n\\n        pre = Preamble(peram[0], peram[1], int(peram[2]), float(peram[4]), float(\\n            peram[5]), float(peram[6]), float(peram[7]), float(peram[8]), float(peram[9]))\\n\\n        return pre\\n\\n    def _read_wave_data(self, channel: int, points: int) -> np.ndarray:\\n\\n        self._wait()\\n        self._send_command(f':WAVeform:SOURce CHANnel{channel}')\\n        self._query('*OPC?')\\n        self._log('Reading channel ' + str(channel))\\n\\n        self._send_command(':WAVeform:FORMat BYTE')\\n        self._send_command(':WAVeform:POINts:MODE MAXimum')\\n\\n        self._log('Reading points')\\n\\n        if points > 0:\\n            self._send_command(f':WAVeform:POINts {points}')\\n        else:\\n            self._send_command(':WAVeform:POINts MAXimum')\\n\\n        self._wait()\\n\\n        self._log('Reading data')\\n\\n        self._send_command(':WAVeform:DATA?')\\n        data = self._read_to_np()\\n\\n        return data\\n    \\n    def auto_scale(self):\\n        \\\"\\\"\\\"\\n        Auto scale the oscilloscope display.\\n        \\n        This method sends an SCPI command to the oscilloscope to auto scale the display.\\n        \\n        Example:\\n        >>> auto_scale()\\n        \\\"\\\"\\\"\\n        self._send_command(\\\":AUToscale\\\")\\n\\n    def set_time_axis(self, scale: float, position: float) -> None:\\n        \\\"\\\"\\\"\\n        Sets the time axis of the Oscilloscope. (x-axis)\\n\\n        :param scale: scale The scale of the axis in seconds \\n        :param position: The position of the time axis from the trigger in seconds\\n        \\\"\\\"\\\"\\n    \\n        self._send_command(f':TIMebase:SCALe {scale}')\\n        self._send_command(f':TIMebase:POSition {position}')\\n        self._wait()\\n    \\n    def set_channel_axis(self, channel: int, scale: float, offset: float) -> None:\\n        \\\"\\\"\\\"\\n        Sets the channel axis of the oscilloscope. (y-axis)\\n\\n        :param channel: The channel to set\\n        :param scale: The scale of the channel axis in volts\\n        :param offset: The offset of the channel in volts\\n        \\\"\\\"\\\"\\n        self._send_command(f':CHANnel{channel}:SCALe {scale}')\\n        self._send_command(f':CHANnel{channel}:OFFSet {offset}')\\n        self._wait()\\n        \\n    def measure_voltage_peak_to_peak(self, channel):\\n        \\\"\\\"\\\"\\n        Measure the peak-to-peak voltage for a specified channel.\\n        \\n        This method sends an SCPI query to the oscilloscope to measure the peak-to-peak voltage \\n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\\n        \\n        Args:\\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\\n        \\n        Returns:\\n        MeasurementResult: An object containing the peak-to-peak voltage measurement for the specified channel.\\n        \\n        Example:\\n        >>> measure_voltage_peak_to_peak(\\\"CH1\\\")\\n        <MeasurementResult object at 0x7f1ec2a4f510>\\n        \\\"\\\"\\\"\\n        self._check_valid_channel(channel)\\n\\n\\n        measurement_result = MeasurementResult(self.profile[\\\"model\\\"], \\\"V\\\", \\\"peak to peak voltage\\\")\\n\\n        response = self._query(f\\\"MEAS:VPP? CHAN{channel}\\\")\\n        measurement_result.add(response)\\n        return measurement_result\\n\\n    def measure_rms_voltage(self, channel: int) -> MeasurementResult:\\n        \\\"\\\"\\\"\\n        Measure the root-mean-square (RMS) voltage for a specified channel.\\n        \\n        This method sends an SCPI query to the oscilloscope to measure the RMS voltage \\n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\\n        \\n        Args:\\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\\n        \\n        Returns:\\n        MeasurementResult: An object containing the RMS voltage measurement for the specified channel.\\n        \\n        Example:\\n        >>> measure_rms_voltage(\\\"CH1\\\")\\n        <MeasurementResult object at 0x7f1ec2a4f590>\\n        \\\"\\\"\\\"\\n        #Error Handling\\n        self._check_valid_channel(channel)\\n\\n\\n        measurement_result = MeasurementResult(self.profile[\\\"model\\\"], \\\"V\\\", \\\"rms voltage\\\")\\n        response = self._query(f\\\"MEAS:VRMS? CHAN{channel}\\\")\\n        measurement_result.add(response)\\n        return measurement_result\\n\\n    def read_channels(self, channels: List[int], points=10000, runAfter=True, timebase=None):\\n        if timebase is not None:\\n            self.set_timebase_scale(timebase)\\n\\n        self._log(points)\\n        self._log(\\\"starting\\\")\\n\\n        for channel in channels:\\n            self._check_valid_channel(channel)\\n\\n        # Prepare the MeasurementResult dictionary\\n        sampling_rate = float(self.get_sampling_rate())\\n        measurement_results = {channel: MeasurementResult(instrument=f\\\"{self.profile['manufacturer']}:{self.profile['model']}\\\", units=\\\"V\\\", measurement_type=\\\"Voltage\\\", sampling_rate=sampling_rate, realtime_timestamps=True)\\n                            for channel in channels}\\n\\n        # Setup and digitize commands\\n        channel_commands = ', '.join(f\\\"CHANnel{channel}\\\" for channel in channels)\\n        self._send_command(f\\\"DIGitize {channel_commands}\\\")\\n        self._send_command(f':WAVeform:SOURce CHANnel{channels[0]}')\\n\\n        # Read preamble to get scaling factors\\n        pream = self._read_preamble()\\n\\n        # Prepare the time axis once, as it is the same for all channels\\n        time_values = (np.arange(0, pream.points, 1) - pream.xref) * pream.xinc + pream.xorg\\n\\n        for i, channel in enumerate(channels):\\n            data = self._read_wave_data(channel, points)\\n            if len(data) != pream.points:\\n                print('ERROR: points mismatch, please investigate')\\n\\n            # Calculate the voltage values\\n            voltages = (data - pream.yref) * pream.yinc + pream.yorg\\n\\n            # Populate the MeasurementResult object for this channel\\n            for voltage, time_val in zip(voltages, time_values):\\n                measurement_results[channel].add(MeasurementValue(voltage, timestamp=time_val))\\n\\n        if runAfter:\\n            self._send_command(\\\":RUN\\\")\\n\\n        return measurement_results\\n    \\n    # def set_probe_attenuation(self, channel, attenuation):\\n    #     \\\"\\\"\\\"\\n    #     Sets the probe attenuation for a given channel.\\n\\n    #     \\\"\\\"\\\"\\n    #     self._check_valid_channel(channel)\\n    #     # Set the probe attenuation for the specified channel\\n    #     self._send_command(f\\\"CHANnel{channel}:PROBe {attenuation}\\\")\\n\\n    def get_sampling_rate(self):\\n        # Send the SCPI command to query the current sampling rate\\n        response = self._query(\\\":ACQuire:SRATe?\\\")\\n        \\n        # Parse the response to get the sampling rate value.\\n        sampling_rate = float(response)\\n        \\n        return MeasurementValue(sampling_rate, \\\"Hz\\\")\\n    \\n    def set_probe_scale(self, channel, scale):\\n        \\\"\\\"\\\"\\n        Sets the probe scale for a given channel.\\n\\n        Parameters:\\n            channel (int): The oscilloscope channel to set the scale for.\\n            scale (float): The probe scale value (e.g., 10.0 for 10:1, 1.0 for 1:1).\\n        \\\"\\\"\\\"\\n        self._check_valid_channel(channel)\\n\\n        # The command format is hypothetical and needs to be adjusted \\n        # to match the specific oscilloscope command set.\\n        command = f\\\":PROBe:CH{channel}:ATTenuation {scale}\\\"\\n        self._send_command(command)\\n\\n        # Confirm the action to the log\\n        self._log(f\\\"Set probe scale to {scale}:1 for channel {channel}.\\\")\\n\\n    def set_timebase_scale(self, scale):\\n        \\\"\\\"\\\"\\n        Set the timebase scale of the oscilloscope.\\n        \\n        This method sends an SCPI command to adjust the timebase scale on the oscilloscope display.\\n        \\n        Args:\\n        scale (float): The timebase scale in seconds per division.\\n        \\n        Example:\\n        >>> set_timebase_scale(0.002)\\n        \\\"\\\"\\\"\\n        self._send_command(f\\\"TIM:SCAL {scale}\\\")\\n\\n    def get_timebase_scale(self):\\n        \\\"\\\"\\\"\\n        Retrieve the current timebase scale setting from the oscilloscope.\\n        \\n        This method sends an SCPI query to get the current timebase scale and encapsulates \\n        the result into a MeasurementResult object.\\n        \\n        Returns:\\n        MeasurementResult: An object containing the current timebase scale setting.\\n        \\n        Example:\\n        >>> get_timebase_scale()\\n        <MeasurementResult object at 0x7f1ec2a4f650>\\n        \\\"\\\"\\\"\\n\\n        measurement_result = MeasurementResult(self.profile[\\\"model\\\"], \\\"s\\\", \\\"timebase scale\\\")\\n        response = self._query(\\\"TIM:SCAL?\\\")\\n\\n        measurement_result.add(response)\\n        return measurement_result\\n\\n    def set_acquisition_time(self, time):\\n        \\\"\\\"\\\"\\n        Set the total acquisition time for the oscilloscope.\\n\\n        ARGS;\\n            time (float): The total acquisition time in seconds.\\n        \\\"\\\"\\\"\\n        # Set the total time for acquisition\\n        self._send_command(f\\\":TIMebase:MAIN:RANGe {time}\\\")\\n\\n    def set_sample_rate(self, rate):\\n        \\\"\\\"\\\"\\n        Sets the sample rate for the oscilloscope.\\n\\n        Args:\\n        rate (str): The desired sample rate. Valid values are 'MAX' and 'AUTO'.\\n        \\\"\\\"\\\"\\n        rate = rate.upper()\\n        valid_values = [\\\"MAX\\\", \\\"AUTO\\\"]\\n        if rate not in valid_values:\\n            raise ValueError(f\\\"Invalid Valid: supported = {valid_values}\\\")\\n        # Set the sample rate for acquisition\\n        self._send_command(f\\\"ACQuire:SRATe {rate}\\\")\\n\\n    def set_bandwidth_limit(self, channel, bandwidth):\\n        \\\"\\\"\\\"\\n        \\n        \\\"\\\"\\\"\\n        self._check_valid_channel(channel)\\n        # Limit the bandwidth to a specified frequency to reduce noise\\n        self._send_command(f\\\"CHANnel{channel}:BANDwidth {bandwidth}\\\")\\n\\n    # def set_filtering(self, channel, filter_type, frequency):\\n    #     self._check_valid_channel(channel)\\n    #     # Configure a filter on the channel to isolate the desired frequency components\\n    #     if self.profile[\\\"channels\\\"][channel][\\\"filtering\\\"] != \\\"available\\\":\\n    #         raise ValueError(f\\\"Filtering is not available on Channel {channel}.\\\")\\n        \\n    #     if channel not in self.profile[\\\"channels\\\"]:\\n    #         raise ValueError(f\\\"Invalid channel {channel}. Supported channels: {self.profile['channels']}\\\")\\n\\n    #     self._send_command(f\\\"CHANnel{channel}:FILTer:{filter_type} {frequency}\\\")\\n\\n    def set_trigger(self, channel, trigger_level):\\n        \\\"\\\"\\\"\\n        Sets the trigger level for a given channel.\\n\\n        Parameters:\\n\\n        \\\"\\\"\\\"\\n        self._check_valid_channel(channel)\\n        # Set the trigger level for the specified channel\\n        self._send_command(f\\\"TRIGger:LEVel CHANnel{channel},{trigger_level}\\\")\\n\\n    # def set_trigger_mode(self, mode):\\n    #     \\\"\\\"\\\"\\n        \\n    #     \\\"\\\"\\\"\\n    #     if mode not in self.profile[\\\"trigger_modes\\\"]:\\n    #         raise ValueError(f\\\"Invalid trigger mode {mode}. Supported trigger modes: {self.profile['trigger_modes']}\\\")\\n    #     # Set the trigger mode to either edge or pulse\\n    #     self._send_command(f\\\"TRIGger:MODE {mode}\\\")\\n\\n    def set_trigger_source(self, channel):\\n        \\\"\\\"\\\"\\n        \\n        \\\"\\\"\\\"\\n        self._check_valid_channel(channel)\\n        # Set the trigger source to the specified channel\\n        self._send_command(f\\\"TRIGger:SOURce CHANnel{channel}\\\")\\n\\n    # def set_trigger_edge_slope(self, slope):\\n    #     \\\"\\\"\\\"\\\"\\\"\\\"\\n    #     # Set the edge slope to either rising or falling\\n    #     self._send_command(f\\\"TRIGger:EDGE:SLOPe {slope}\\\")\\n\\n    # def set_trigger_pulse_polarity(self, polarity):\\n    #     # Set the pulse polarity to either positive or negative\\n    #     self._send_command(f\\\"TRIGger:PULSe:POLarity {polarity}\\\")\\n\\n    # def set_trigger_pulse_width(self, width):\\n    #     # Set the pulse width to the specified value\\n    #     self._send_command(f\\\"TRIGger:PULSe:WIDth {width}\\\")\\n\\n    # def set_trigger_pulse_delay(self, delay):\\n    #     # Set the pulse delay to the specified value\\n    #     self._send_command(f\\\"TRIGger:PULSe:DELay {delay}\\\")\\n\\n    # def set_trigger_pulse_transition(self, transition):\\n    #     # Set the pulse transition to either positive or negative\\n    #     self._send_command(f\\\"TRIGger:PULSe:TRANsition {transition}\\\")\\n\\n    # def set_trigger_pulse_condition(self, condition):\\n    #     # Set the pulse condition to either width or delay\\n    #     self._send_command(f\\\"TRIGger:PULSe:CONdition {condition}\\\")\\n\\n    def wave_gen(self, state: bool):\\n        \\\"\\\"\\\"\\n        Enable or disable the waveform generator of the oscilloscope.\\n\\n        This method sends an SCPI command to enable or disable the function generator in the oscilloscope.\\n        \\n        Args:\\n        state (str): The desired state ('ON' or 'OFF') for the waveform generator.\\n        \\n        Raises:\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\\n        \\n        Example:\\n        >>> set_wave_gen('ON')\\n        \\\"\\\"\\\"\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        # if state not in self.profile[\\\"function_generator\\\"]:\\n        #     raise ValueError(f\\\"Invalid state {state}. Supported states: {self.profile['function_generator']}\\\")\\n        \\n        self._send_command(f\\\"WGEN:OUTP {'ON' if state else 'OFF'}\\\")\\n\\n    def set_wave_gen_func(self, state):\\n        \\\"\\\"\\\"\\n        Set the waveform function for the oscilloscope's waveform generator.\\n\\n        This method sends an SCPI command to change the function (e.g., 'SINE', 'SQUARE') of the waveform generator.\\n        \\n        Args:\\n        state (str): The desired function ('SINE', 'SQUARE', etc.) for the waveform generator.\\n\\n        Raises:\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\\n\\n        Example:\\n        >>> set_wave_gen_func('SINE')\\n        \\\"\\\"\\\"\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        if state not in self.profile[\\\"function_generator\\\"][\\\"waveform_types\\\"]:\\n            raise ValueError(f\\\"Invalid state {state}. Supported states: {self.profile['function_generator']['waveform_types']}\\\")\\n        \\n        self._send_command(f\\\"WGEN:FUNC {state}\\\")\\n\\n    def set_wave_gen_freq(self, freq):\\n        \\\"\\\"\\\"\\n        Set the frequency for the waveform generator.\\n\\n        This method sends an SCPI command to set the frequency of the waveform generator.\\n        \\n        Args:\\n        freq (float): The desired frequency for the waveform generator in Hz.\\n\\n        Raises:\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the frequency is out of range.\\n\\n        Example:\\n        >>> set_wave_gen_freq(1000.0)\\n        \\\"\\\"\\\"\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        if freq < self.profile[\\\"function_generator\\\"][\\\"frequency\\\"][\\\"min\\\"] or freq > self.profile[\\\"function_generator\\\"][\\\"frequency\\\"][\\\"max\\\"]:\\n            raise ValueError(f\\\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\\\")\\n\\n        self._send_command(f\\\"WGEN:FREQ {freq}\\\")\\n\\n    def set_wave_gen_amp(self, amp):\\n        \\\"\\\"\\\"\\n        Set the amplitude for the waveform generator.\\n\\n        This method sends an SCPI command to set the amplitude of the waveform generator.\\n        \\n        Args:\\n        amp (float): The desired amplitude for the waveform generator in volts.\\n\\n        Raises:\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the amplitude is out of range.\\n\\n        Example:\\n        >>> set_wave_gen_amp(1.0)\\n        \\\"\\\"\\\"\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        if amp < self.profile[\\\"function_generator\\\"][\\\"amplitude\\\"][\\\"min\\\"] or amp > self.profile[\\\"function_generator\\\"][\\\"amplitude\\\"][\\\"max\\\"]:\\n            raise ValueError(f\\\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\\\")\\n\\n        self._send_command(f\\\"WGEN:VOLT {amp}\\\")\\n\\n    def set_wave_gen_offset(self, offset):\\n        \\\"\\\"\\\"\\n        Set the voltage offset for the waveform generator.\\n\\n        This method sends an SCPI command to set the voltage offset of the waveform generator.\\n        \\n        Args:\\n        offset (float): The desired voltage offset for the waveform generator in volts.\\n\\n        Raises:\\n        ValueError: If the oscilloscope model does not have a waveform generator or if the offset is out of range.\\n\\n        Example:\\n        >>> set_wave_gen_offset(0.1)\\n        \\\"\\\"\\\"\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        if offset < self.profile[\\\"function_generator\\\"][\\\"offset\\\"][\\\"min\\\"] or offset > self.profile[\\\"function_generator\\\"][\\\"offset\\\"][\\\"max\\\"]:\\n            raise ValueError(f\\\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\\\")\\n        \\n        self._send_command(f\\\"WGEN:VOLT:OFFSet {offset}\\\")\\n\\n    def set_wgen_sin(self, amp: float, offset: float, freq: float) -> None:\\n        \\\"\\\"\\\"Sets the waveform generator to a sine wave. (Only available on specific models)\\n\\n        :param amp: The amplitude of the sine wave in volts\\n        :param offset: The offset of the sine wave in volts\\n        :param freq: The frequency of the sine wave in Hz. The frequency can be adjusted from 100 mHz to 20 MHz.\\n        \\\"\\\"\\\"\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        if offset < self.profile[\\\"function_generator\\\"][\\\"offset\\\"][\\\"min\\\"] or offset > self.profile[\\\"function_generator\\\"][\\\"offset\\\"][\\\"max\\\"]:\\n            raise ValueError(f\\\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\\\")\\n        if amp < self.profile[\\\"function_generator\\\"][\\\"amplitude\\\"][\\\"min\\\"] or amp > self.profile[\\\"function_generator\\\"][\\\"amplitude\\\"][\\\"max\\\"]:\\n            raise ValueError(f\\\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\\\")\\n        if freq < self.profile[\\\"function_generator\\\"][\\\"frequency\\\"][\\\"min\\\"] or freq > self.profile[\\\"function_generator\\\"][\\\"frequency\\\"][\\\"max\\\"]:\\n            raise ValueError(f\\\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\\\")\\n\\n        self._send_command('WGEN:FUNCtion SINusoid')\\n        self._send_command(f':WGEN:VOLTage {amp}')\\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\\n        self._send_command(f':WGEN:FREQuency {freq}')\\n\\n\\n    def set_wgen_square(self, v0: float, v1: float, freq: float, dutyCycle: int) -> None:\\n        \\\"\\\"\\\"Sets the waveform generator to a square wave. (Only available on specific models)\\n\\n        :param v0: The voltage of the low state in volts\\n        :param v1: The voltage of the high state in volts\\n        :param freq: The frequency of the square wave in Hz. The frequency can be adjusted from 100 mHz to 10 MHz.\\n        :param dutyCycle: The duty cycle can be adjusted from 1% to 99% up to 500 kHz. At higher frequencies, the adjustment range narrows so as not to allow pulse widths less than 20 ns.\\n        \\\"\\\"\\\"\\n\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        \\n        self._send_command('WGEN:FUNCtion SQUare')\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\n        self._send_command(f':WGEN:FREQuency {freq}')\\n        self._send_command(f':WGEN:FUNCtion:SQUare:DCYCle {dutyCycle}')\\n\\n\\n    def set_wgen_ramp(self, v0: float, v1: float, freq: float, symmetry: int) -> None:\\n        \\\"\\\"\\\"Sets the waveform generator to a ramp wave. (Only available on specific models)\\n\\n        :param v0: The voltage of the low state in volts\\n        :param v1: The voltage of the high state in volts\\n        :param freq: The frequency of the ramp wave in Hz. The frequency can be adjusted from 100 mHz to 100 kHz.\\n        :param symmetry: Symmetry represents the amount of time per cycle that the ramp waveform is rising and can be adjusted from 0% to 100%.\\n        \\\"\\\"\\\"\\n\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        \\n        self._send_command('WGEN:FUNCtion RAMP')\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\n        self._send_command(f':WGEN:FREQuency {freq}')\\n        self._send_command(f':WGEN:FUNCtion:RAMP:SYMMetry {symmetry}')\\n\\n\\n    def set_wgen_pulse(self, v0: float, v1: float, period: float, pulseWidth: float) -> None:\\n        \\\"\\\"\\\"Sets the waveform generator to a pulse wave. (Only available on specific models)\\n\\n        :param v0: The voltage of the low state in volts\\n        :param v1: The voltage of the high state in volts\\n        :param period: The period of the pulse wave in seconds. The period can be adjusted from 10 ns to 10 s.\\n        :param pulseWidth: The pulse width can be adjusted from 20 ns to the period minus 20 ns.\\n        \\\"\\\"\\\"\\n\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n\\n        self._send_command('WGEN:FUNCtion PULSe')\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\n        self._send_command(f':WGEN:PERiod {period}')\\n        self._send_command(f':WGEN:FUNCtion:PULSe:WIDTh {pulseWidth}')\\n\\n\\n    def set_wgen_dc(self, offset: float) -> None:\\n        \\\"\\\"\\\"Sets the waveform generator to a DC wave. (Only available on specific models)\\n\\n        :param offset: The offset of the DC wave in volts\\n        \\\"\\\"\\\"\\n\\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        if offset < self.profile[\\\"function_generator\\\"][\\\"offset\\\"][\\\"min\\\"] or offset > self.profile[\\\"function_generator\\\"][\\\"offset\\\"][\\\"max\\\"]:\\n            raise ValueError(f\\\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\\\")\\n        \\n        self._send_command('WGEN:FUNCtion DC')\\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\\n\\n\\n    def set_wgen_noise(self, v0: float, v1: float, offset: float) -> None:\\n        \\\"\\\"\\\"Sets the waveform generator to a noise wave. (Only available on specific models)\\n\\n        :param v0: The voltage of the low state in volts\\n        :param v1: The voltage of the high state in volts\\n        :param offset: The offset of the noise wave in volts\\n        \\\"\\\"\\\"\\n        \\n        if \\\"function_generator\\\" not in self.profile:\\n            raise ValueError(f\\\"Waveform generator is not available on this oscilloscope.\\\")\\n        \\n        self._send_command('WGEN:FUNCtion NOISe')\\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\\n\\n    def display_channel(self, channels, state=True) -> None:\\n        \\\"\\\"\\\"\\n        Display the specified channels on the oscilloscope.\\n        \\n        This method sends an SCPI command to the oscilloscope to display the specified channels.\\n        \\n        Args:\\n        channels (list): A list of channels to display on the oscilloscope.\\n        \\n        Raises:\\n        ValueError: If the oscilloscope model does not support the specified channel(s).\\n        \\n        Example:\\n        >>> display_channel([\\\"CH1\\\", \\\"CH2\\\"])\\n        \\\"\\\"\\\"\\n        for channel in channels:\\n            self._check_valid_channel(channel)\\n        # Implement SCPI commands to display the specified channels\\n        self._send_command(f\\\"CHAN:{channels}:DISP {'ON' if state else 'OFF'}\\\")\\n\\n\\n    def fft_display(self, state=True):\\n        \\\"\\\"\\\"\\n        Switches on the FFT display\\n\\n        :param state: The state of the FFT display\\n        \\\"\\\"\\\"\\n        assert \\\"fft\\\" in self.profile, \\\"FFT is not available on this oscilloscope.\\\"\\n\\n        self._send_command(f\\\":FFT:DISPlay {'ON' if state else 'OFF'}\\\")\\n        self._log(f\\\"FFT display {'enabled' if state else 'disabled'}.\\\")\\n\\n    def function_display(self, state=True):\\n        \\\"\\\"\\\"\\n        Switches on the function display\\n\\n        :param state: The state of the function display\\n        \\\"\\\"\\\"\\n        \\n        self._send_command(f\\\":FUNCtion:DISPlay {'ON' if state else 'OFF'}\\\")\\n        self._log(f\\\"Function display {'enabled' if state else 'disabled'}.\\\")\\n\\n    def configure_fft(self, source_channel: int, scale: float = None, offset: float = None, window_type: str = 'HANNing', units: str = 'DECibel', display: bool = True):\\n        \\\"\\\"\\\"\\n        Configure the oscilloscope to perform an FFT on the specified channel with the given parameters.\\n\\n        :param source_channel: The channel number to perform FFT on.\\n        :param scale: The scale of the FFT display in dB. Defaults to None.\\n        :param offset: The offset of the FFT display. Defaults to None.\\n        :param window_type: The windowing function to apply. Defaults to 'HANNing'.\\n        :param units: The unit of measurement for the FFT (DECibel or VRMS). Defaults to 'DECibel'.\\n        :param display: A boolean to turn the FFT display ON or OFF. Defaults to True.\\n        \\\"\\\"\\\"\\n\\n        # Ensure the oscilloscope supports FFT and the specified channel is valid\\n        assert \\\"fft\\\" in self.profile, \\\"FFT is not available on this oscilloscope.\\\"\\n        assert source_channel in self.profile[\\\"channels\\\"], f\\\"Invalid channel {source_channel}. Supported channels: {self.profile['channels']}\\\"\\n        assert window_type in self.profile[\\\"fft\\\"][\\\"window_types\\\"], f\\\"Invalid window type {window_type}. Supported window types: {self.profile['fft']['window_types']}\\\"\\n        assert units in self.profile[\\\"fft\\\"][\\\"units\\\"], f\\\"Invalid units {units}. Supported units: {self.profile['fft']['units']}\\\"\\n\\n        # Set the FFT source to the specified channel\\n        self._send_command(f':FFT:SOURce1 CHANnel{source_channel}')\\n        # Configure the FFT window type\\n        self._send_command(f':FFT:WINDow {window_type}')\\n        # Configure the FFT vertical type (units)\\n        self._send_command(f':FFT:VTYPe {units}')\\n        # Set the scale if provided\\n        if scale is not None:\\n            self._send_command(f':FFT:SCALe {scale}dB')\\n        # Set the offset if provided\\n        if offset is not None:\\n            self._send_command(f':FFT:OFFSet {offset}')\\n        # Turn the FFT display on or off based on the parameter\\n        display_state = '1' if display else '0'\\n        self._send_command(f':FFT:DISPlay {display_state}')\\n\\n        self._log(f\\\"FFT configured for channel {source_channel}.\\\")\\n\\n    def _convert_binary_block_to_data(self, binary_block):\\n        # Process the binary data header to determine the size of the block\\n        header_len = int(binary_block[1])  # Assuming the length of the length field itself is 1 byte\\n        expected_data_points = int(binary_block[2:2+header_len])\\n\\n        # Use _read_to_np to read the binary data into a NumPy array\\n        data = self._read_to_np()\\n\\n        # Ensure that we've read the correct number of data points\\n        assert len(data) == expected_data_points, \\\"Data size mismatch\\\"\\n\\n        # Data is now in a NumPy array format and can be reshaped or processed as needed\\n        # For FRANalysis, the data often comes in pairs representing frequency and response (magnitude/phase)\\n        # so we need to reshape the array accordingly\\n        data_points_per_entry = 2  # Assuming each data point consists of a frequency and a corresponding value\\n        structured_data = data.reshape((-1, data_points_per_entry))\\n        \\n    def perform_franalysis(self, input_channel, output_channel, start_freq, stop_freq, points=1000, mode='SWEep'):\\n        \\\"\\\"\\\"\\n        Perform a frequency response analysis on the oscilloscope.\\n\\n        :param input_channel: The channel number to use as the input.\\n        :param output_channel: The channel number to use as the output.\\n        :param start_freq: The start frequency of the analysis in Hz.\\n        :param stop_freq: The stop frequency of the analysis in Hz.\\n        :param points: The number of points to use for the analysis.\\n        \\\"\\\"\\\"\\n        # Validate input\\n        self._check_valid_channel(input_channel)\\n        self._check_valid_channel(output_channel)\\n        assert mode in ['SWEep', 'SINGle'], 'Mode should be \\\"SWEep\\\" or \\\"SINGle\\\"'\\n        assert 10 <= start_freq < stop_freq <= 20000000, 'Frequency range should be within 10 Hz to 20 MHz'\\n        assert points > 0, 'Number of points must be positive'\\n\\n        # Enable FRANalysis\\n        self._send_command(\\\":FRANalysis:ENABle 1\\\")\\n\\n        # Set the start and stop frequencies\\n        self._send_command(f\\\":FRANalysis:FREQuency:STARt {start_freq}Hz\\\")\\n        self._send_command(f\\\":FRANalysis:FREQuency:STOP {stop_freq}Hz\\\")\\n\\n        # Set the mode\\n        self._send_command(f\\\":FRANalysis:FREQuency:MODE {mode}\\\")\\n\\n        # If single frequency mode, set the single frequency, otherwise set points for sweep\\n        if mode == 'SINGle':\\n            self._send_command(f\\\":FRANalysis:FREQuency:SINGle {start_freq}Hz\\\")\\n        else:\\n            # Not directly provided in the command summary, assuming there's a command for points\\n            assert points > 0, 'Number of points must be positive'\\n            # TODO remove this hard-coded limit - only for DSOX1204G\\n            assert points <= 1000, 'Number of points must be less than 1000'\\n            self._send_command(f\\\":FRANalysis:SWEep:POINts {points}\\\")\\n\\n        # Initiate FRANalysis\\n        self._send_command(\\\":FRANalysis:RUN\\\")\\n\\n        # Wait for analysis to complete and then read the data\\n        # The waiting mechanism is not detailed, assuming there's a method for it\\n        self._wait()\\n        # Read the FRANalysis data (binary block format)\\n        franalysis_data = self._query(\\\":FRANalysis:DATA?\\\")\\n\\n        # Process the binary block data into a structured format\\n        # Assuming a helper function to convert binary block to numerical data\\n        data = self._read_preamble()\\n        # data = self._convert_binary_block_to_data(franalysis_data)\\n\\n        # Disable FRANalysis after completion\\n        self._send_command(\\\":FRANalysis:ENABle 0\\\")\\n\\n        # Return the processed data\\n        return data\\n    \\n    def read_fft_data(self) -> MeasurementResult:\\n        \\\"\\\"\\\"\\n        Perform the FFT and read the data from the oscilloscope, returning it as a MeasurementResult.\\n\\n        :return: A MeasurementResult object containing the FFT data.\\n        \\\"\\\"\\\"\\n        self._log('Initiating FFT data read.')\\n        \\n        # The oscilloscope setup for FFT should be done before calling this method\\n        # Make sure that the acquisition is already started or in continuous mode\\n        \\n        # Assuming :FUNCtion:DATA? returns the FFT data from the oscilloscope\\n        self._send_command(':FUNCtion:DATA?')\\n        fft_data = self._read_to_np()\\n        \\n        # Now, instead of just returning fft_data, we need to encapsulate it into MeasurementValue objects\\n        # and then add these to a MeasurementResult object.\\n\\n        # For this example, let's assume 'self.sampling_rate' is set and represents the sampling rate used for FFT\\n        if self.sampling_rate is None:\\n            raise ValueError(\\\"Sampling rate must be set to read FFT data.\\\")\\n        \\n        # Compute the frequency bins for the FFT data\\n        freq = np.fft.fftfreq(len(fft_data), 1 / self.sampling_rate)\\n        \\n        units = self._query(\\\":FFT:VTYPe?\\\")\\n        # Create a new MeasurementResult for the FFT results\\n        fft_measurement_result = MeasurementResult(\\n            instrument=self.instrument,  # Replace with actual attribute, if different\\n            units=units,  \\n            measurement_type=\\\"Frequency Spectrum\\\",\\n            sampling_rate=self.sampling_rate  # Including the sampling rate for reference\\n        )\\n        \\n        # Populate the MeasurementResult with MeasurementValue objects\\n        for f, magnitude in zip(freq, fft_data):\\n            fft_measurement_value = MeasurementValue(value=magnitude)\\n            # Normally, timestamp would be set to the time the measurement was taken\\n            # In this case, we can repurpose it to store the frequency, if that's acceptable for your design\\n            fft_measurement_value.timestamp = f\\n            fft_measurement_result.add(fft_measurement_value)\\n        \\n        return fft_measurement_result\\n\\n# class DigitalOscilloscopeWithJitter(Oscilloscope):\\n\\n#     def __init__(self, visa_resource, profile):\\n#         super().__init__(visa_resource, profile)\\n\\n#     def _available_jitter_measurements(self, jitter_type):\\n#         if jitter_type not in self.profile[\\\"jitter_analysis\\\"][\\\"available_types\\\"]:\\n#             raise ValueError(f\\\"Invalid jitter type {jitter_type}. Supported jitter types: {self.profile['jitter_analysis']}\\\")\\n\\n#     def setup_rms_jitter_measurement(self, channel):\\n#         self._available_jitter_measurements(\\\"rms\\\")\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\n#         self._send_command(f\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\")\\n#         self._send_command(\\\"MEASure:JITTer:MODE RMS\\\")\\n\\n#     def setup_peak_to_peak_jitter_measurement(self, channel):\\n#         self._available_jitter_measurements(\\\"peak_to_peak\\\")\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\n#         self._send_command(f\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\")\\n#         self._send_command(\\\"MEASure:JITTer:MODE PK2PK\\\")\\n\\n#     def setup_period_jitter_measurement(self, channel):\\n#         self._available_jitter_measurements(\\\"period\\\")\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\n#         self._send_command(f\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\")\\n#         self._send_command(\\\"MEASure:JITTer:MODE PERiod\\\")\\n\\n#     def setup_cycle_to_cycle_jitter_measurement(self, channel):\\n#         self._available_jitter_measurements(\\\"cycle_to_cycle\\\")\\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\\n#         self._send_command(f\\\"MEASure:JITTer:SOURce CHANnel{channel}\\\")\\n#         self._send_command(\\\"MEASure:JITTer:MODE CCYCle\\\")\\n\\n#     def configure_trigger(self, trigger_source, trigger_level):\\n#         # Implement SCPI commands to configure trigger settings for jitter measurement\\n#         self._send_command(f\\\"TRIGger:SOURce CHANnel{trigger_source}\\\")\\n#         self._send_command(f\\\"TRIGger:LEVel CHANnel{trigger_source},{trigger_level}\\\")\\n\\n#     def acquire_jitter_data(self):\\n#         # Implement SCPI commands to acquire jitter data from the oscilloscope\\n#         self._send_command(\\\"ACQuire:STATE RUN\\\")\\n\\n#     def analyze_jitter_data(self):\\n#         measurement_result = MeasurementResult(self.profile[\\\"model\\\"], \\\"s\\\", \\\"jitter\\\")\\n#         jitter_value = self._query_command(\\\"MEASure:JITTer?\\\")\\n#         measurement_result.add_measurement(jitter_value)\\n#         return measurement_result\\n    \\n#     def perform_rms_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\n#         self.setup_rms_jitter_measurement(channel)\\n#         self.configure_trigger(trigger_source, trigger_level)\\n#         self.acquire_jitter_data()\\n#         return self.analyze_jitter_data()\\n    \\n#     def perform_peak_to_peak_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\n#         \\\"\\\"\\\"\\n#         Perform a peak-to-peak jitter measurement on a specified channel with given trigger settings.\\n        \\n#         This method sets up the measurement, configures the trigger, acquires the jitter data and \\n#         then analyzes the data to return a MeasurementResult object containing the results of \\n#         the jitter measurement.\\n        \\n#         Args:\\n#         channel (str/int): The identifier for the channel on which the measurement is to be performed.\\n#                         This could be an integer representing the channel number or a string representing\\n#                         the channel name, depending on the implementation.\\n#         trigger_source (str/int): The identifier for the trigger source. This could be an integer or a \\n#                                 string representing the source depending on the implementation.\\n#         trigger_level (float): The trigger level for the measurement in volts. This value sets the voltage \\n#                             level at which the trigger event occurs.\\n        \\n#         Returns:\\n#         MeasurementResult: An object containing the results of the peak-to-peak jitter measurement.\\n        \\n#         Raises:\\n#         NotImplementedError: If any of the method calls within this function (e.g., setup_peak_to_peak_jitter_measurement, \\n#                             configure_trigger, acquire_jitter_data, analyze_jitter_data) are not implemented.\\n#         MeasurementError: If there is an error during the measurement process.\\n        \\n#         Example:\\n#         >>> perform_peak_to_peak_jitter_measurement(\\\"CH1\\\", \\\"External\\\", 0.5)\\n#         <MeasurementResult object at 0x7f9bd8134f50>\\n#         \\\"\\\"\\\"\\n#         self.setup_peak_to_peak_jitter_measurement(channel)\\n#         self.configure_trigger(trigger_source, trigger_level)\\n#         self.acquire_jitter_data()\\n#         return self.analyze_jitter_data()\\n\\n        \\n#     def perform_period_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\n#         self.setup_period_jitter_measurement(channel)\\n#         self.configure_trigger(trigger_source, trigger_level)\\n#         self.acquire_jitter_data()\\n#         return self.analyze_jitter_data()\\n\\n#     def perform_cycle_to_cycle_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\\n#         self.setup_cycle_to_cycle_jitter_measurement(channel)\\n#         self.configure_trigger(trigger_source, trigger_level)\\n#         self.acquire_jitter_data()\\n#         return self.analyze_jitter_data()\\n        \",\n    \"pytestlab\\\\instruments\\\\WaveformGenerator.py\": \"from pytestlab.instruments.instrument import SCPIInstrument\\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\\nimport numpy as np\\n\\nclass WaveformGenerator(SCPIInstrument):\\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\\n        \\\"\\\"\\\"\\n        Initialize a WaveformGenerator instance with a device profile.\\n\\n        Args:\\n            profile (dict): A dictionary containing device profile information.\\n\\n        \\\"\\\"\\\"\\n        super().__init__(visa_resource=visa_resource, profile=profile, debug_mode=debug_mode)\\n        assert \\\"model\\\" in self.profile, \\\"Waveform Generator model not specified in profile.\\\"\\n\\n    def _validate_waveform(self, waveform_type):\\n        \\\"\\\"\\\"\\n        Validate if the waveform type is supported by the device.\\n\\n        Args:\\n            waveform_type (str): The type of waveform to validate.\\n\\n        Raises:\\n            ValueError: If the waveform type is not supported.\\n\\n        \\\"\\\"\\\"\\n        standard_waveforms = [w.upper() for w in self.profile.get('waveforms', {}).get('standard', [])]\\n        if waveform_type.upper() not in standard_waveforms:\\n            raise ValueError(f\\\"Invalid waveform type: {waveform_type}. Supported types: {standard_waveforms}\\\")\\n\\n    def _validate_frequency(self, frequency):\\n        \\\"\\\"\\\"\\n        Validate if the frequency is within the device's supported range.\\n\\n        Args:\\n            frequency (float): The frequency to validate.\\n\\n        Raises:\\n            ValueError: If the frequency is out of range.\\n\\n        \\\"\\\"\\\"\\n        max_frequency = self.profile.get('max_frequency')\\n        if frequency > max_frequency:\\n            raise ValueError(f\\\"Frequency out of range. Max supported frequency: {max_frequency}\\\")\\n\\n    def _validate_amplitude(self, amplitude):\\n        \\\"\\\"\\\"\\n        Validate if the amplitude is within the device's supported range.\\n\\n        Args:\\n            amplitude (float): The amplitude to validate.\\n\\n        Raises:\\n            ValueError: If the amplitude is out of range.\\n\\n        \\\"\\\"\\\"\\n        min_amplitude = self.profile.get('amplitude', {}).get('min', 0)\\n        max_amplitude = self.profile.get('amplitude', {}).get('max', float('inf'))\\n        if not min_amplitude <= amplitude <= max_amplitude:\\n            raise ValueError(f\\\"Amplitude out of range. Supported range: {min_amplitude} to {max_amplitude}\\\")\\n\\n    def _validate_offset(self, offset):\\n        \\\"\\\"\\\"\\n        Validate if the offset is within the device's supported range.\\n\\n        Args:\\n            offset (float): The offset to validate.\\n\\n        Raises:\\n            ValueError: If the offset is out of range.\\n\\n        \\\"\\\"\\\"\\n        min_offset = self.profile.get('dc_offset', {}).get('min', float('-inf'))\\n        max_offset = self.profile.get('dc_offset', {}).get('max', float('inf'))\\n        if not min_offset <= offset <= max_offset:\\n            raise ValueError(f\\\"Offset out of range. Supported range: {min_offset} to {max_offset}\\\")\\n\\n    def set_arbitrary_waveform(self, channel, waveform, scale=True):\\n        \\\"\\\"\\\"\\n        Sets the arbitrary waveform for the specified channel.\\n\\n        Args:\\n            channel (int or str): The channel for which to set the waveform.\\n            waveform (list): The arbitrary waveform to set.\\n\\n        \\\"\\\"\\\"\\n        self._log(f\\\"Setting arbitrary waveform for channel {channel}\\\")\\n        waveform_np = np.array(waveform)\\n        awg_max_voltage = self.profile[\\\"amplitude\\\"][\\\"max\\\"]\\n        awg_min_voltage = self.profile[\\\"amplitude\\\"][\\\"min\\\"]\\n\\n        max_length = self.profile[\\\"waveforms\\\"][\\\"arbitrary\\\"][\\\"max_length\\\"]\\n        if scale:\\n            waveform_normalized = (waveform - np.min(waveform)) / (np.max(waveform) - np.min(waveform))\\n            waveform_scaled = waveform_normalized * (awg_max_voltage - awg_min_voltage) + awg_min_voltage\\n            waveform_np = np.array(waveform_scaled)\\n            self._log(f\\\"Waveform scaled to {awg_min_voltage} to {awg_max_voltage} V\\\")\\n            if len(waveform_np) > max_length:\\n                # squash into max_length by approximating\\n                waveform_np = waveform_np[::int(len(waveform_np) / max_length)] # TODO: improve this approximation\\n                self._log(f\\\"Waveform squashed to {max_length} samples\\\")\\n        else:\\n            self._log(f\\\"Waveform not scaled\\\")\\n            if len(waveform_np) > max_length:\\n                self._log(f\\\"Waveform length exceeds maximum length: {max_length}\\\")\\n                raise ValueError(f\\\"Waveform length exceeds maximum length: {max_length}\\\")\\n            if np.max(waveform_np) > awg_max_voltage or np.min(waveform_np) < awg_min_voltage:\\n                self._log(f\\\"Waveform exceeds amplitude range: {awg_min_voltage} to {awg_max_voltage}\\\")\\n                raise ValueError(f\\\"Waveform exceeds amplitude range: {awg_min_voltage} to {awg_max_voltage}\\\")\\n\\n        binary_waveform = waveform_np.tobytes()\\n\\n        self._send_command(f\\\"SOURCE{channel}:DATA:VOL:CLEAR\\\")  # Clear the volatile memory\\n        self._send_command(f\\\"SOURCE{channel}:FUNCTION ARBITRAR\\\")  # Set the source to arbitrary waveform\\n        self._send_command(f\\\"SOURCE{channel}:DATA:ARB:DAC {binary_waveform}, (@1)\\\")\\n\\n        self._log(f\\\"Waveform set\\\")\\n\\n    def set_waveform(self, channel, waveform_type):\\n        \\\"\\\"\\\"\\n        Sets the waveform type for the specified channel after validation.\\n\\n        Args:\\n            channel (int or str): The channel for which to set the waveform.\\n            waveform_type (str): The type of waveform to set.\\n\\n        \\\"\\\"\\\"\\n        self._validate_waveform(waveform_type)\\n        self._send_command(f\\\"SOUR{channel}:FUNC {waveform_type.upper()}\\\")\\n        self._log(f\\\"Waveform set to {waveform_type}\\\")\\n\\n    def set_frequency(self, channel, frequency):\\n        \\\"\\\"\\\"\\n        Sets the frequency for the specified channel after validation.\\n\\n        Args:\\n            channel (int or str): The channel for which to set the frequency.\\n            frequency (float): The frequency to set.\\n\\n        \\\"\\\"\\\"\\n        self._validate_frequency(frequency)\\n        self._send_command(f\\\"SOUR{channel}:FREQ {frequency}\\\")\\n        self._log(f\\\"Frequency set to {frequency} Hz\\\")\\n\\n    def set_amplitude(self, channel, amplitude):\\n        \\\"\\\"\\\"\\n        Sets the amplitude for the specified channel after validation.\\n\\n        Args:\\n            channel (int or str): The channel for which to set the amplitude.\\n            amplitude (float): The amplitude to set.\\n\\n        \\\"\\\"\\\"\\n        self._validate_amplitude(amplitude)\\n        self._send_command(f\\\"SOUR{channel}:AMPL {amplitude}\\\")\\n\\n    def set_offset(self, channel, offset):\\n        \\\"\\\"\\\"\\n        Sets the offset for the specified channel after validation.\\n\\n        Args:\\n            channel (int or str): The channel for which to set the offset.\\n            offset (float): The offset to set.\\n\\n        \\\"\\\"\\\"\\n        self._validate_offset(offset)\\n        self._send_command(f\\\"SOUR{channel}:OFFS {offset}\\\")\\n\\n# # Similar approach can be taken for PatternGenerator\\n# class PatternGenerator(SCPIInstrument):\\n#     def __init__(self, profile):\\n#         \\\"\\\"\\\"\\n#         Initialize a PatternGenerator instance with a device profile.\\n\\n#         Args:\\n#             profile (dict): A dictionary containing device profile information.\\n\\n#         \\\"\\\"\\\"\\n#         super().__init__()\\n#         self.profile = profile\\n\\n#     def _validate_pattern(self, pattern):\\n#         \\\"\\\"\\\"\\n#         Validate if the pattern is supported by the device.\\n\\n#         Args:\\n#             pattern (str): The type of pattern to validate.\\n\\n#         Raises:\\n#             ValueError: If the pattern is not supported.\\n\\n#         \\\"\\\"\\\"\\n#         standard_patterns = [p.upper() for p in self.profile.get('waveforms', {}).get('standard', [])]\\n#         if pattern.upper() not in standard_patterns:\\n#             raise ValueError(f\\\"Invalid pattern: {pattern}. Supported types: {standard_patterns}\\\")\\n\\n#     def set_pattern(self, channel, pattern):\\n#         \\\"\\\"\\\"\\n#         Sets the pattern for the specified channel after validation.\\n\\n#         Args:\\n#             channel (int or str): The channel for which to set the pattern.\\n#             pattern (str): The type of pattern to set.\\n\\n#         \\\"\\\"\\\"\\n#         self._validate_pattern(pattern)\\n#         self._send_command(f\\\"SOUR{channel}:FUNC {pattern.upper()}\\\")\\n\",\n    \"pytestlab\\\\profiles\\\\__init__.py\": \"\",\n    \"pytestlab\\\\profiles\\\\keysight\\\\infiniium.py\": \"\\noscilloscope_profile = {\\n    \\\"MXR054A\\\": {\\n    \\\"manufacturer\\\": \\\"Keysight\\\",\\n    \\\"model\\\": \\\"MXR054A\\\", \\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"bandwidth\\\": \\\"500 MHz\\\",\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n    },\\n    \\\"MXR058A\\\": {\\n    \\\"manufacturer\\\": \\\"Keysight\\\",\\n    \\\"model\\\": \\\"MXR058A\\\", \\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n      1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n      2: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },  \\n      3: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n      4: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n      5: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n      6: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }, \\n      7: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n      8: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"bandwidth\\\": \\\"500 MHz\\\",  \\n    \\\"analog_channels\\\": 8,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n\\n    \\\"MXR104A\\\": {\\n    # Same as MXR054A except:\\n    \\\"model\\\": \\\"MXR104A\\\",\\n    \\\"bandwidth\\\": \\\"1 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n\\n  \\\"MXR108A\\\": {\\n    # Same as MXR058A except: \\n    \\\"model\\\": \\\"MXR108A\\\",\\n    \\\"bandwidth\\\": \\\"1 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n\\n  \\\"MXR204A\\\": {\\n    # Same as MXR054A except:\\n    \\\"model\\\": \\\"MXR204A\\\",\\n    \\\"bandwidth\\\": \\\"2 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n\\n  \\\"MXR208A\\\": {\\n    # Same as MXR058A except:\\n    \\\"model\\\": \\\"MXR208A\\\",\\n    \\\"bandwidth\\\": \\\"2 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n\\n  \\\"MXR254A\\\": {\\n    # Same as MXR054A except:\\n    \\\"model\\\": \\\"MXR254A\\\",\\n    \\\"bandwidth\\\": \\\"2.5 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n  \\n  \\\"MXR258A\\\": {\\n    # Same as MXR058A except:\\n    \\\"model\\\": \\\"MXR258A\\\",\\n    \\\"bandwidth\\\": \\\"2.5 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n\\n  \\\"MXR404A\\\": {\\n    # Same as MXR054A except:\\n    \\\"model\\\": \\\"MXR404A\\\", \\n    \\\"bandwidth\\\": \\\"4 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n\\n  \\\"MXR408A\\\": {\\n    # Same as MXR058A except:\\n    \\\"model\\\": \\\"MXR408A\\\",\\n    \\\"bandwidth\\\": \\\"4 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n\\n  \\\"MXR604A\\\": {\\n    # Same as MXR054A except:\\n    \\\"model\\\": \\\"MXR604A\\\",\\n    \\\"bandwidth\\\": \\\"6 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  },\\n\\n  \\\"MXR608A\\\": {\\n    # Same as MXR058A except:\\n    \\\"model\\\": \\\"MXR608A\\\",\\n    \\\"bandwidth\\\": \\\"6 GHz\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Input Channel 1\\\",\\n        \\\"min\\\": -5.0,               \\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],   \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Input Channel 2\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,  \\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Input Channel 3\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0,\\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Input Channel 4\\\",\\n        \\\"min\\\": -5.0,\\n        \\\"max\\\": 5.0, \\n        \\\"input_coupling\\\": [\\\"AC\\\", \\\"DC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10, 100]\\n        }\\n    },\\n    \\\"timebase\\\": {\\n        \\\"min_scale\\\": 5e-12,\\n        \\\"max_scale\\\": 200,\\n        \\\"time_units\\\": [\\\"s\\\", \\\"ms\\\", \\\"us\\\", \\\"ns\\\"]\\n    },\\n    \\\"trigger\\\": {\\n        \\\"available_modes\\\": [\\\"EDGE\\\", \\\"PULSE\\\", \\\"TIMEOUT\\\", \\\"WINDOW\\\"],\\n        \\\"slope\\\": [\\\"RISING\\\", \\\"FALLING\\\", \\\"EITHER\\\"],\\n        \\\"external_trigger_input\\\": [\\\"AUX\\\"] \\n    },\\n    \\\"analog_channels\\\": 4,\\n    \\\"sampling_rate\\\": \\\"16 GSa/s\\\",\\n    \\\"standard_memory\\\": \\\"200 Mpts/ch\\\",\\n    \\\"waveform_update_rate\\\": \\\"> 200,000 wfms/sec\\\",\\n    \\\"jitter_analysis\\\": {\\n        \\\"available_types\\\": [\\\"RMS\\\"],\\n        \\\"jitter_sources\\\": [\\\"Time Interval Error\\\"],\\n        \\\"analysis_depth\\\": 1e6,\\n        \\\"histogram_bins\\\": 256, \\n        \\\"modulation_analysis\\\": False,\\n        \\\"real_time_analysis\\\": False,\\n        \\\"min_jitter_measurement\\\": 1e-12,\\n        \\\"max_jitter_measurement\\\": 1e-3\\n    }\\n  }\\n}\",\n    \"pytestlab\\\\profiles\\\\keysight\\\\smartbench.py\": \"oscilloscope_profile = {\\n    \\\"DSOX1204A\\\":{\\n    \\\"manufacturer\\\": \\\"Keysight\\\",\\n    \\\"vendor_id\\\": 0x2A8D,\\n    \\\"product_id\\\": 0x0396,\\n    \\\"model\\\": \\\"DSOX1204A\\\",\\n    \\\"device_type\\\": \\\"oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Analog Channel 1\\\",\\n        \\\"min\\\": -5,\\n        \\\"max\\\": 5,\\n        \\\"input_coupling\\\": [\\\"DC\\\", \\\"AC\\\"], \\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10]\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Analog Channel 2\\\",\\n        \\\"min\\\": -5,\\n        \\\"max\\\": 5,\\n        \\\"input_coupling\\\": [\\\"DC\\\", \\\"AC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Analog Channel 3\\\",\\n        \\\"min\\\": -5,\\n        \\\"max\\\": 5,\\n        \\\"input_coupling\\\": [\\\"DC\\\", \\\"AC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Analog Channel 4\\\",\\n        \\\"min\\\": -5,\\n        \\\"max\\\": 5, \\n        \\\"input_coupling\\\": [\\\"DC\\\", \\\"AC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10]\\n        }\\n    },\\n    \\\"bandwidth\\\": 70e6,\\n    \\\"sampling_rate\\\": 2e9,\\n    \\\"memory\\\": 2e6,\\n    \\\"waveform_update_rate\\\": 2e5,\\n    \\\"trigger_modes\\\": [\\\"Edge\\\", \\\"Pulse Width\\\", \\\"Video\\\", \\\"I2C\\\", \\\"SPI\\\", \\\"UART/RS232\\\", \\\"CAN\\\", \\\"LIN\\\"],\\n    \\\"timebase\\\": {  \\n        \\\"min\\\": 5e-9,\\n        \\\"max\\\": 50\\n    }\\n    },\\n    \\\"DSOX1204G\\\": {\\n    \\\"manufacturer\\\": \\\"Keysight\\\",\\n    \\\"model\\\": \\\"DSOX1204G\\\",\\n    \\\"vendor_id\\\": 0x2A8D,\\n    \\\"product_id\\\": 0x0396,\\n    \\\"device_type\\\": \\\"Oscilloscope\\\",\\n    \\\"channels\\\": {\\n        1: {\\n        \\\"description\\\": \\\"Analog Channel 1\\\",\\n        \\\"min\\\": -5,\\n        \\\"max\\\": 5,\\n        \\\"input_coupling\\\": [\\\"DC\\\", \\\"AC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10],\\n        \\\"timebase\\\": {\\n            \\\"range\\\": {\\n            \\\"min\\\": 5e-9,\\n            \\\"max\\\": 50\\n            },\\n            \\\"horizontal_resolution\\\": 1e-12\\n        }\\n        },\\n        2: {\\n        \\\"description\\\": \\\"Analog Channel 2\\\",\\n        \\\"min\\\": -5,\\n        \\\"max\\\": 5,\\n        \\\"input_coupling\\\": [\\\"DC\\\", \\\"AC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10]\\n        },\\n        3: {\\n        \\\"description\\\": \\\"Analog Channel 3\\\",\\n        \\\"min\\\": -5,\\n        \\\"max\\\": 5,\\n        \\\"input_coupling\\\": [\\\"DC\\\", \\\"AC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10]\\n        },\\n        4: {\\n        \\\"description\\\": \\\"Analog Channel 4\\\",\\n        \\\"min\\\": -5,\\n        \\\"max\\\": 5,\\n        \\\"input_coupling\\\": [\\\"DC\\\", \\\"AC\\\"],\\n        \\\"input_impedance\\\": 1e6,\\n        \\\"probe_attenuation\\\": [1, 10]\\n        }\\n    },\\n    \\\"bandwidth\\\": 70e6,\\n    \\\"sampling_rate\\\": 2e9,\\n    \\\"memory\\\": 2e6,\\n    \\\"waveform_update_rate\\\": 2e5,\\n    \\\"trigger_modes\\\": [\\\"EDGE\\\", \\\"PULSe\\\", \\\"VIDEo\\\", \\\"I2C\\\", \\\"SPI\\\", \\\"UART\\\", \\\"RS232\\\", \\\"CAN\\\", \\\"LIN\\\"],\\n    \\\"timebase\\\": {\\n        \\\"min\\\": 5e-9,\\n        \\\"max\\\": 50\\n    },\\n    \\\"fft\\\": {\\n        \\\"window_types\\\": [\\\"RECTangular\\\", \\\"HANNing\\\", \\\"FLATtop\\\", \\\"BHARris\\\"],\\n        \\\"units\\\": [\\\"DECibel\\\", \\\"VRMS\\\"]\\n    },\\n    \\\"function_generator\\\": {\\n        \\\"waveform_types\\\": [\\\"SINusoid\\\", \\\"SQUare\\\", \\\"RAMp\\\", \\\"PULse\\\", \\\"NOISe\\\", \\\"DC\\\"],\\n        \\\"supported_states\\\": [\\\"ON\\\", \\\"OFF\\\"],\\n        \\\"offset\\\": { \\n        \\\"min\\\": -5,\\n        \\\"max\\\": 5\\n        },\\n        \\\"frequency\\\": {\\n        \\\"min\\\": 0.1,\\n        \\\"max\\\": 20e6\\n        },\\n        \\\"amplitude\\\": {\\n        \\\"min\\\": 2e-3,\\n        \\\"max\\\": 20    \\n        }\\n    }\\n    }\\n}\\n\\npower_supply_profile = {\\n  \\\"EDU36311A\\\": {\\n    \\\"manufacturer\\\": \\\"Keysight\\\",\\n    \\\"vendor_id\\\": 0x2a8d,\\n    \\\"product_id\\\": 0x8f01,\\n    \\\"model\\\": \\\"EDU36311A\\\",\\n    \\\"device_type\\\": \\\"powersupply\\\",\\n    \\n    \\\"outputs\\\": {\\n      1: {\\n        \\\"voltage\\\": {\\n          \\\"min\\\": 0,\\n          \\\"max\\\": 6\\n        },\\n        \\\"current\\\": {\\n          \\\"min\\\": 0, \\n          \\\"max\\\": 5\\n        }\\n      },\\n      2: {\\n        \\\"voltage\\\": {\\n          \\\"min\\\": 0,\\n          \\\"max\\\": 30\\n        },\\n        \\\"current\\\": {\\n          \\\"min\\\": 0,\\n          \\\"max\\\": 1\\n        }\\n      },\\n      3: {\\n        \\\"voltage\\\": {\\n          \\\"min\\\": 0,\\n          \\\"max\\\": 30\\n        },\\n        \\\"current\\\": {\\n          \\\"min\\\": 0,\\n          \\\"max\\\": 1  \\n        }\\n      }\\n    },\\n    \\n    \\\"total_power\\\": 90, \\n    \\\"line_regulation\\\": 0.01, \\n    \\\"load_regulation\\\": 0.2,\\n    \\\"programming_accuracy\\\": {\\n      \\\"voltage\\\": 0.05,\\n      \\\"current\\\": 0.2  \\n    },\\n    \\n    \\\"readback_accuracy\\\": {\\n      \\\"voltage\\\": 0.05,\\n      \\\"current\\\": 0.2\\n    },\\n    \\n    \\\"interfaces\\\": [\\\"USB\\\", \\\"LAN\\\"],\\n    \\\"remote_control\\\": [\\\"SCPI\\\", \\\"IVI\\\", \\\"Web Browser\\\"]\\n  }\\n}\\n\\nawg_profile = {\\n  \\\"EDU33211A\\\": {\\n    \\\"manufacturer\\\": \\\"Keysight\\\",\\n    \\\"model\\\": \\\"EDU33211A\\\", \\n    \\\"vendor_id\\\": 0x2a8d,\\n    \\\"product_id\\\": 0x8d01,\\n    \\\"device_type\\\": \\\"Arbitrary Waveform Generator\\\",\\n    \\n    \\\"channels\\\": 1,\\n    \\\"max_frequency\\\": 20e6, \\n    \\n    \\\"waveforms\\\": {\\n      \\\"standard\\\": [\\\"sine\\\", \\\"square\\\", \\\"ramp\\\", \\\"pulse\\\", \\\"triangle\\\", \\\"noise\\\", \\\"PRBS\\\", \\\"DC\\\"],\\n      \\\"built-in\\\": [\\\"cardiac\\\", \\\"exponential_fall\\\", \\\"exponential_rise\\\", \\\"gaussian_pulse\\\", \\n                  \\\"haversine\\\", \\\"lorentz\\\", \\\"dlorentz\\\", \\\"negative_ramp\\\", \\\"sinc\\\"],\\n      \\\"arbitrary\\\": {\\n        \\\"memory\\\": 8e6, \\n        \\\"max_length\\\": 1e6,\\n        \\\"sampling_rate\\\": {\\n          \\\"min\\\": 1e-6,\\n          \\\"max\\\": 250e6\\n        },\\n        \\\"resolution\\\": 16\\n      }\\n    },\\n    \\n    \\\"modulation_types\\\": [\\\"AM\\\", \\\"FM\\\", \\\"PM\\\", \\\"FSK\\\", \\\"BPSK\\\", \\\"PWM\\\"],\\n    \\n    \\\"amplitude\\\": {\\n      \\\"min\\\": 1e-3,\\n      \\\"max\\\": 10\\n    },\\n    \\n    \\\"dc_offset\\\": {\\n      \\\"min\\\": -5,\\n      \\\"max\\\": 5  \\n    },\\n\\n    \\\"accuracy\\\": {\\n      \\\"amplitude\\\": 0.02, \\n      \\\"frequency\\\": 1e-6\\n    },\\n    \\n    \\\"interfaces\\\": [\\\"USB\\\", \\\"LAN\\\"], \\n    \\\"remote_control\\\": [\\\"SCPI\\\", \\\"IVI\\\", \\\"Web Browser\\\"]\\n  }\\n}\\n\\nmultimeter_profile = {\\n    \\\"EDU34450A\\\": {\\n    \\\"manufacturer\\\": \\\"Keysight\\\",\\n    \\\"model\\\": \\\"EDU34450A\\\",\\n    \\\"vendor_id\\\": 0x2a8d,\\n    \\\"product_id\\\": 0x8e01,\\n    \\\"device_type\\\": \\\"multimeter\\\",\\n\\n    \\\"channels\\\": 1,\\n    \\\"resolution\\\": 5.5,\\n    \\\"max_voltage\\\": 1000,\\n    \\\"max_current\\\": 10,\\n    \\\"max_resistance\\\": 100e6,\\n    \\\"max_capacitance\\\": 10e-6,\\n    \\\"max_frequency\\\": 1e6,\\n    }\\n  }\"\n}",
    "README.md": "# PyTestLab\n\nA Python library for test and measurement  automation and measurement data management.\n",
    "setup.py": "from setuptools import setup, find_packages\n\nsetup(\n    name='pytestlab',\n    version='0.0.1',\n    description='A Python library for instrument automation and measurement data management.',\n    author='Emmanuel Olowe',\n    author_email='e.a.olowe@ed.ac.uk',\n    # url='https://github.com/labiium/PyTestLab',\n    # packages=find_packages(),\n    # install_requires=[\n    #     'numpy',\n    #     # 'scipy',\n    #     'pandas',\n    #     # 'pyvisa',\n    # ],\n    classifiers=[\n        'Development Status :: 3 - Alpha',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n    ],\n)\n",
    "examples\\description.json": "{\n    \"methods\": [\n        {\n            \"name\": \"add_instrument\",\n            \"description\": \"Add an instrument to the manager's collection.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"str\",\n                    \"description\": \"The name of the instrument.\"\n                },\n                {\n                    \"name\": \"instrument\",\n                    \"type\": \"object\",\n                    \"description\": \"The instrument object to be added.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"remove_instrument\",\n            \"description\": \"Remove an instrument from the manager's collection.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"str\",\n                    \"description\": \"The name of the instrument to be removed.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"get_instrument\",\n            \"description\": \"Get an instrument by name from the manager's collection.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"str\",\n                    \"description\": \"The name of the instrument to retrieve.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"list_instruments\",\n            \"description\": \"List all instruments currently added to the manager.\",\n            \"parameters\": []\n        },\n        {\n            \"name\": \"connect_all_instruments\",\n            \"description\": \"Connect all instruments in the manager's collection.\",\n            \"parameters\": []\n        },\n        {\n            \"name\": \"disconnect_all_instruments\",\n            \"description\": \"Disconnect all instruments in the manager's collection.\",\n            \"parameters\": []\n        },\n        {\n            \"name\": \"is_all_instruments_connected\",\n            \"description\": \"Check if all instruments are connected.\",\n            \"parameters\": []\n        },\n        {\n            \"name\": \"is_instrument_connected\",\n            \"description\": \"Check if a specific instrument is connected.\",\n            \"parameters\": [\n                {\n                    \"name\": \"name\",\n                    \"type\": \"str\",\n                    \"description\": \"The name of the instrument to check.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"measure_voltage\",\n            \"description\": \"Perform a voltage measurement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"voltage\",\n                    \"type\": \"float\",\n                    \"description\": \"The voltage to measure.\"\n                },\n                {\n                    \"name\": \"channel\",\n                    \"type\": \"int\",\n                    \"description\": \"The channel number to measure (default: 1).\"\n                }\n            ]\n        },\n        {\n            \"name\": \"measure_current\",\n            \"description\": \"Perform a current measurement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"current\",\n                    \"type\": \"float\",\n                    \"description\": \"The current to measure.\"\n                },\n                {\n                    \"name\": \"channel\",\n                    \"type\": \"int\",\n                    \"description\": \"The channel number to measure (default: 1).\"\n                }\n            ]\n        },\n        {\n            \"name\": \"measure_power\",\n            \"description\": \"Perform a power measurement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"power\",\n                    \"type\": \"float\",\n                    \"description\": \"The power to measure.\"\n                },\n                {\n                    \"name\": \"channel\",\n                    \"type\": \"int\",\n                    \"description\": \"The channel number to measure (default: 1).\"\n                }\n            ]\n        },\n        {\n            \"name\": \"measure_eye_diagram\",\n            \"description\": \"Perform an Eye Diagram measurement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"test_pattern\",\n                    \"type\": \"str\",\n                    \"description\": \"The test pattern to use.\"\n                },\n                {\n                    \"name\": \"voltage\",\n                    \"type\": \"float\",\n                    \"description\": \"The voltage for the power supply (default: 1.0 V).\"\n                },\n                {\n                    \"name\": \"current\",\n                    \"type\": \"float\",\n                    \"description\": \"The current for the power supply (default: 0.5 A).\"\n                },\n                {\n                    \"name\": \"channel\",\n                    \"type\": \"int\",\n                    \"description\": \"The channel number to use (default: 1).\"\n                },\n                {\n                    \"name\": \"eye_duration\",\n                    \"type\": \"float\",\n                    \"description\": \"The duration of the eye diagram measurement (default: 0.1 s).\"\n                }\n            ]\n        },\n        {\n            \"name\": \"perform_s21_measurement\",\n            \"description\": \"Perform an S21 measurement.\",\n            \"parameters\": [\n                {\n                    \"name\": \"frequency\",\n                    \"type\": \"float\",\n                    \"description\": \"The frequency for the measurement.\"\n                },\n                {\n                    \"name\": \"power_level\",\n                    \"type\": \"float\",\n                    \"description\": \"The power level for the measurement.\"\n                },\n                {\n                    \"name\": \"channel\",\n                    \"type\": \"int\",\n                    \"description\": \"The channel number to use (default: 1).\"\n                },\n                {\n                    \"name\": \"measurement_time\",\n                    \"type\": \"float\",\n                    \"description\": \"The measurement time (default: 0.1 s).\"\n                }\n            ]\n        },\n        {\n            \"name\": \"calibrate_power_supply\",\n            \"description\": \"Calibrate the power supply.\",\n            \"parameters\": []\n        },\n        {\n            \"name\": \"calibrate_oscilloscope\",\n            \"description\": \"Calibrate the oscilloscope.\",\n            \"parameters\": []\n        },\n        {\n            \"name\": \"calibrate_vna\",\n            \"description\": \"Calibrate the Vector Network Analyzer.\",\n            \"parameters\": []\n        },\n        {\n            \"name\": \"save_measurement_data\",\n            \"description\": \"Save measurement data to a file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"data\",\n                    \"type\": \"dict\",\n                    \"description\": \"The measurement data to save.\"\n                },\n                {\n                    \"name\": \"file_name\",\n                    \"type\": \"str\",\n                    \"description\": \"The name of the file to save the data to.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"load_measurement_data\",\n            \"description\": \"Load measurement data from a file.\",\n            \"parameters\": [\n                {\n                    \"name\": \"file_name\",\n                    \"type\": \"str\",\n                    \"description\": \"The name of the file to load the data from.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"configure_power_supply\",\n            \"description\": \"Configure power supply settings.\",\n            \"parameters\": [\n                {\n                    \"name\": \"settings\",\n                    \"type\": \"dict\",\n                    \"description\": \"A dictionary containing power supply settings.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"configure_oscilloscope\",\n            \"description\": \"Configure oscilloscope settings.\",\n            \"parameters\": [\n                {\n                    \"name\": \"settings\",\n                    \"type\": \"dict\",\n                    \"description\": \"A dictionary containing oscilloscope settings.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"configure_vna\",\n            \"description\": \"Configure Vector Network Analyzer settings.\",\n            \"parameters\": [\n                {\n                    \"name\": \"settings\",\n                    \"type\": \"dict\",\n                    \"description\": \"A dictionary containing VNA settings.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"check_instrument_compatibility\",\n            \"description\": \"Check if the connected instruments are compatible for the planned measurements.\",\n            \"parameters\": []\n        },\n        {\n            \"name\": \"perform_full_system_check\",\n            \"description\": \"Perform a comprehensive system check before starting measurements.\",\n            \"parameters\": []\n        },\n        {\n            \"name\": \"report_system_status\",\n            \"description\": \"Generate a report on the status of connected instruments and overall system health.\",\n            \"parameters\": []\n        }\n    ]\n}",
    "examples\\digital_multimeter_example.py": "from pytestlab.instruments.DigitalMultimeter import DigitalMultimeter\nimport json\n# connect to the digital multimeter\npath_to_description = \"/examples/instrument_descriptions/digital_multi_meter.json\"\ndescription = json.load(open(path_to_description, \"r\"))\n\ndigital_multimeter = DigitalMultimeter(description[\"visa_resource\"], description)\n\n# print the id of the digital multimeter\nprint(digital_multimeter.id())\n\n# reset the digital multimeter\ndigital_multimeter.reset()\n\n# set the voltage of channel 1 to 1.5V\ndigital_multimeter.set_channel_voltage(1, 1.5)\n\n# get the voltage of channel 1\nprint(digital_multimeter.get_channel_voltage(1))\n\n\n# measure the frequency of channel 1\nprint(digital_multimeter.measure_frequency(1))\n\n# close the connection to the digital multimeter\ndigital_multimeter.close()",
    "examples\\oscilloscope_jitter_example.py": "from pytestlab.instruments.Oscilloscope import Oscilloscope\nfrom pytestlab.instruments.InstrumentManager import InstrumentManager\n\n# connect to the oscilloscope\noscilloscope = Oscilloscope(\"USB0::0x0957::0x1799::MY58100838::INSTR\")\n\n# reset oscilloscope\noscilloscope.reset()\n\nprint(oscilloscope.id())\n\n# get the voltage of channel 1\nprint(oscilloscope.get_channel_voltage(1))\n\n# measure the frequency of channel 1\nprint(oscilloscope.measure_frequency(1))\n\n# rms jitter measurement\nprint(oscilloscope.perform_rms_jitter_measurement(1, 0.5))\n\n# peak-to-peak jitter measurement\nprint(oscilloscope.perform_peak_to_peak_jitter_measurement(1, 0.5))\n\n# rise time measurement\nprint(oscilloscope.perform_rise_time_measurement(1, 0.5))\n\n# fall time measurement\nprint(oscilloscope.perform_fall_time_measurement(1, 0.5))\n\n# eye diagram measurement",
    "examples\\__init__.py": "",
    "examples\\instrument_descrptions\\.oscilloscope_description.py": "oscilloscope_description = {\n    \"manufacturer\": \"Keysight\",    # Manufacturer name\n    \"model\": \"Magic Oscilloscope with 2 Channels\",    # Model name/number\n    \"device_type\": \"oscilloscope\", # Device type\n    \"visa_resource\": \"USB0::0x0957::0x1799::MY58100838::INSTR\",   # VISA resource string\n    \"channels\": {\n        1: {\n            \"description\": \"Input Channel 1\",\n            \"min\": -5.0,             # Minimum voltage (in volts) supported on Channel 1\n            \"max\": 5.0,              # Maximum voltage (in volts) supported on Channel 1\n            \"input_coupling\": [\"AC\", \"DC\", \"GND\"],   # List of supported input coupling modes\n            \"input_impedance\": 1e6,   # Input impedance (in ohms) for Channel 1\n            \"probe_attenuation\": [1, 10, 100],       # List of supported probe attenuation ratios\n            # Add more channel-specific settings and limitations as needed\n        },\n        2: {\n            \"description\": \"Input Channel 2\",\n            \"min\": -5.0,             # Minimum voltage (in volts) supported on Channel 2\n            \"max\": 5.0,              # Maximum voltage (in volts) supported on Channel 2\n            \"input_coupling\": [\"AC\", \"DC\", \"GND\"],   # List of supported input coupling modes\n            \"input_impedance\": 1e6,   # Input impedance (in ohms) for Channel 2\n            \"probe_attenuation\": [1, 10, 100],       # List of supported probe attenuation ratios\n            # Add more channel-specific settings and limitations as needed\n        },\n    },\n    \"timebase\": {\n        \"min_scale\": 1e-9,         # Minimum timebase scale (in seconds) supported\n        \"max_scale\": 10.0,         # Maximum timebase scale (in seconds) supported\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"],   # List of supported time units\n        # Add more timebase-related settings and limitations as needed\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"VIDEO\", \"USB\", \"RS232\"],   # List of supported trigger modes\n        \"slope\": [\"RISING\", \"FALLING\"],          # List of supported trigger slope options\n        \"external_trigger_input\": [\"EXT\", \"EXT/10\", \"EXT/100\"],  # List of supported external trigger inputs\n        # Add more trigger-related settings and limitations as needed\n    },\n    \"bandwidth\": \"0.5 - 6 GHz\",            # Oscilloscope bandwidth (in Hz)\n    \"analog_channels\": [4, 8],             # Number of analog channels supported (upgradeable)\n    \"sampling_rate\": \"16 GSa/s\",           # Oscilloscope sampling rate (in samples per second)\n    \"standard_memory\": \"200Mpts/ch\",       # Standard memory per channel (in points)\n    \"waveform_update_rate\": \">200,000 wfms/sec\",  # Waveform update rate (in waveforms per second)\n    # Jitter analysis\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\", \"Peak-to-Peak\"],   # Types of jitter measurement\n        \"jitter_sources\": [\"Time Interval Error\", \"Phase Noise\"], # List of selectable jitter sources\n        \"analysis_depth\": 1e6,         # Maximum number of cycles or edges that can be analyzed\n        \"histogram_bins\": 256,         # Number of histogram bins for jitter distribution\n        \"modulation_analysis\": True,   # Supports modulation analysis or not\n        \"real_time_analysis\": True,    # Supports real-time jitter analysis or not\n        \"min_jitter_measurement\": 1e-12,   # Minimum measurable jitter (in seconds)\n        \"max_jitter_measurement\": 1e-3,    # Maximum measurable jitter (in seconds)\n        # Add more jitter-related settings and limitations as needed\n    }\n    # Add more settings and limitations as needed\n}\n",
    "examples\\instrument_descrptions\\digital_multimeter.py": "digital_multimeter_description = {\n    \"voltage_channels\": [1, 2],   # Supported voltage measurement channels: 1, 2\n    \"current_channels\": [1],      # Supported current measurement channels: 1\n    \"voltage_range\": 1000,        # Voltage measurement range (in Volts)\n    \"current_range\": 10,          # Current measurement range (in Amperes)\n}",
    "examples\\instrument_descrptions\\digital_power_supply.py": "digital_power_supply_description = {\n    \"channels\": {\n        1: {\"min_voltage\": 0, \"max_voltage\": 30},   # Channel 1 voltage range: 0 V to 30 V\n        2: {\"min_voltage\": 0, \"max_voltage\": 30},   # Channel 2 voltage range: 0 V to 30 V\n    },\n    \"max_current\": 5,   # Maximum current (in Amperes) supported by the power supply\n}",
    "examples\\instrument_descrptions\\oscilloscope.json": "{\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"Magic Oscilloscope with 2 Channels\",\n    \"device_type\": \"oscilloscope\",\n    \"visa_resource\": \"USB0::0x0957::0x1799::MY58100838::INSTR\",\n    \"channels\": {\n        \"1\": {\n            \"description\": \"Input Channel 1\",\n            \"min\": -5.0,\n            \"max\": 5.0,\n            \"input_coupling\": [\n                \"AC\",\n                \"DC\",\n                \"GND\"\n            ],\n            \"input_impedance\": 1000000,\n            \"probe_attenuation\": [\n                1,\n                10,\n                100\n            ]\n        },\n        \"2\": {\n            \"description\": \"Input Channel 2\",\n            \"min\": -5.0,\n            \"max\": 5.0,\n            \"input_coupling\": [\n                \"AC\",\n                \"DC\",\n                \"GND\"\n            ],\n            \"input_impedance\": 1000000,\n            \"probe_attenuation\": [\n                1,\n                10,\n                100\n            ]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 1e-9,\n        \"max_scale\": 10.0,\n        \"time_units\": [\n            \"s\",\n            \"ms\",\n            \"us\",\n            \"ns\"\n        ]\n    },\n    \"trigger\": {\n        \"available_modes\": [\n            \"EDGE\",\n            \"PULSE\",\n            \"VIDEO\",\n            \"USB\",\n            \"RS232\"\n        ],\n        \"slope\": [\n            \"RISING\",\n            \"FALLING\"\n        ],\n        \"external_trigger_input\": [\n            \"EXT\",\n            \"EXT/10\",\n            \"EXT/100\"\n        ]\n    },\n    \"bandwidth\": \"0.5 - 6 GHz\",\n    \"analog_channels\": [\n        4,\n        8\n    ],\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200Mpts/ch\",\n    \"waveform_update_rate\": \">200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\n            \"RMS\",\n            \"Peak-to-Peak\"\n        ],\n        \"jitter_sources\": [\n            \"Time Interval Error\",\n            \"Phase Noise\"\n        ],\n        \"analysis_depth\": 1000000,\n        \"histogram_bins\": 256,\n        \"modulation_analysis\": true,\n        \"real_time_analysis\": true,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n}",
    "examples\\instrument_descrptions\\train.jsonl": "  {\n    \"query\": \"Automate a frequency measurement on channel 4 with 10 Hz.\",\n    \"command_with_explanation\": \"This command automates a frequency measurement on channel 4. The signal generator will be set to 10 Hz, the output will be enabled, the frequency will be measured, and then the output will be disabled.\\n```python\\nsignal_generator.set_frequency(10, channel=4)\\nsignal_generator.enable_output(channel=4)\\nmanager.measure_frequency(10, channel=4)\\nsignal_generator.disable_output(channel=4)\\n```\"\n  },\n  {\n    \"query\": \"Perform a resistance measurement with 100 ohms.\",\n    \"command_with_explanation\": \"This command performs a resistance measurement. The multimeter will be set to measure resistance, a 100-ohm resistor will be connected, and the resistance will be measured.\\n```python\\nmultimeter.set_to_resistance()\\nmanager.connect_resistor(100)\\nresistance = multimeter.measure_resistance()\\nprint('Measured resistance:', resistance)\\n```\"\n  },\n  {\n    \"query\": \"Automate a jitter measurement on channel 5 with a peak-to-peak value of 10 ns.\",\n    \"command_with_explanation\": \"This command automates a jitter measurement on channel 5. The oscilloscope will be set to measure jitter with a peak-to-peak value of 10 ns.\\n```python\\noscilloscope.set_to_jitter(channel=5)\\nmanager.set_jitter_pp(10, channel=5)\\njitter = oscilloscope.measure_jitter()\\nprint('Measured jitter:', jitter)\\n```\"\n  },\n  {\n    \"query\": \"Perform a rise time measurement on channel 1 with 5 ms.\",\n    \"command_with_explanation\": \"This command performs a rise time measurement on channel 1. The oscilloscope will be set to measure rise time with a value of 5 ms.\\n```python\\noscilloscope.set_to_rise_time(channel=1)\\nmanager.set_rise_time(5, channel=1)\\nrise_time = oscilloscope.measure_rise_time()\\nprint('Measured rise time:', rise_time)\\n```\"\n  },\n  {\n    \"query\": \"Automate a fall time measurement on channel 2 with 5 ms.\",\n    \"command_with_explanation\": \"This command automates a fall time measurement on channel 2. The oscilloscope will be set to measure fall time with a value of 5 ms.\\n```python\\noscilloscope.set_to_fall_time(channel=2)\\nmanager.set_fall_time(5, channel=2)\\nfall_time = oscilloscope.measure_fall_time()\\nprint('Measured fall time:', fall_time)\\n```\"\n  },\n  {\n    \"query\": \"Perform a Bit Error Rate (BER) measurement with a bit sequence 10101010.\",\n    \"command_with_explanation\": \"This command performs a Bit Error Rate (BER) measurement. The bit sequence 10101010 is sent, and the received bit sequence is checked for errors.\\n```python\\nmanager.send_bit_sequence('10101010')\\nber = manager.measure_ber('10101010')\\nprint('Measured BER:', ber)\\n```\"\n  },\n  {\n    \"query\": \"Automate a power measurement on channel 3 with 5 Watts.\",\n    \"command_with_explanation\": \"This command automates a power measurement on channel 3. The power meter will be set to 5 Watts, the output will be enabled, the power will be measured, and then the output will be disabled.\\n```python\\npower_meter.set_power(5, channel=3)\\npower_meter.enable_output(channel=3)\\nmanager.measure_power(5, channel=3)\\npower_meter.disable_output(channel=3)\\n```\"\n  },\n  {\n    \"query\": \"Perform an impedance measurement with 50 Ohms.\",\n    \"command_with_explanation\": \"This command performs an impedance measurement. The multimeter will be set to measure impedance, a 50-ohm load will be connected, and the impedance will be measured.\\n```python\\nmultimeter.set_to_impedance()\\nmanager.connect_load(50)\\nimpedance = multimeter.measure_impedance()\\nprint('Measured impedance:', impedance)\\n```\"\n  },\n  {\n    \"query\": \"Automate a voltage peak-to-peak measurement on channel 1 with 5 V.\",\n    \"command_with_explanation\": \"This command automates a voltage peak-to-peak measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the voltage will be measured, and then the output will be disabled.\\n```python\\npower_supply.set_voltage(5, channel=1)\\npower_supply.enable_output(channel=1)\\nmanager.measure_voltage_pp(5, channel=1)\\npower_supply.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Perform a current peak-to-peak measurement on channel 2 with 2 A.\",\n    \"command_with_explanation\": \"This command performs a current peak-to-peak measurement on channel 2. The digital power supply will be set to 2 A, the output will be enabled, the current will be measured, and then the output will be disabled.\\n```python\\npower_supply.set_current(2, channel=2)\\npower_supply.enable_output(channel=2)\\nmanager.measure_current_pp(2, channel=2)\\npower_supply.disable_output(channel=2)\\n```\"\n  },\n  {\n    \"query\": \"Automate a pulse width measurement on channel 1 with 5 ms.\",\n    \"command_with_explanation\": \"This command automates a pulse width measurement on channel 1. The pulse generator will be set to 5 ms, the output will be enabled, the pulse width will be measured, and then the output will be disabled.\\n```python\\npulse_generator.set_pulse_width(5, channel=1)\\npulse_generator.enable_output(channel=1)\\nmanager.measure_pulse_width(5, channel=1)\\npulse_generator.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Perform a phase shift measurement between channels 1 and 2.\",\n    \"command_with_explanation\": \"This command performs a phase shift measurement between channels 1 and 2. The oscilloscope will be set to measure phase shift, and the phase shift will be measured.\\n```python\\noscilloscope.set_to_phase_shift()\\nphase_shift = oscilloscope.measure_phase_shift(channel1=1, channel2=2)\\nprint('Measured phase shift:', phase_shift)\\n```\"\n  },\n  {\n    \"query\": \"Automate a duty cycle measurement on channel 1 with 50%.\",\n    \"command_with_explanation\": \"This command automates a duty cycle measurement on channel 1. The signal generator will be set to a duty cycle of 50%, the output will be enabled, the duty cycle will be measured, and then the output will be disabled.\\n```python\\nsignal_generator.set_duty_cycle(50, channel=1)\\nsignal_generator.enable_output(channel=1)\\nmanager.measure_duty_cycle(50, channel=1)\\nsignal_generator.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Perform a Signal to Noise Ratio (SNR) measurement with a signal of 5 V and noise of 0.5 V.\",\n    \"command_with_explanation\": \"This command performs a Signal to Noise Ratio (SNR) measurement. The signal of 5 V and noise of 0.5 V is set, and the SNR is measured.\\n```python\\nmanager.set_signal_and_noise(signal=5, noise=0.5)\\nsnr = manager.measure_snr()\\nprint('Measured SNR:', snr)\\n```\"\n  },\n  {\n    \"query\": \"Automate a voltage RMS measurement on channel 1 with 5 V.\",\n    \"command_with_explanation\": \"This command automates a voltage RMS measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the RMS voltage will be measured, and then the output will be disabled.\\n```python\\npower_supply.set_voltage(5, channel=1)\\npower_supply.enable_output(channel=1)\\nmanager.measure_voltage_rms(5, channel=1)\\npower_supply.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Perform a current RMS measurement on channel 2 with 2 A.\",\n    \"command_with_explanation\": \"This command performs a current RMS measurement on channel 2. The digital power supply will be set to 2 A, the output will be enabled, the RMS current will be measured, and then the output will be disabled.\\n```python\\npower_supply.set_current(2, channel=2)\\npower_supply.enable_output(channel=2)\\nmanager.measure_current_rms(2, channel=2)\\npower_supply.disable_output(channel=2)\\n```\"\n  },\n  {\n    \"query\": \"Automate a power factor measurement on channel 1.\",\n    \"command_with_explanation\": \"This command automates a power factor measurement on channel 1. The power meter will be set to measure power factor on channel 1.\\n```python\\npower_meter.set_to_power_factor(channel=1)\\npower_factor = power_meter.measure_power_factor()\\nprint('Measured power factor:', power_factor)\\n```\"\n  },\n  {\n    \"query\": \"Perform a Total Harmonic Distortion (THD) measurement on channel 1.\",\n    \"command_with_explanation\": \"This command performs a Total Harmonic Distortion (THD) measurement on channel 1. The spectrum analyzer will be set to measure THD on channel 1.\\n```python\\nspectrum_analyzer.set_to_thd(channel=1)\\nthd = spectrum_analyzer.measure_thd()\\nprint('Measured THD:', thd)\\n```\"\n  },\n  {\n    \"query\": \"Automate a signal amplitude measurement on channel 1 with 5 V.\",\n    \"command_with_explanation\": \"This command automates a signal amplitude measurement on channel 1. The signal generator will be set to 5 V, the output will be enabled, the signal amplitude will be measured, and then the output will be disabled.\\n```python\\nsignal_generator.set_amplitude(5, channel=1)\\nsignal_generator.enable_output(channel=1)\\nmanager.measure_signal_amplitude(5, channel=1)\\nsignal_generator.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Perform a latency measurement between channel 1 and channel 2.\",\n    \"command_with_explanation\": \"This command performs a latency measurement between channel 1 and channel 2. The oscilloscope will be set to measure latency between the two channels.\\n```python\\noscilloscope.set_to_latency()\\nlatency = oscilloscope.measure_latency(channel1=1, channel2=2)\\nprint('Measured latency:', latency)\\n```\"\n  },\n  {\n    \"query\": \"Automate a cross-correlation measurement between channel 1 and channel 2.\",\n    \"command_with_explanation\": \"This command automates a cross-correlation measurement between channel 1 and channel 2. The oscilloscope will be set to measure cross-correlation between the two channels.\\n```python\\noscilloscope.set_to_cross_correlation()\\ncross_correlation = oscilloscope.measure_cross_correlation(channel1=1, channel2=2)\\nprint('Measured cross-correlation:', cross_correlation)\\n```\"\n  },\n  {\n    \"query\": \"Perform an attenuation measurement on channel 1 with 5 dB.\",\n    \"command_with_explanation\": \"This command performs an attenuation measurement on channel 1. The signal generator will be set to 5 dB, the output will be enabled, the attenuation will be measured, and then the output will be disabled.\\n```python\\nsignal_generator.set_attenuation(5, channel=1)\\nsignal_generator.enable_output(channel=1)\\nmanager.measure_attenuation(5, channel=1)\\nsignal_generator.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Automate a bandwidth measurement on channel 1 with 5 MHz.\",\n    \"command_with_explanation\": \"This command automates a bandwidth measurement on channel 1. The signal generator will be set to 5 MHz, the output will be enabled, the bandwidth will be measured, and then the output will be disabled.\\n```python\\nsignal_generator.set_bandwidth(5, channel=1)\\nsignal_generator.enable_output(channel=1)\\nmanager.measure_bandwidth(5, channel=1)\\nsignal_generator.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Perform a gain measurement on channel 1 with 5 dB.\",\n    \"command_with_explanation\": \"This command performs a gain measurement on channel 1. The signal generator will be set to 5 dB, the output will be enabled, the gain will be measured, and then the output will be disabled.\\n```python\\nsignal_generator.set_gain(5, channel=1)\\nsignal_generator.enable_output(channel=1)\\nmanager.measure_gain(5, channel=1)\\nsignal_generator.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Automate a frequency response measurement on channel 1 from 1 Hz to 1 MHz.\",\n    \"command_with_explanation\": \"This command automates a frequency response measurement on channel 1. The spectrum analyzer will be set from 1 Hz to 1 MHz, the frequency response will be measured, and then the output will be disabled.\\n```python\\nspectrum_analyzer.set_frequency_range(1, 1e6, channel=1)\\nfrequency_response = spectrum_analyzer.measure_frequency_response(channel=1)\\nprint('Measured frequency response:', frequency_response)\\n```\"\n  },\n  {\n    \"query\": \"Perform a delay measurement between channel 1 and channel 2 with 5 ms.\",\n    \"command_with_explanation\": \"This command performs a delay measurement between channel 1 and channel 2. The oscilloscope will be set to measure delay, and the delay will be measured.\\n```python\\noscilloscope.set_to_delay()\\ndelay = oscilloscope.measure_delay(channel1=1, channel2=2)\\nprint('Measured delay:', delay)\\n```\"\n  },\n  {\n    \"query\": \"Automate a power measurement on channel 1 with 5 W.\",\n    \"command_with_explanation\": \"This command automates a power measurement on channel 1. The digital power supply will be set to 5 W, the output will be enabled, the power will be measured, and then the output will be disabled.\\n```python\\npower_supply.set_power(5, channel=1)\\npower_supply.enable_output(channel=1)\\nmanager.measure_power(5, channel=1)\\npower_supply.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Perform a modulation depth measurement on channel 1 with 50%.\",\n    \"command_with_explanation\": \"This command performs a modulation depth measurement on channel 1. The signal generator will be set to 50%, the output will be enabled, the modulation depth will be measured, and then the output will be disabled.\\n```python\\nsignal_generator.set_modulation_depth(50, channel=1)\\nsignal_generator.enable_output(channel=1)\\nmanager.measure_modulation_depth(50, channel=1)\\nsignal_generator.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Automate a peak to peak voltage measurement on channel 1 with 5 V.\",\n    \"command_with_explanation\": \"This command automates a peak to peak voltage measurement on channel 1. The digital power supply will be set to 5 V, the output will be enabled, the peak to peak voltage will be measured, and then the output will be disabled.\\n```python\\npower_supply.set_voltage(5, channel=1)\\npower_supply.enable_output(channel=1)\\nmanager.measure_peak_to_peak_voltage(5, channel=1)\\npower_supply.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Perform a duty cycle measurement on channel 1 with 50%.\",\n    \"command_with_explanation\": \"This command performs a duty cycle measurement on channel 1. The signal generator will be set to 50%, the output will be enabled, the duty cycle will be measured, and then the output will be disabled.\\n```python\\nsignal_generator.set_duty_cycle(50, channel=1)\\nsignal_generator.enable_output(channel=1)\\nmanager.measure_duty_cycle(50, channel=1)\\nsignal_generator.disable_output(channel=1)\\n```\"\n  },\n  {\n    \"query\": \"Automate a temperature measurement on sensor 1 with 25 C.\",\n    \"command_with_explanation\": \"This command automates a temperature measurement on sensor 1. The digital thermometer will be set to 25 C, the measurement will be taken, and then the output will be disabled.\\n```python\\nthermometer.set_temperature(25, sensor=1)\\nmanager.measure_temperature(25, sensor=1)\\n```\"\n  },\n  {\n    \"query\": \"Perform a phase shift measurement between channel 1 and channel 2 with 90 degrees.\",\n    \"command_with_explanation\": \"This command performs a phase shift measurement between channel 1 and channel 2. The oscilloscope will be set to measure phase shift, and the phase shift will be measured.\\n```python\\noscilloscope.set_to_phase_shift()\\nphase_shift = oscilloscope.measure_phase_shift(channel1=1, channel2=2)\\nprint('Measured phase shift:', phase_shift)\\n```\"\n  }\n",
    "examples\\instrument_descrptions\\waveform_generator_description.py": "waveform_generator_description = {\n    \"channels\": {\n        1: {\"min\": 1, \"max\": 2},   # Channel 1 voltage range: 1 V to 2 V\n        2: {\"min\": 1, \"max\": 2},   # Channel 2 voltage range: 1 V to 2 V\n    },\n    \"waveform_types\": [\"SINE\", \"SQUARE\", \"TRIANGLE\", \"RAMP\"],  # Supported waveform types\n}",
    "pytestlab\\errors.py": "class SCPIConnectionError(Exception):\n    \"\"\"For SCPI instrument connection errors.\"\"\"\n\n    def __init__(self, message=\"Failed to connect to the instrument.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass SCPICommunicationError(Exception):\n    \"\"\"For SCPI communication errors.\"\"\"\n\n    def __init__(self, message=\"Error in SCPI communication.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass SCPIValueError(ValueError):\n    \"\"\"For invalid SCPI values or settings.\"\"\"\n\n    def __init__(self, message=\"Invalid value for SCPI command.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InstrumentNotFoundError(Exception):\n    \"\"\"For instrument not found errors.\"\"\"\n\n    def __init__(self, name):\n        super().__init__(f\"Instrument {name} not found in the manager's collection.\")\n\n\nclass IntrumentConfigurationError(Exception):\n    \"\"\"For instrument configuration errors.\"\"\"\n\n    def __init__(self, message=\"Invalid Instrument configuration.\"):\n        self.message = message\n        super().__init__(self.message)",
    "pytestlab\\MeasurementDatabase.py": "import sqlite3\nimport time\nimport numpy as np\nfrom datetime import datetime\nfrom dataclasses import dataclass\nimport matplotlib.pyplot as plt\n\n@dataclass\nclass Preamble:\n    \"\"\"A class to store the preamble data from the oscilloscope channel.\n\n    :param format: The format of the data\n    :param type: The type of the data\n    :param points: The number of points\n    :param xinc: The x increment\n    :param xorg: The x origin\n    :param xref: The x reference\n    :param yinc: The y increment\n    :param yorg: The y origin\n    :param yref: The y reference\n    \"\"\"\n\n    format: str\n    type: str\n    points: int\n    xinc: float\n    xorg: float\n    xref: float\n    yinc: float\n    yorg: float\n    yref: float\n\nclass MeasurementValue:\n    \"\"\"A class to represent a single measurement value and its timestamp.\n    \n    Attributes:\n        value (float): The measurement value.\n        units (str): The units of the measurement value (e.g. \"V\", \"A\", \"Ohm\", \"Hz\").\n        timestamp (float): The timestamp when the measurement was taken.\n    \"\"\"\n    def __init__(self, value, units=\"units\", timestamp=None):\n        self.value = float(value)\n        self.units = units\n        self.timestamp = timestamp if timestamp else time.time()\n\n    def __str__(self):\n        return f\"{self.value}\"\n\n    def __float__(self):\n        return self.value\n    \nclass MeasurementResult:\n    \"\"\"A class to represent a collection of measurement values.\n    \n    Attributes:\n        values (list): A list of MeasurementValue objects.\n        units (str): The units of the measurements.\n        instrument (str): The name of the instrument used for the measurements.\n        measurement_type (str): The type of measurement.\n    \"\"\"\n    def __init__(self, instrument, units, measurement_type, sampling_rate=None, realtime_timestamps=False):\n        self.values = []\n        self.units = units\n        self.instrument = instrument\n        self.timestamp = time.time()\n        self.realtime_timestamps = realtime_timestamps\n        self.measurement_type = measurement_type\n        self.sampling_rate = sampling_rate\n\n    def __str__(self):\n        string = \"\"\n        for value in self.values:\n            string += f\"{value} {self.units}\\n\"\n\n        # remove last newline\n        string = string[:-1]\n        return string\n    \n    def __repr__(self):\n        return str(self)\n    \n    def add(self, value):\n        \"\"\"Adds a new MeasurementValue to the collection.\"\"\"\n        ## append to numpy array\n        if value.units != self.units and self.units != \"units\" and value.units != \"units\":\n            raise ValueError(\"MeasurementValue units must match MeasurementResult units.\")\n        self.values = np.append(self.values, value)\n\n    def set_values(self, values):\n        \"\"\"Sets the MeasurementValues in the collection.\"\"\"\n        self.values = values\n\n    def get(self, index):\n        \"\"\"Gets the MeasurementValue at a specified index.\"\"\"\n        return self.values[index]\n\n    def get_all(self):\n        \"\"\"Returns all the MeasurementValues in the collection.\"\"\"\n        return self.values\n\n    def clear(self):\n        \"\"\"Clears all the MeasurementValues from the collection.\"\"\"\n        self.values.clear()\n    \n    def plot(self, title=None, xlabel=None, ylabel=None):\n        \"\"\"\n        Generates a plot of the measurement values.\n\n        Args:\n            title (str, optional): The title of the plot.\n            xlabel (str, optional): The label for the x-axis.\n            ylabel (str, optional): The label for the y-axis.\n        \"\"\"\n        timestamps = [value.timestamp for value in self.values]\n        measurements = [value.value for value in self.values]\n        \n        plt.figure(figsize=(10, 5))\n        if self.realtime_timestamps:\n            plt.plot(timestamps, measurements, marker='o')\n        else:\n            plt.plot(measurements, marker='o')\n        if title:\n            plt.title(title)\n        \n        xlabel = xlabel if xlabel else \"Time (s)\"\n        ylabel = ylabel if ylabel else f\"Measurement ({self.units})\"\n        \n        plt.xlabel(xlabel)\n        plt.ylabel(ylabel)\n        plt.grid(True)\n        plt.show()\n\n    def perform_fft(self):\n        \"\"\"Performs FFT on the measurement values and returns a MeasurementResult object\n        for the frequency spectrum.\n\n        Returns:\n            MeasurementResult: An object with frequencies as its measurement values.\n        \"\"\"\n        # check if is a time-domain measurement\n        if self.measurement_type == \"Frequency Spectrum\":\n            raise ValueError(\"Cannot perform FFT on Frequency Spectrum measurement.\")\n        if self.sampling_rate is None:\n            raise ValueError(\"Sampling rate must be set to perform FFT.\")\n\n        # Extract the measurement values and convert them to a numpy array\n        data = np.array([value.value for value in self.values])\n\n        # Perform the FFT\n        fft_result = np.fft.fft(data)\n\n        # Compute the frequency bins\n        freq = np.fft.fftfreq(len(fft_result), 1 / self.sampling_rate)\n\n        # Calculate the magnitudes\n        magnitudes = np.abs(fft_result)\n\n\n        # Create a new MeasurementResult for the FFT results\n        fft_measurement_result = MeasurementResult(\n            instrument=self.instrument,\n            units=self.units,\n            measurement_type=\"Frequency Spectrum\",\n            sampling_rate=self.sampling_rate,  #  for reference\n            realtime_timestamps=self.realtime_timestamps\n        )\n\n        # Populate the FFT MeasurementResult with frequency and magnitude pairs\n        for f, magnitude in zip(freq, magnitudes):\n            fft_measurement_value = MeasurementValue(value=magnitude)\n            # Normally we would set the timestamp to the frequency value\n            # Misuse the timestamp here for plotting purposes\n            fft_measurement_value.timestamp = f\n            fft_measurement_result.add(fft_measurement_value)\n\n        return fft_measurement_result\n    \n    def __len__(self):\n        return len(self.values)\n\n    def __getitem__(self, index):\n        return self.values[index]\n\n    def __iter__(self):\n        return iter(self.values)\n\n    def __delitem__(self, index):\n        del self.values[index]\n\nclass MeasurementDatabase:\n    \"\"\"\n    A class for managing a SQLite database that stores measurement results.\n    \"\"\"\n    def __init__(self, db_path):\n        self.db_path = db_path\n        self._create_tables()\n\n    def _create_tables(self):\n        with self._get_connection() as conn:\n            conn.execute('''\n                CREATE TABLE IF NOT EXISTS instruments (\n                    instrument_id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    name TEXT NOT NULL UNIQUE\n                )\n            ''')\n            conn.execute('''\n                CREATE TABLE IF NOT EXISTS measurements (\n                    measurement_id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    instrument_id INTEGER NOT NULL,\n                    timestamp TIMESTAMP NOT NULL,\n                    value REAL NOT NULL,\n                    units TEXT NOT NULL,\n                    type TEXT NOT NULL, -- 'reading' or 'fft'\n                    FOREIGN KEY (instrument_id) REFERENCES instruments(instrument_id)\n                )\n            ''')\n\n    def _get_connection(self):\n        return sqlite3.connect(self.db_path)\n\n    def store_reading(self, measurement_result: MeasurementResult):\n        \"\"\"\n        Stores a time-domain measurement result in the database.\n        \"\"\"\n        with self._get_connection() as conn:\n            # Get or create the instrument_id\n            instrument_id = self._get_or_create_instrument_id(conn, measurement_result.instrument)\n\n            # Store each MeasurementValue\n            for measurement in measurement_result:\n                conn.execute('''\n                    INSERT INTO measurements (instrument_id, timestamp, value, units, type)\n                    VALUES (?, ?, ?, ?, ?)\n                ''', (instrument_id, datetime.fromtimestamp(measurement.timestamp),\n                      measurement.value, measurement_result.units, 'reading'))\n\n    def store_fft_result(self, fft_result: MeasurementResult):\n        \"\"\"\n        Stores an FFT measurement result in the database.\n        \"\"\"\n        with self._get_connection() as conn:\n            # Get or create the instrument_id\n            instrument_id = self._get_or_create_instrument_id(conn, fft_result.instrument)\n\n            # Store each FFT result (frequency, magnitude)\n            for measurement in fft_result:\n                # Assuming timestamp field is reused to store frequency\n                conn.execute('''\n                    INSERT INTO measurements (instrument_id, timestamp, value, units, type)\n                    VALUES (?, ?, ?, ?, ?)\n                ''', (instrument_id, measurement.timestamp, measurement.value,\n                      fft_result.units, 'fft'))\n\n    def _get_or_create_instrument_id(self, conn, instrument_name):\n        \"\"\"\n        Retrieves the instrument ID for the given name, or creates it if it doesn't exist.\n        \"\"\"\n        cursor = conn.execute('SELECT instrument_id FROM instruments WHERE name = ?', (instrument_name,))\n        result = cursor.fetchone()\n        if result:\n            return result[0]\n        else:\n            cursor.execute('INSERT INTO instruments (name) VALUES (?)', (instrument_name,))\n            return cursor.lastrowid\n\n    def retrieve_measurements(self, instrument_name, measurement_type):\n        \"\"\"\n        Retrieves measurements from the database by instrument name and measurement type.\n        \"\"\"\n        with self._get_connection() as conn:\n            cursor = conn.execute('''\n                SELECT m.timestamp, m.value, m.units\n                FROM measurements m\n                JOIN instruments i ON m.instrument_id = i.instrument_id\n                WHERE i.name = ? AND m.type = ?\n            ''', (instrument_name, measurement_type))\n            return cursor.fetchall()",
    "pytestlab\\utilities.py": "import time\nfrom pytestlab.errors import InstrumentNotFoundError, SCPIConnectionError, SCPICommunicationError, SCPIValueError\n\ndef delay(seconds):\n    \"\"\"Pauses the program for the given number of seconds.\n    \n    Args:\n        seconds (float): Time to pause in seconds.\n    \"\"\"\n    time.sleep(seconds)\n\ndef validate_visa_resource(visa_resource):\n    \"\"\"Validates the VISA resource string format.\n    \n    Args:\n        visa_resource (str): The VISA resource string.\n        \n    Raises:\n        ValueError: If the VISA resource string is in an invalid format.\n    \"\"\"\n    if not visa_resource.startswith(\"TCPIP0::\"):\n        raise ValueError(\"Invalid VISA resource format. Please use TCPIP0::<IP_ADDRESS>::INSTR format for LAN instruments.\")\n\ndef check_connection(instrument):\n    \"\"\"Checks if the instrument connection is active.\n    \n    Args:\n        instrument (object): The instrument object to check the connection for.\n        \n    Raises:\n        SCPIConnectionError: If unable to connect to the instrument.\n    \"\"\"\n    try:\n        response = instrument._query(\"*IDN?\")\n        if response:\n            print(\"Connection to the instrument is active.\")\n    except Exception as e:\n        raise SCPIConnectionError()\n\nclass InstrumentCollection:\n    \"\"\"A class to manage a collection of instruments.\n    \n    Attributes:\n        instruments (dict): A dictionary to store instrument objects by their names.\n    \"\"\"\n    def __init__(self):\n        self.instruments = {}\n\n    def add(self, name, instrument):\n        \"\"\"Adds an instrument to the collection.\"\"\"\n        self.instruments[name] = instrument\n\n    def get(self, name):\n        \"\"\"Gets an instrument by its name.\"\"\"\n        if name in self.instruments:\n            return self.instruments[name]\n        else:\n            raise InstrumentNotFoundError(name)\n\n    # ... (continue with the remaining methods in the same manner)\n",
    "pytestlab\\__init__.py": "",
    "pytestlab\\instruments\\AutoInstrument.py": "from pytestlab.instruments.Oscilloscope import Oscilloscope, DigitalOscilloscopeWithJitter\nfrom pytestlab.instruments.DigitalMultimeter import DigitalMultimeter\nfrom pytestlab.instruments.WaveformGenerator import WaveformGenerator\nfrom pytestlab.instruments.DigitalPowerSupply import DigitalPowerSupply\nfrom pytestlab.errors import InstrumentConfigurationError\n\ndef AutoInstrument(profile):\n    \"\"\"\n    Automatically instantiate and return an instrument object based on a given profile.\n\n    Args:\n        profile (dict): A dictionary profile containing information about the instrument to be created. \n                            The dictionary should contain a \"device_type\" key with a string value \n                            specifying the type of the device (\"oscilloscope\", \"digital_multimeter\", \n                            \"waveform_generator\", \"digital_power_supply\"). \n                            Additional will be required depending on the device type.\n                            \n    Returns:\n        Object: An instance of the corresponding instrument class, initialized based on the profile.\n\n    Raises:\n        InstrumentConfigurationError: If the device type is not recognized or missing in the profile.\n    \"\"\"\n    match profile[\"device_type\"]:\n        case \"oscilloscope\":\n            if profile[\"jitter_analysis\"]:\n                return DigitalOscilloscopeWithJitter(profile[\"visa_resource\"], profile)\n            else:\n                return Oscilloscope(profile[\"visa_resource\"], profile)\n        case \"digital_multimeter\":\n            return DigitalMultimeter(profile[\"visa_resource\"], profile)\n        case \"waveform_generator\":\n            return WaveformGenerator(profile[\"visa_resource\"], profile)\n        case \"digital_power_supply\":\n            return DigitalPowerSupply(profile[\"visa_resource\"], profile)\n        case _:\n            raise InstrumentConfigurationError()\n",
    "pytestlab\\instruments\\DigitalMultimeter.py": "from pytestlab.instruments.instrument import SCPIInstrument, SCPIConnectionError, SCPICommunicationError\n\nclass DigitalMultimeter(SCPIInstrument):\n    \"\"\"\n    A class representing a Digital Multimeter that inherits from the SCPIInstrument class.\n\n    Provides methods for measuring voltage, current, resistance, frequency, and testing continuity.\n\n    Attributes:\n        visa_resource (str): The VISA address of the device.\n        description (dict): A dictionary containing additional information about the device, including supported channels.\n    \"\"\"\n\n    def __init__(self, visa_resource, description):\n        \"\"\"\n        Initializes a DigitalMultimeter instance.\n\n        Args:\n            visa_resource (str): The VISA address of the device.\n            description (dict): A dictionary containing additional information about the device.\n        \"\"\"\n        super().__init__(visa_resource)\n        self.description = description\n\n    def measure_voltage(self, channel=1):\n        \"\"\"\n        Measures the DC voltage on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            float: The measured voltage.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"voltage_channels\"]:\n            raise ValueError(f\"Invalid voltage channel {channel}. Supported voltage channels: {self.description['voltage_channels']}\")\n        voltage = self._query(f\"MEASURE:VOLTAGE:DC? (@{channel})\")\n        return float(voltage)\n\n    def measure_current(self, channel=1):\n        \"\"\"\n        Measures the DC current on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            float: The measured current.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"current_channels\"]:\n            raise ValueError(f\"Invalid current channel {channel}. Supported current channels: {self.description['current_channels']}\")\n        current = self._query(f\"MEASURE:CURRENT:DC? (@{channel})\")\n        return float(current)\n\n    def measure_resistance(self, channel=1):\n        \"\"\"\n        Measures the resistance on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            float: The measured resistance.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"resistance_channels\"]:\n            raise ValueError(f\"Invalid resistance channel {channel}. Supported resistance channels: {self.description['resistance_channels']}\")\n        resistance = self._query(f\"MEASURE:RESISTANCE? (@{channel})\")\n        return float(resistance)\n\n    def measure_frequency(self, channel=1):\n        \"\"\"\n        Measures the frequency on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            float: The measured frequency.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"frequency_channels\"]:\n            raise ValueError(f\"Invalid frequency channel {channel}. Supported frequency channels: {self.description['frequency_channels']}\")\n        frequency = self._query(f\"MEASURE:FREQUENCY? (@{channel})\")\n        return float(frequency)\n\n    def test_continuity(self, channel=1):\n        \"\"\"\n        Tests for electrical continuity on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            bool: True if continuity is present, False otherwise.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"continuity_channels\"]:\n            raise ValueError(f\"Invalid continuity channel {channel}. Supported continuity channels: {self.description['continuity_channels']}\")\n        continuity = self._query(f\"TEST:CONTINUITY? (@{channel})\")\n        return bool(int(continuity))  # Assuming continuity returns 1 for True and 0 for False\n",
    "pytestlab\\instruments\\DigitalPowerSupply.py": "from pytestlab.instruments.instrument import SCPIInstrument\nfrom pytestlab.errors import SCPICommunicationError\n\nclass DigitalPowerSupply(SCPIInstrument):\n    \"\"\"\n    A class representing a Digital Power Supply that inherits from the SCPIInstrument class.\n\n    Provides methods for setting voltage and current, and for enabling or disabling the output.\n\n    Attributes:\n        visa_resource (str): The VISA address of the device.\n        description (dict): A dictionary containing additional information about the device.\n    \"\"\"\n\n    def __init__(self, visa_resource, description):\n        \"\"\"\n        Initializes a DigitalPowerSupply instance.\n\n        Args:\n            visa_resource (str): The VISA address of the device.\n            description (dict): A dictionary containing additional information about the device.\n        \"\"\"\n        super().__init__(visa_resource)\n        self.description = description\n\n    def set_voltage(self, voltage, channel=1):\n        \"\"\"\n        Sets the voltage for the specified channel.\n\n        Args:\n            voltage (float): The voltage value to set.\n            channel (int, optional): The channel number. Default is 1.\n\n        Raises:\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\n        \"\"\"\n        self._check_channel_range(channel, voltage, \"voltage\")\n        self._send_command(f\"VOLTAGE{channel} {voltage}\")\n\n    def set_current(self, current, channel=1):\n        \"\"\"\n        Sets the current for the specified channel.\n\n        Args:\n            current (float): The current value to set.\n            channel (int, optional): The channel number. Default is 1.\n\n        Raises:\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\n        \"\"\"\n        self._check_channel_range(channel, current, \"current\")\n        self._send_command(f\"CURRENT{channel} {current}\")\n\n    def enable_output(self, channel=1):\n        \"\"\"\n        Enables the output for the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Raises:\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\n        \"\"\"\n        self._send_command(f\"OUTPUT{channel} ON\")\n\n    def disable_output(self, channel=1):\n        \"\"\"\n        Disables the output for the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Raises:\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\n        \"\"\"\n        self._send_command(f\"OUTPUT{channel} OFF\")\n",
    "pytestlab\\instruments\\instrument.py": "import numpy as np\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError\nfrom pyscpi import usbtmc\nimport time\n\nclass SCPIInstrument:\n    \"\"\"\n    A class representing an SCPI-compliant instrument.\n\n    Attributes:\n        visa_resource (str): The VISA resource string that identifies the instrument.\n    \"\"\"\n\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\n        \"\"\"\n        Initialize the SCPIInstrument class.\n\n        Args:\n            visa_resource (str): The VISA resource string to use for the connection.\n        \"\"\"\n        if visa_resource:\n            self.visa_resource = visa_resource\n            self._connect()\n        elif \"vendor_id\" in profile and \"product_id\" in profile:\n            self.instrument = usbtmc.Instrument(profile[\"vendor_id\"], profile[\"product_id\"])\n        else:\n            raise ValueError(\"Either a VISA resource string or a vendor and product ID must be provided.\")\n        self.profile = profile\n        self._command_log = []\n        self.debug_mode = debug_mode\n\n    def _connect(self):\n        \"\"\"Connect to the instrument using the VISA resource string.\"\"\"\n        try:\n            import pyvisa\n            self.instrument = pyvisa.ResourceManager().open_resource(self.visa_resource)\n        except Exception as e:\n            raise SCPIConnectionError(f\"Failed to connect to the instrument: {str(e)}\")\n\n    def _read_to_np(self) -> bytes:\n        chunk_size = 1024\n        data = self.instrument.read_raw(chunk_size)\n        np.frombuffer(data[10:], dtype=np.uint8)\n        header = data[2:10].decode('utf-8')\n        data = np.frombuffer(data[10:], dtype=np.uint8)\n        self._log(header)\n\n        hpoints = int(header)\n\n        while len(data) < hpoints:\n            data = np.append(data, np.frombuffer(\n                self.instrument.read_raw(chunk_size), dtype=np.uint8))\n\n        return data[:-1]\n\n    def _send_command(self, command):\n        \"\"\"\n        Send an SCPI command to the instrument.\n\n        Args:\n            command (str): The SCPI command to send.\n\n        Raises:\n            SCPICommunicationError: If sending the command fails.\n        \"\"\"\n        try:\n            self.instrument.write(command)\n            self._command_log.append({\"command\": command, \"success\": True, \"type\": \"write\", \"timestamp\":time.time})\n        except Exception as e:\n            raise SCPICommunicationError(f\"Failed to send command: {str(e)}\")\n\n    def _query(self, query):\n        \"\"\"\n        Query the instrument and return the response.\n\n        Args:\n            query (str): The SCPI query to send.\n\n        Returns:\n            str: The instrument's response to the query.\n\n        Raises:\n            SCPICommunicationError: If the query fails.\n        \"\"\"\n        try:\n            response =  self.instrument.query(query)\n            print(response)\n            self._command_log.append({\"command\": query, \"success\": True, \"type\": \"query\", \"timestamp\":time.time})\n            self.instrument.query(\"*OPC?\")\n            return response\n        except Exception as e:\n            self._command_log.append({\"command\": query, \"success\": False, \"type\": \"query\", \"timestamp\":time.time})\n            raise SCPICommunicationError(f\"Failed to query instrument: {str(e)}\")\n        \n    def _wait(self):\n        \"\"\"\n        Blocks until all previous commands have been processed by the instrument.\n        \"\"\"\n        self.instrument.query(\"*OPC?\")\n\n    def _log(self, message):\n        \"\"\"\n        Log a message.\n\n        Args:\n            message (str): The message to log.\n        \"\"\"\n        if self.debug_mode:\n            print(message)\n\n    def _history(self):\n        \"\"\"\n        Prints history of executed commands\n        \"\"\"\n        for command in self._command_log:\n            print(command)\n    def id(self):\n        \"\"\"\n        Query the instrument for its identification.\n\n        Returns:\n            str: The identification string of the instrument.\n        \"\"\"\n        return self._query(\"*IDN?\")\n    \n    def _check_valid_channel(self, selected_channel):\n        valid_channels = self.profile[\"channels\"].keys()\n        min_limit = min(valid_channels)\n        max_limit = max(valid_channels)\n        assert isinstance(selected_channel, int), f\"Channel must be an integer. Received: {selected_channel}\"\n        assert selected_channel in valid_channels, f\"Invalid Channel Selected: {selected_channel}. Available Channels: {min_limit} to {max_limit}\"\n\n    def close(self):\n        \"\"\"Close the connection to the instrument.\"\"\"\n        self.instrument.close()\n\n    def reset(self):\n        \"\"\"Reset the instrument to its default settings.\"\"\"\n        self._send_command(\"*RST\")\n\n    def set_channel_voltage(self, channel, voltage):\n        \"\"\"\n        Set the voltage for a specific channel.\n\n        Args:\n            channel (int or str): The channel for which to set the voltage.\n            voltage (float): The voltage value to set.\n        \"\"\"\n        self._check_valid_channel(channel)\n        self._send_command(f\"CHAN{channel}:VOLT {voltage}\")\n\n    def get_channel_voltage(self, channel):\n        \"\"\"\n        Get the voltage for a specific channel.\n\n        Args:\n            channel (int or str): The channel for which to get the voltage.\n\n        Returns:\n            float: The voltage value for the channel.\n        \"\"\"\n        self._check_valid_channel(channel)\n        response = self._query(f\"CHAN{channel}:VOLT?\")\n        return float(response)\n\n    def measure_frequency(self, channel):\n        \"\"\"\n        Measure the frequency for a specific channel.\n\n        Args:\n            channel (int or str): The channel for which to measure the frequency.\n\n        Returns:\n            float: The measured frequency value for the channel.\n        \"\"\"\n        self._check_valid_channel(channel)\n        response = self._query(f\"MEAS:FREQ? CHAN{channel}\")\n        return float(response)\n",
    "pytestlab\\instruments\\InstrumentManager.py": "import time\nfrom pytestlab import InstrumentCollection\n\nclass InstrumentManager:\n    def __init__(self):\n        self.instrument_collection = InstrumentCollection()\n\n    # Instrument management methods\n    def add_instrument(self, name, instrument):\n        # Add an instrument to the manager's collection\n        self.instrument[name] = instrument\n\n    def remove_instrument(self, name):\n        # Remove an instrument from the manager's collection\n        del self.instruments[name]\n\n    def get_instrument(self, name):\n        # Get an instrument from the manager's collection\n        return self.instruments[name]\n\n    def list_instruments(self):\n        # List all instruments currently added to the manager\n        print(self.instrument_collection)\n\n    def disconnect_all_instruments(self):\n        # Disconnect all instruments in the manager's collection\n        for i in self.instruments:\n            self.instruments[i].close()\n        pass\n\n    def is_all_instruments_connected(self):\n        # Check if all instruments are connected\n        pass\n\n    def is_instrument_connected(self, name):\n        # Check if a specific instrument is connected\n        pass\n    # Measurement methods\n    def measure_voltage(self, voltage, channel=1):\n        # Perform a voltage measurement\n        pass\n\n    def measure_current(self, current, channel=1):\n        # Perform a current measurement\n        pass\n\n    def measure_power(self, power, channel=1):\n        # Perform a power measurement\n        pass\n\n    def measure_eye_diagram(self, test_pattern, voltage=1.0, current=0.5, channel=1, eye_duration=0.1):\n        power_supply = self.instrument_collection[\"power_supply\"]\n        oscilloscope = self.instrument_collection[\"oscilloscope\"]\n        pattern_generator = self.instrument_collection[\"pattern_generator\"]\n\n        power_supply.set_voltage(voltage, channel)\n        power_supply.set_current(current, channel)\n        power_supply.enable_output(channel)\n\n        pattern_generator.load_pattern(test_pattern)\n        pattern_generator.enable_output()\n\n        oscilloscope.set_channel(channel)\n        oscilloscope.start_measurement()\n\n        # Wait for the test pattern to stabilize and the oscilloscope to capture data\n        time.sleep(eye_duration)\n\n        oscilloscope.stop_measurement()\n        data = oscilloscope.get_measurement_data()\n\n        power_supply.disable_output()\n        pattern_generator.disable_output()\n\n        #Data needs to be processed to generate Eye Diagram by frontend\n        # eye_diagram = process_eye_data(data)\n        return data\n        # return eye_diagram\n\n    def perform_s21_measurement(self, frequency, power_level, channel=1, measurement_time=0.1):\n        signal_generator = self.instrument_collection[\"signal_generator\"]\n        vna = self.instrument_collection[\"vna\"]\n\n        signal_generator.set_frequency(frequency)\n        signal_generator.set_power_level(power_level)\n        signal_generator.enable_output()\n\n        vna.set_channel(channel)\n        vna.set_frequency(frequency)\n        vna.set_power_level(power_level)\n        vna.set_s_parameter(\"S21\")\n        vna.start_measurement()\n\n        # Wait for the measurement to stabilize and complete\n        time.sleep(measurement_time)\n\n        s21_result = vna.get_measurement_data(\"S21\")\n\n        signal_generator.disable_output()\n        vna.stop_measurement()\n\n        return s21_result\n\n        \n    # Calibration methods\n    def calibrate_power_supply(self):\n        # Calibrate the power supply\n        pass\n\n    def calibrate_oscilloscope(self):\n        # Calibrate the oscilloscope\n        pass\n\n    def calibrate_vna(self):\n        # Calibrate the Vector Network Analyzer\n        pass\n\n    # Data handling methods\n    def save_measurement_data(self, data, file_name):\n        # Save measurement data to a file\n        pass\n\n    def load_measurement_data(self, file_name):\n        # Load measurement data from a file\n        pass\n\n    # Instrument configuration methods\n    def configure_power_supply(self, settings):\n        # Configure power supply settings (e.g., voltage limits, current limits)\n        pass\n\n    def configure_oscilloscope(self, settings):\n        # Configure oscilloscope settings (e.g., timebase, trigger settings)\n        pass\n\n    def configure_vna(self, settings):\n        # Configure Vector Network Analyzer settings (e.g., frequency range, calibration)\n        pass\n\n    # Additional utility methods as needed\n    def check_instrument_compatibility(self):\n        # Check if the connected instruments are compatible for the planned measurements\n        pass\n\n    def perform_full_system_check(self):\n        # Perform a comprehensive system check before starting measurements\n        pass\n\n    def report_system_status(self):\n        # Generate a report on the status of connected instruments and overall system health\n        pass\n",
    "pytestlab\\instruments\\Oscilloscope.py": "import time\nfrom typing import List\nfrom pytestlab.instruments.instrument import SCPIInstrument\nfrom pytestlab.MeasurementDatabase import MeasurementResult, Preamble, MeasurementValue\nfrom pytestlab.errors import SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\nimport numpy as np\nclass Oscilloscope(SCPIInstrument):\n    \"\"\"\n    Provides an interface for controlling and acquiring data from an oscilloscope using SCPI commands.\n\n    This class inherits from SCPIInstrument and implements specific methods to interact with \n    oscilloscope features such as voltage measurement and timebase scaling.\n\n    Attributes:\n    visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\n    profile (dict): Information about the instrument model.\n    \"\"\"\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\n        \"\"\"\n        Initialize the Oscilloscope class with the given VISA resource and profile information.\n        \n        Args:\n        visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\n        profile (dict): Information about the instrument model.\n        \"\"\"\n        super().__init__(visa_resource=visa_resource, profile=profile, debug_mode=debug_mode)\n        assert \"model\" in self.profile, \"Oscilloscope model not specified in profile.\"\n\n    def _read_preamble(self):\n        \"\"\"Reads the preamble from the oscilloscope.\n\n        :param inst: The instrument object from pyscpi or pyvisa\n        :param debug: Print debug messages\n        :return: A Preamble object\n\n        \"\"\"\n\n        peram = self._query(':WAVeform:PREamble?')\n        peram = peram.split(',')\n        self._log(peram)\n\n        pre = Preamble(peram[0], peram[1], int(peram[2]), float(peram[4]), float(\n            peram[5]), float(peram[6]), float(peram[7]), float(peram[8]), float(peram[9]))\n\n        return pre\n\n    def _read_wave_data(self, channel: int, points: int) -> np.ndarray:\n\n        self._wait()\n        self._send_command(f':WAVeform:SOURce CHANnel{channel}')\n        self._query('*OPC?')\n        self._log('Reading channel ' + str(channel))\n\n        self._send_command(':WAVeform:FORMat BYTE')\n        self._send_command(':WAVeform:POINts:MODE MAXimum')\n\n        self._log('Reading points')\n\n        if points > 0:\n            self._send_command(f':WAVeform:POINts {points}')\n        else:\n            self._send_command(':WAVeform:POINts MAXimum')\n\n        self._wait()\n\n        self._log('Reading data')\n\n        self._send_command(':WAVeform:DATA?')\n        data = self._read_to_np()\n\n        return data\n    \n    def auto_scale(self):\n        \"\"\"\n        Auto scale the oscilloscope display.\n        \n        This method sends an SCPI command to the oscilloscope to auto scale the display.\n        \n        Example:\n        >>> auto_scale()\n        \"\"\"\n        self._send_command(\":AUToscale\")\n\n    def set_time_axis(self, scale: float, position: float) -> None:\n        \"\"\"\n        Sets the time axis of the Oscilloscope. (x-axis)\n\n        :param scale: scale The scale of the axis in seconds \n        :param position: The position of the time axis from the trigger in seconds\n        \"\"\"\n    \n        self._send_command(f':TIMebase:SCALe {scale}')\n        self._send_command(f':TIMebase:POSition {position}')\n        self._wait()\n    \n    def set_channel_axis(self, channel: int, scale: float, offset: float) -> None:\n        \"\"\"\n        Sets the channel axis of the oscilloscope. (y-axis)\n\n        :param channel: The channel to set\n        :param scale: The scale of the channel axis in volts\n        :param offset: The offset of the channel in volts\n        \"\"\"\n        self._send_command(f':CHANnel{channel}:SCALe {scale}')\n        self._send_command(f':CHANnel{channel}:OFFSet {offset}')\n        self._wait()\n        \n    def measure_voltage_peak_to_peak(self, channel):\n        \"\"\"\n        Measure the peak-to-peak voltage for a specified channel.\n        \n        This method sends an SCPI query to the oscilloscope to measure the peak-to-peak voltage \n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\n        \n        Args:\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\n        \n        Returns:\n        MeasurementResult: An object containing the peak-to-peak voltage measurement for the specified channel.\n        \n        Example:\n        >>> measure_voltage_peak_to_peak(\"CH1\")\n        <MeasurementResult object at 0x7f1ec2a4f510>\n        \"\"\"\n        self._check_valid_channel(channel)\n\n\n        measurement_result = MeasurementResult(self.profile[\"model\"], \"V\", \"peak to peak voltage\")\n\n        response = self._query(f\"MEAS:VPP? CHAN{channel}\")\n        measurement_result.add(response)\n        return measurement_result\n\n    def measure_rms_voltage(self, channel: int) -> MeasurementResult:\n        \"\"\"\n        Measure the root-mean-square (RMS) voltage for a specified channel.\n        \n        This method sends an SCPI query to the oscilloscope to measure the RMS voltage \n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\n        \n        Args:\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\n        \n        Returns:\n        MeasurementResult: An object containing the RMS voltage measurement for the specified channel.\n        \n        Example:\n        >>> measure_rms_voltage(\"CH1\")\n        <MeasurementResult object at 0x7f1ec2a4f590>\n        \"\"\"\n        #Error Handling\n        self._check_valid_channel(channel)\n\n\n        measurement_result = MeasurementResult(self.profile[\"model\"], \"V\", \"rms voltage\")\n        response = self._query(f\"MEAS:VRMS? CHAN{channel}\")\n        measurement_result.add(response)\n        return measurement_result\n\n    def read_channels(self, channels: List[int], points=10000, runAfter=True, timebase=None):\n        if timebase is not None:\n            self.set_timebase_scale(timebase)\n\n        self._log(points)\n        self._log(\"starting\")\n\n        for channel in channels:\n            self._check_valid_channel(channel)\n\n        # Prepare the MeasurementResult dictionary\n        sampling_rate = float(self.get_sampling_rate())\n        measurement_results = {channel: MeasurementResult(instrument=f\"{self.profile['manufacturer']}:{self.profile['model']}\", units=\"V\", measurement_type=\"Voltage\", sampling_rate=sampling_rate, realtime_timestamps=True)\n                            for channel in channels}\n\n        # Setup and digitize commands\n        channel_commands = ', '.join(f\"CHANnel{channel}\" for channel in channels)\n        self._send_command(f\"DIGitize {channel_commands}\")\n        self._send_command(f':WAVeform:SOURce CHANnel{channels[0]}')\n\n        # Read preamble to get scaling factors\n        pream = self._read_preamble()\n\n        # Prepare the time axis once, as it is the same for all channels\n        time_values = (np.arange(0, pream.points, 1) - pream.xref) * pream.xinc + pream.xorg\n\n        for i, channel in enumerate(channels):\n            data = self._read_wave_data(channel, points)\n            if len(data) != pream.points:\n                print('ERROR: points mismatch, please investigate')\n\n            # Calculate the voltage values\n            voltages = (data - pream.yref) * pream.yinc + pream.yorg\n\n            # Populate the MeasurementResult object for this channel\n            for voltage, time_val in zip(voltages, time_values):\n                measurement_results[channel].add(MeasurementValue(voltage, timestamp=time_val))\n\n        if runAfter:\n            self._send_command(\":RUN\")\n\n        return measurement_results\n    \n    # def set_probe_attenuation(self, channel, attenuation):\n    #     \"\"\"\n    #     Sets the probe attenuation for a given channel.\n\n    #     \"\"\"\n    #     self._check_valid_channel(channel)\n    #     # Set the probe attenuation for the specified channel\n    #     self._send_command(f\"CHANnel{channel}:PROBe {attenuation}\")\n\n    def get_sampling_rate(self):\n        # Send the SCPI command to query the current sampling rate\n        response = self._query(\":ACQuire:SRATe?\")\n        \n        # Parse the response to get the sampling rate value.\n        sampling_rate = float(response)\n        \n        return MeasurementValue(sampling_rate, \"Hz\")\n    \n    def set_probe_scale(self, channel, scale):\n        \"\"\"\n        Sets the probe scale for a given channel.\n\n        Parameters:\n            channel (int): The oscilloscope channel to set the scale for.\n            scale (float): The probe scale value (e.g., 10.0 for 10:1, 1.0 for 1:1).\n        \"\"\"\n        self._check_valid_channel(channel)\n\n        # The command format is hypothetical and needs to be adjusted \n        # to match the specific oscilloscope command set.\n        command = f\":PROBe:CH{channel}:ATTenuation {scale}\"\n        self._send_command(command)\n\n        # Confirm the action to the log\n        self._log(f\"Set probe scale to {scale}:1 for channel {channel}.\")\n\n    def set_timebase_scale(self, scale):\n        \"\"\"\n        Set the timebase scale of the oscilloscope.\n        \n        This method sends an SCPI command to adjust the timebase scale on the oscilloscope display.\n        \n        Args:\n        scale (float): The timebase scale in seconds per division.\n        \n        Example:\n        >>> set_timebase_scale(0.002)\n        \"\"\"\n        self._send_command(f\"TIM:SCAL {scale}\")\n\n    def get_timebase_scale(self):\n        \"\"\"\n        Retrieve the current timebase scale setting from the oscilloscope.\n        \n        This method sends an SCPI query to get the current timebase scale and encapsulates \n        the result into a MeasurementResult object.\n        \n        Returns:\n        MeasurementResult: An object containing the current timebase scale setting.\n        \n        Example:\n        >>> get_timebase_scale()\n        <MeasurementResult object at 0x7f1ec2a4f650>\n        \"\"\"\n\n        measurement_result = MeasurementResult(self.profile[\"model\"], \"s\", \"timebase scale\")\n        response = self._query(\"TIM:SCAL?\")\n\n        measurement_result.add(response)\n        return measurement_result\n\n    def set_acquisition_time(self, time):\n        \"\"\"\n        Set the total acquisition time for the oscilloscope.\n\n        ARGS;\n            time (float): The total acquisition time in seconds.\n        \"\"\"\n        # Set the total time for acquisition\n        self._send_command(f\":TIMebase:MAIN:RANGe {time}\")\n\n    def set_sample_rate(self, rate):\n        \"\"\"\n        Sets the sample rate for the oscilloscope.\n\n        Args:\n        rate (str): The desired sample rate. Valid values are 'MAX' and 'AUTO'.\n        \"\"\"\n        rate = rate.upper()\n        valid_values = [\"MAX\", \"AUTO\"]\n        if rate not in valid_values:\n            raise ValueError(f\"Invalid Valid: supported = {valid_values}\")\n        # Set the sample rate for acquisition\n        self._send_command(f\"ACQuire:SRATe {rate}\")\n\n    def set_bandwidth_limit(self, channel, bandwidth):\n        \"\"\"\n        \n        \"\"\"\n        self._check_valid_channel(channel)\n        # Limit the bandwidth to a specified frequency to reduce noise\n        self._send_command(f\"CHANnel{channel}:BANDwidth {bandwidth}\")\n\n    # def set_filtering(self, channel, filter_type, frequency):\n    #     self._check_valid_channel(channel)\n    #     # Configure a filter on the channel to isolate the desired frequency components\n    #     if self.profile[\"channels\"][channel][\"filtering\"] != \"available\":\n    #         raise ValueError(f\"Filtering is not available on Channel {channel}.\")\n        \n    #     if channel not in self.profile[\"channels\"]:\n    #         raise ValueError(f\"Invalid channel {channel}. Supported channels: {self.profile['channels']}\")\n\n    #     self._send_command(f\"CHANnel{channel}:FILTer:{filter_type} {frequency}\")\n\n    def set_trigger(self, channel, trigger_level):\n        \"\"\"\n        Sets the trigger level for a given channel.\n\n        Parameters:\n\n        \"\"\"\n        self._check_valid_channel(channel)\n        # Set the trigger level for the specified channel\n        self._send_command(f\"TRIGger:LEVel CHANnel{channel},{trigger_level}\")\n\n    # def set_trigger_mode(self, mode):\n    #     \"\"\"\n        \n    #     \"\"\"\n    #     if mode not in self.profile[\"trigger_modes\"]:\n    #         raise ValueError(f\"Invalid trigger mode {mode}. Supported trigger modes: {self.profile['trigger_modes']}\")\n    #     # Set the trigger mode to either edge or pulse\n    #     self._send_command(f\"TRIGger:MODE {mode}\")\n\n    def set_trigger_source(self, channel):\n        \"\"\"\n        \n        \"\"\"\n        self._check_valid_channel(channel)\n        # Set the trigger source to the specified channel\n        self._send_command(f\"TRIGger:SOURce CHANnel{channel}\")\n\n    # def set_trigger_edge_slope(self, slope):\n    #     \"\"\"\"\"\"\n    #     # Set the edge slope to either rising or falling\n    #     self._send_command(f\"TRIGger:EDGE:SLOPe {slope}\")\n\n    # def set_trigger_pulse_polarity(self, polarity):\n    #     # Set the pulse polarity to either positive or negative\n    #     self._send_command(f\"TRIGger:PULSe:POLarity {polarity}\")\n\n    # def set_trigger_pulse_width(self, width):\n    #     # Set the pulse width to the specified value\n    #     self._send_command(f\"TRIGger:PULSe:WIDth {width}\")\n\n    # def set_trigger_pulse_delay(self, delay):\n    #     # Set the pulse delay to the specified value\n    #     self._send_command(f\"TRIGger:PULSe:DELay {delay}\")\n\n    # def set_trigger_pulse_transition(self, transition):\n    #     # Set the pulse transition to either positive or negative\n    #     self._send_command(f\"TRIGger:PULSe:TRANsition {transition}\")\n\n    # def set_trigger_pulse_condition(self, condition):\n    #     # Set the pulse condition to either width or delay\n    #     self._send_command(f\"TRIGger:PULSe:CONdition {condition}\")\n\n    def wave_gen(self, state: bool):\n        \"\"\"\n        Enable or disable the waveform generator of the oscilloscope.\n\n        This method sends an SCPI command to enable or disable the function generator in the oscilloscope.\n        \n        Args:\n        state (str): The desired state ('ON' or 'OFF') for the waveform generator.\n        \n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\n        \n        Example:\n        >>> set_wave_gen('ON')\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        # if state not in self.profile[\"function_generator\"]:\n        #     raise ValueError(f\"Invalid state {state}. Supported states: {self.profile['function_generator']}\")\n        \n        self._send_command(f\"WGEN:OUTP {'ON' if state else 'OFF'}\")\n\n    def set_wave_gen_func(self, state):\n        \"\"\"\n        Set the waveform function for the oscilloscope's waveform generator.\n\n        This method sends an SCPI command to change the function (e.g., 'SINE', 'SQUARE') of the waveform generator.\n        \n        Args:\n        state (str): The desired function ('SINE', 'SQUARE', etc.) for the waveform generator.\n\n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\n\n        Example:\n        >>> set_wave_gen_func('SINE')\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if state not in self.profile[\"function_generator\"][\"waveform_types\"]:\n            raise ValueError(f\"Invalid state {state}. Supported states: {self.profile['function_generator']['waveform_types']}\")\n        \n        self._send_command(f\"WGEN:FUNC {state}\")\n\n    def set_wave_gen_freq(self, freq):\n        \"\"\"\n        Set the frequency for the waveform generator.\n\n        This method sends an SCPI command to set the frequency of the waveform generator.\n        \n        Args:\n        freq (float): The desired frequency for the waveform generator in Hz.\n\n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the frequency is out of range.\n\n        Example:\n        >>> set_wave_gen_freq(1000.0)\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if freq < self.profile[\"function_generator\"][\"frequency\"][\"min\"] or freq > self.profile[\"function_generator\"][\"frequency\"][\"max\"]:\n            raise ValueError(f\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\")\n\n        self._send_command(f\"WGEN:FREQ {freq}\")\n\n    def set_wave_gen_amp(self, amp):\n        \"\"\"\n        Set the amplitude for the waveform generator.\n\n        This method sends an SCPI command to set the amplitude of the waveform generator.\n        \n        Args:\n        amp (float): The desired amplitude for the waveform generator in volts.\n\n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the amplitude is out of range.\n\n        Example:\n        >>> set_wave_gen_amp(1.0)\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if amp < self.profile[\"function_generator\"][\"amplitude\"][\"min\"] or amp > self.profile[\"function_generator\"][\"amplitude\"][\"max\"]:\n            raise ValueError(f\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\")\n\n        self._send_command(f\"WGEN:VOLT {amp}\")\n\n    def set_wave_gen_offset(self, offset):\n        \"\"\"\n        Set the voltage offset for the waveform generator.\n\n        This method sends an SCPI command to set the voltage offset of the waveform generator.\n        \n        Args:\n        offset (float): The desired voltage offset for the waveform generator in volts.\n\n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the offset is out of range.\n\n        Example:\n        >>> set_wave_gen_offset(0.1)\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if offset < self.profile[\"function_generator\"][\"offset\"][\"min\"] or offset > self.profile[\"function_generator\"][\"offset\"][\"max\"]:\n            raise ValueError(f\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\")\n        \n        self._send_command(f\"WGEN:VOLT:OFFSet {offset}\")\n\n    def set_wgen_sin(self, amp: float, offset: float, freq: float) -> None:\n        \"\"\"Sets the waveform generator to a sine wave. (Only available on specific models)\n\n        :param amp: The amplitude of the sine wave in volts\n        :param offset: The offset of the sine wave in volts\n        :param freq: The frequency of the sine wave in Hz. The frequency can be adjusted from 100 mHz to 20 MHz.\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if offset < self.profile[\"function_generator\"][\"offset\"][\"min\"] or offset > self.profile[\"function_generator\"][\"offset\"][\"max\"]:\n            raise ValueError(f\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\")\n        if amp < self.profile[\"function_generator\"][\"amplitude\"][\"min\"] or amp > self.profile[\"function_generator\"][\"amplitude\"][\"max\"]:\n            raise ValueError(f\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\")\n        if freq < self.profile[\"function_generator\"][\"frequency\"][\"min\"] or freq > self.profile[\"function_generator\"][\"frequency\"][\"max\"]:\n            raise ValueError(f\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\")\n\n        self._send_command('WGEN:FUNCtion SINusoid')\n        self._send_command(f':WGEN:VOLTage {amp}')\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\n        self._send_command(f':WGEN:FREQuency {freq}')\n\n\n    def set_wgen_square(self, v0: float, v1: float, freq: float, dutyCycle: int) -> None:\n        \"\"\"Sets the waveform generator to a square wave. (Only available on specific models)\n\n        :param v0: The voltage of the low state in volts\n        :param v1: The voltage of the high state in volts\n        :param freq: The frequency of the square wave in Hz. The frequency can be adjusted from 100 mHz to 10 MHz.\n        :param dutyCycle: The duty cycle can be adjusted from 1% to 99% up to 500 kHz. At higher frequencies, the adjustment range narrows so as not to allow pulse widths less than 20 ns.\n        \"\"\"\n\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        \n        self._send_command('WGEN:FUNCtion SQUare')\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n        self._send_command(f':WGEN:FREQuency {freq}')\n        self._send_command(f':WGEN:FUNCtion:SQUare:DCYCle {dutyCycle}')\n\n\n    def set_wgen_ramp(self, v0: float, v1: float, freq: float, symmetry: int) -> None:\n        \"\"\"Sets the waveform generator to a ramp wave. (Only available on specific models)\n\n        :param v0: The voltage of the low state in volts\n        :param v1: The voltage of the high state in volts\n        :param freq: The frequency of the ramp wave in Hz. The frequency can be adjusted from 100 mHz to 100 kHz.\n        :param symmetry: Symmetry represents the amount of time per cycle that the ramp waveform is rising and can be adjusted from 0% to 100%.\n        \"\"\"\n\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        \n        self._send_command('WGEN:FUNCtion RAMP')\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n        self._send_command(f':WGEN:FREQuency {freq}')\n        self._send_command(f':WGEN:FUNCtion:RAMP:SYMMetry {symmetry}')\n\n\n    def set_wgen_pulse(self, v0: float, v1: float, period: float, pulseWidth: float) -> None:\n        \"\"\"Sets the waveform generator to a pulse wave. (Only available on specific models)\n\n        :param v0: The voltage of the low state in volts\n        :param v1: The voltage of the high state in volts\n        :param period: The period of the pulse wave in seconds. The period can be adjusted from 10 ns to 10 s.\n        :param pulseWidth: The pulse width can be adjusted from 20 ns to the period minus 20 ns.\n        \"\"\"\n\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n\n        self._send_command('WGEN:FUNCtion PULSe')\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n        self._send_command(f':WGEN:PERiod {period}')\n        self._send_command(f':WGEN:FUNCtion:PULSe:WIDTh {pulseWidth}')\n\n\n    def set_wgen_dc(self, offset: float) -> None:\n        \"\"\"Sets the waveform generator to a DC wave. (Only available on specific models)\n\n        :param offset: The offset of the DC wave in volts\n        \"\"\"\n\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if offset < self.profile[\"function_generator\"][\"offset\"][\"min\"] or offset > self.profile[\"function_generator\"][\"offset\"][\"max\"]:\n            raise ValueError(f\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\")\n        \n        self._send_command('WGEN:FUNCtion DC')\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\n\n\n    def set_wgen_noise(self, v0: float, v1: float, offset: float) -> None:\n        \"\"\"Sets the waveform generator to a noise wave. (Only available on specific models)\n\n        :param v0: The voltage of the low state in volts\n        :param v1: The voltage of the high state in volts\n        :param offset: The offset of the noise wave in volts\n        \"\"\"\n        \n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        \n        self._send_command('WGEN:FUNCtion NOISe')\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\n\n    def display_channel(self, channels, state=True) -> None:\n        \"\"\"\n        Display the specified channels on the oscilloscope.\n        \n        This method sends an SCPI command to the oscilloscope to display the specified channels.\n        \n        Args:\n        channels (list): A list of channels to display on the oscilloscope.\n        \n        Raises:\n        ValueError: If the oscilloscope model does not support the specified channel(s).\n        \n        Example:\n        >>> display_channel([\"CH1\", \"CH2\"])\n        \"\"\"\n        for channel in channels:\n            self._check_valid_channel(channel)\n        # Implement SCPI commands to display the specified channels\n        self._send_command(f\"CHAN:{channels}:DISP {'ON' if state else 'OFF'}\")\n\n\n    def fft_display(self, state=True):\n        \"\"\"\n        Switches on the FFT display\n\n        :param state: The state of the FFT display\n        \"\"\"\n        assert \"fft\" in self.profile, \"FFT is not available on this oscilloscope.\"\n\n        self._send_command(f\":FFT:DISPlay {'ON' if state else 'OFF'}\")\n        self._log(f\"FFT display {'enabled' if state else 'disabled'}.\")\n\n    def function_display(self, state=True):\n        \"\"\"\n        Switches on the function display\n\n        :param state: The state of the function display\n        \"\"\"\n        \n        self._send_command(f\":FUNCtion:DISPlay {'ON' if state else 'OFF'}\")\n        self._log(f\"Function display {'enabled' if state else 'disabled'}.\")\n\n    def configure_fft(self, source_channel: int, scale: float = None, offset: float = None, window_type: str = 'HANNing', units: str = 'DECibel', display: bool = True):\n        \"\"\"\n        Configure the oscilloscope to perform an FFT on the specified channel with the given parameters.\n\n        :param source_channel: The channel number to perform FFT on.\n        :param scale: The scale of the FFT display in dB. Defaults to None.\n        :param offset: The offset of the FFT display. Defaults to None.\n        :param window_type: The windowing function to apply. Defaults to 'HANNing'.\n        :param units: The unit of measurement for the FFT (DECibel or VRMS). Defaults to 'DECibel'.\n        :param display: A boolean to turn the FFT display ON or OFF. Defaults to True.\n        \"\"\"\n\n        # Ensure the oscilloscope supports FFT and the specified channel is valid\n        assert \"fft\" in self.profile, \"FFT is not available on this oscilloscope.\"\n        assert source_channel in self.profile[\"channels\"], f\"Invalid channel {source_channel}. Supported channels: {self.profile['channels']}\"\n        assert window_type in self.profile[\"fft\"][\"window_types\"], f\"Invalid window type {window_type}. Supported window types: {self.profile['fft']['window_types']}\"\n        assert units in self.profile[\"fft\"][\"units\"], f\"Invalid units {units}. Supported units: {self.profile['fft']['units']}\"\n\n        # Set the FFT source to the specified channel\n        self._send_command(f':FFT:SOURce1 CHANnel{source_channel}')\n        # Configure the FFT window type\n        self._send_command(f':FFT:WINDow {window_type}')\n        # Configure the FFT vertical type (units)\n        self._send_command(f':FFT:VTYPe {units}')\n        # Set the scale if provided\n        if scale is not None:\n            self._send_command(f':FFT:SCALe {scale}dB')\n        # Set the offset if provided\n        if offset is not None:\n            self._send_command(f':FFT:OFFSet {offset}')\n        # Turn the FFT display on or off based on the parameter\n        display_state = '1' if display else '0'\n        self._send_command(f':FFT:DISPlay {display_state}')\n\n        self._log(f\"FFT configured for channel {source_channel}.\")\n\n    def _convert_binary_block_to_data(self, binary_block):\n        # Process the binary data header to determine the size of the block\n        header_len = int(binary_block[1])  # Assuming the length of the length field itself is 1 byte\n        expected_data_points = int(binary_block[2:2+header_len])\n\n        # Use _read_to_np to read the binary data into a NumPy array\n        data = self._read_to_np()\n\n        # Ensure that we've read the correct number of data points\n        assert len(data) == expected_data_points, \"Data size mismatch\"\n\n        # Data is now in a NumPy array format and can be reshaped or processed as needed\n        # For FRANalysis, the data often comes in pairs representing frequency and response (magnitude/phase)\n        # so we need to reshape the array accordingly\n        data_points_per_entry = 2  # Assuming each data point consists of a frequency and a corresponding value\n        structured_data = data.reshape((-1, data_points_per_entry))\n        \n    def perform_franalysis(self, input_channel, output_channel, start_freq, stop_freq, points=1000, mode='SWEep'):\n        \"\"\"\n        Perform a frequency response analysis on the oscilloscope.\n\n        :param input_channel: The channel number to use as the input.\n        :param output_channel: The channel number to use as the output.\n        :param start_freq: The start frequency of the analysis in Hz.\n        :param stop_freq: The stop frequency of the analysis in Hz.\n        :param points: The number of points to use for the analysis.\n        \"\"\"\n        # Validate input\n        self._check_valid_channel(input_channel)\n        self._check_valid_channel(output_channel)\n        assert mode in ['SWEep', 'SINGle'], 'Mode should be \"SWEep\" or \"SINGle\"'\n        assert 10 <= start_freq < stop_freq <= 20000000, 'Frequency range should be within 10 Hz to 20 MHz'\n        assert points > 0, 'Number of points must be positive'\n\n        # Enable FRANalysis\n        self._send_command(\":FRANalysis:ENABle 1\")\n\n        # Set the start and stop frequencies\n        self._send_command(f\":FRANalysis:FREQuency:STARt {start_freq}Hz\")\n        self._send_command(f\":FRANalysis:FREQuency:STOP {stop_freq}Hz\")\n\n        # Set the mode\n        self._send_command(f\":FRANalysis:FREQuency:MODE {mode}\")\n\n        # If single frequency mode, set the single frequency, otherwise set points for sweep\n        if mode == 'SINGle':\n            self._send_command(f\":FRANalysis:FREQuency:SINGle {start_freq}Hz\")\n        else:\n            # Not directly provided in the command summary, assuming there's a command for points\n            assert points > 0, 'Number of points must be positive'\n            # TODO remove this hard-coded limit - only for DSOX1204G\n            assert points <= 1000, 'Number of points must be less than 1000'\n            self._send_command(f\":FRANalysis:SWEep:POINts {points}\")\n\n        # Initiate FRANalysis\n        self._send_command(\":FRANalysis:RUN\")\n\n        # Wait for analysis to complete and then read the data\n        # The waiting mechanism is not detailed, assuming there's a method for it\n        self._wait()\n        # Read the FRANalysis data (binary block format)\n        franalysis_data = self._query(\":FRANalysis:DATA?\")\n\n        # Process the binary block data into a structured format\n        # Assuming a helper function to convert binary block to numerical data\n        data = self._read_preamble()\n        # data = self._convert_binary_block_to_data(franalysis_data)\n\n        # Disable FRANalysis after completion\n        self._send_command(\":FRANalysis:ENABle 0\")\n\n        # Return the processed data\n        return data\n    \n    def read_fft_data(self) -> MeasurementResult:\n        \"\"\"\n        Perform the FFT and read the data from the oscilloscope, returning it as a MeasurementResult.\n\n        :return: A MeasurementResult object containing the FFT data.\n        \"\"\"\n        self._log('Initiating FFT data read.')\n        \n        # The oscilloscope setup for FFT should be done before calling this method\n        # Make sure that the acquisition is already started or in continuous mode\n        \n        # Assuming :FUNCtion:DATA? returns the FFT data from the oscilloscope\n        self._send_command(':FUNCtion:DATA?')\n        fft_data = self._read_to_np()\n        \n        # Now, instead of just returning fft_data, we need to encapsulate it into MeasurementValue objects\n        # and then add these to a MeasurementResult object.\n\n        # For this example, let's assume 'self.sampling_rate' is set and represents the sampling rate used for FFT\n        if self.sampling_rate is None:\n            raise ValueError(\"Sampling rate must be set to read FFT data.\")\n        \n        # Compute the frequency bins for the FFT data\n        freq = np.fft.fftfreq(len(fft_data), 1 / self.sampling_rate)\n        \n        units = self._query(\":FFT:VTYPe?\")\n        # Create a new MeasurementResult for the FFT results\n        fft_measurement_result = MeasurementResult(\n            instrument=self.instrument,  # Replace with actual attribute, if different\n            units=units,  \n            measurement_type=\"Frequency Spectrum\",\n            sampling_rate=self.sampling_rate  # Including the sampling rate for reference\n        )\n        \n        # Populate the MeasurementResult with MeasurementValue objects\n        for f, magnitude in zip(freq, fft_data):\n            fft_measurement_value = MeasurementValue(value=magnitude)\n            # Normally, timestamp would be set to the time the measurement was taken\n            # In this case, we can repurpose it to store the frequency, if that's acceptable for your design\n            fft_measurement_value.timestamp = f\n            fft_measurement_result.add(fft_measurement_value)\n        \n        return fft_measurement_result\n\n# class DigitalOscilloscopeWithJitter(Oscilloscope):\n\n#     def __init__(self, visa_resource, profile):\n#         super().__init__(visa_resource, profile)\n\n#     def _available_jitter_measurements(self, jitter_type):\n#         if jitter_type not in self.profile[\"jitter_analysis\"][\"available_types\"]:\n#             raise ValueError(f\"Invalid jitter type {jitter_type}. Supported jitter types: {self.profile['jitter_analysis']}\")\n\n#     def setup_rms_jitter_measurement(self, channel):\n#         self._available_jitter_measurements(\"rms\")\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\n#         self._send_command(f\"MEASure:JITTer:SOURce CHANnel{channel}\")\n#         self._send_command(\"MEASure:JITTer:MODE RMS\")\n\n#     def setup_peak_to_peak_jitter_measurement(self, channel):\n#         self._available_jitter_measurements(\"peak_to_peak\")\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\n#         self._send_command(f\"MEASure:JITTer:SOURce CHANnel{channel}\")\n#         self._send_command(\"MEASure:JITTer:MODE PK2PK\")\n\n#     def setup_period_jitter_measurement(self, channel):\n#         self._available_jitter_measurements(\"period\")\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\n#         self._send_command(f\"MEASure:JITTer:SOURce CHANnel{channel}\")\n#         self._send_command(\"MEASure:JITTer:MODE PERiod\")\n\n#     def setup_cycle_to_cycle_jitter_measurement(self, channel):\n#         self._available_jitter_measurements(\"cycle_to_cycle\")\n#         # Implement SCPI commands to set up the oscilloscope for jitter measurement\n#         self._send_command(f\"MEASure:JITTer:SOURce CHANnel{channel}\")\n#         self._send_command(\"MEASure:JITTer:MODE CCYCle\")\n\n#     def configure_trigger(self, trigger_source, trigger_level):\n#         # Implement SCPI commands to configure trigger settings for jitter measurement\n#         self._send_command(f\"TRIGger:SOURce CHANnel{trigger_source}\")\n#         self._send_command(f\"TRIGger:LEVel CHANnel{trigger_source},{trigger_level}\")\n\n#     def acquire_jitter_data(self):\n#         # Implement SCPI commands to acquire jitter data from the oscilloscope\n#         self._send_command(\"ACQuire:STATE RUN\")\n\n#     def analyze_jitter_data(self):\n#         measurement_result = MeasurementResult(self.profile[\"model\"], \"s\", \"jitter\")\n#         jitter_value = self._query_command(\"MEASure:JITTer?\")\n#         measurement_result.add_measurement(jitter_value)\n#         return measurement_result\n    \n#     def perform_rms_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\n#         self.setup_rms_jitter_measurement(channel)\n#         self.configure_trigger(trigger_source, trigger_level)\n#         self.acquire_jitter_data()\n#         return self.analyze_jitter_data()\n    \n#     def perform_peak_to_peak_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\n#         \"\"\"\n#         Perform a peak-to-peak jitter measurement on a specified channel with given trigger settings.\n        \n#         This method sets up the measurement, configures the trigger, acquires the jitter data and \n#         then analyzes the data to return a MeasurementResult object containing the results of \n#         the jitter measurement.\n        \n#         Args:\n#         channel (str/int): The identifier for the channel on which the measurement is to be performed.\n#                         This could be an integer representing the channel number or a string representing\n#                         the channel name, depending on the implementation.\n#         trigger_source (str/int): The identifier for the trigger source. This could be an integer or a \n#                                 string representing the source depending on the implementation.\n#         trigger_level (float): The trigger level for the measurement in volts. This value sets the voltage \n#                             level at which the trigger event occurs.\n        \n#         Returns:\n#         MeasurementResult: An object containing the results of the peak-to-peak jitter measurement.\n        \n#         Raises:\n#         NotImplementedError: If any of the method calls within this function (e.g., setup_peak_to_peak_jitter_measurement, \n#                             configure_trigger, acquire_jitter_data, analyze_jitter_data) are not implemented.\n#         MeasurementError: If there is an error during the measurement process.\n        \n#         Example:\n#         >>> perform_peak_to_peak_jitter_measurement(\"CH1\", \"External\", 0.5)\n#         <MeasurementResult object at 0x7f9bd8134f50>\n#         \"\"\"\n#         self.setup_peak_to_peak_jitter_measurement(channel)\n#         self.configure_trigger(trigger_source, trigger_level)\n#         self.acquire_jitter_data()\n#         return self.analyze_jitter_data()\n\n        \n#     def perform_period_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\n#         self.setup_period_jitter_measurement(channel)\n#         self.configure_trigger(trigger_source, trigger_level)\n#         self.acquire_jitter_data()\n#         return self.analyze_jitter_data()\n\n#     def perform_cycle_to_cycle_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\n#         self.setup_cycle_to_cycle_jitter_measurement(channel)\n#         self.configure_trigger(trigger_source, trigger_level)\n#         self.acquire_jitter_data()\n#         return self.analyze_jitter_data()\n        ",
    "pytestlab\\instruments\\WaveformGenerator.py": "from pytestlab.instruments.instrument import SCPIInstrument\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\nimport numpy as np\n\nclass WaveformGenerator(SCPIInstrument):\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\n        \"\"\"\n        Initialize a WaveformGenerator instance with a device profile.\n\n        Args:\n            profile (dict): A dictionary containing device profile information.\n\n        \"\"\"\n        super().__init__(visa_resource=visa_resource, profile=profile, debug_mode=debug_mode)\n        assert \"model\" in self.profile, \"Waveform Generator model not specified in profile.\"\n\n    def _validate_waveform(self, waveform_type):\n        \"\"\"\n        Validate if the waveform type is supported by the device.\n\n        Args:\n            waveform_type (str): The type of waveform to validate.\n\n        Raises:\n            ValueError: If the waveform type is not supported.\n\n        \"\"\"\n        standard_waveforms = [w.upper() for w in self.profile.get('waveforms', {}).get('standard', [])]\n        if waveform_type.upper() not in standard_waveforms:\n            raise ValueError(f\"Invalid waveform type: {waveform_type}. Supported types: {standard_waveforms}\")\n\n    def _validate_frequency(self, frequency):\n        \"\"\"\n        Validate if the frequency is within the device's supported range.\n\n        Args:\n            frequency (float): The frequency to validate.\n\n        Raises:\n            ValueError: If the frequency is out of range.\n\n        \"\"\"\n        max_frequency = self.profile.get('max_frequency')\n        if frequency > max_frequency:\n            raise ValueError(f\"Frequency out of range. Max supported frequency: {max_frequency}\")\n\n    def _validate_amplitude(self, amplitude):\n        \"\"\"\n        Validate if the amplitude is within the device's supported range.\n\n        Args:\n            amplitude (float): The amplitude to validate.\n\n        Raises:\n            ValueError: If the amplitude is out of range.\n\n        \"\"\"\n        min_amplitude = self.profile.get('amplitude', {}).get('min', 0)\n        max_amplitude = self.profile.get('amplitude', {}).get('max', float('inf'))\n        \n        assert min_amplitude <= amplitude <= max_amplitude, f\"Amplitude out of range. Supported range: {min_amplitude} to {max_amplitude}\"\n\n    def _validate_offset(self, offset):\n        \"\"\"\n        Validate if the offset is within the device's supported range.\n\n        Args:\n            offset (float): The offset to validate.\n\n        Raises:\n            ValueError: If the offset is out of range.\n\n        \"\"\"\n        min_offset = self.profile.get('dc_offset', {}).get('min', float('-inf'))\n        max_offset = self.profile.get('dc_offset', {}).get('max', float('inf'))\n        assert min_offset <= offset <= max_offset, f\"Offset out of range. Supported range: {min_offset} to {max_offset}\"\n\n    def set_arbitrary_waveform(self, channel, waveform, scale=True):\n        \"\"\"\n        Sets the arbitrary waveform for the specified channel.\n\n        Args:\n            channel (int or str): The channel for which to set the waveform.\n            waveform (list): The arbitrary waveform to set.\n\n        \"\"\"\n        self._log(f\"Setting arbitrary waveform for channel {channel}\")\n        waveform_np = np.array(waveform)\n        awg_max_voltage = self.profile[\"amplitude\"][\"max\"]\n        awg_min_voltage = self.profile[\"amplitude\"][\"min\"]\n\n        max_length = self.profile[\"waveforms\"][\"arbitrary\"][\"max_length\"]\n        if scale:\n            waveform_normalized = (waveform - np.min(waveform)) / (np.max(waveform) - np.min(waveform))\n            waveform_scaled = waveform_normalized * (awg_max_voltage - awg_min_voltage) + awg_min_voltage\n            waveform_np = np.array(waveform_scaled)\n            self._log(f\"Waveform scaled to {awg_min_voltage} to {awg_max_voltage} V\")\n            if len(waveform_np) > max_length:\n                # squash into max_length by approximating\n                waveform_np = waveform_np[::int(len(waveform_np) / max_length)] # TODO: improve this approximation\n                self._log(f\"Waveform squashed to {max_length} samples\")\n        else:\n            self._log(f\"Waveform not scaled\")\n            if len(waveform_np) > max_length:\n                self._log(f\"Waveform length exceeds maximum length: {max_length}\")\n                raise ValueError(f\"Waveform length exceeds maximum length: {max_length}\")\n            if np.max(waveform_np) > awg_max_voltage or np.min(waveform_np) < awg_min_voltage:\n                self._log(f\"Waveform exceeds amplitude range: {awg_min_voltage} to {awg_max_voltage}\")\n                raise ValueError(f\"Waveform exceeds amplitude range: {awg_min_voltage} to {awg_max_voltage}\")\n\n        binary_waveform = waveform_np.tobytes()\n\n        self._send_command(f\"SOURCE{channel}:DATA:VOL:CLEAR\")  # Clear the volatile memory\n        self._send_command(f\"SOURCE{channel}:FUNCTION ARBITRAR\")  # Set the source to arbitrary waveform\n        self._send_command(f\"SOURCE{channel}:DATA:ARB:DAC {binary_waveform}, (@1)\")\n\n        self._log(f\"Waveform set\")\n\n    def set_waveform(self, channel, waveform_type):\n        \"\"\"\n        Sets the waveform type for the specified channel after validation.\n\n        Args:\n            channel (int or str): The channel for which to set the waveform.\n            waveform_type (str): The type of waveform to set.\n\n        \"\"\"\n        self._validate_waveform(waveform_type)\n        self._check_valid_channel(channel)\n        self._send_command(f\"SOUR{channel}:FUNC {waveform_type.upper()}\")\n        self._log(f\"Waveform set to {waveform_type}\")\n\n    def set_frequency(self, channel, frequency):\n        \"\"\"\n        Sets the frequency for the specified channel after validation.\n\n        Args:\n            channel (int or str): The channel for which to set the frequency.\n            frequency (float): The frequency to set.\n\n        \"\"\"\n        self._check_valid_channel(channel)\n        self._validate_frequency(frequency)\n        self._send_command(f\"SOUR{channel}:FREQ {frequency}\")\n        self._log(f\"Frequency set to {frequency} Hz\")\n\n    def set_amplitude(self, channel, amplitude):\n        \"\"\"\n        Sets the amplitude for the specified channel after validation.\n\n        Args:\n            channel (int or str): The channel for which to set the amplitude.\n            amplitude (float): The amplitude to set.\n\n        \"\"\"\n        self._check_valid_channel(channel)\n        self._validate_amplitude(amplitude)\n        self._send_command(f\"SOUR{channel}:VOLTage:AMPL {amplitude}\")\n\n    def set_offset(self, channel, offset):\n        \"\"\"\n        Sets the offset for the specified channel after validation.\n\n        Args:\n            channel (int or str): The channel for which to set the offset.\n            offset (float): The offset to set.\n\n        \"\"\"\n        self._validate_offset(offset)\n        self._send_command(f\"SOUR{channel}:VOLTage:OFFSet {offset}\")\n\n    def output(self, channel, state):\n        \"\"\"\n        Sets the output state for the specified channel.\n\n        Args:\n            channel (int or str): The channel for which to set the output state.\n            state (str): The state to set.\n\n        \"\"\"\n        self._send_command(f\"OUTP{channel} {'ON' if state else 'OFF'}\")\n\n# # Similar approach can be taken for PatternGenerator\n# class PatternGenerator(SCPIInstrument):\n#     def __init__(self, profile):\n#         \"\"\"\n#         Initialize a PatternGenerator instance with a device profile.\n\n#         Args:\n#             profile (dict): A dictionary containing device profile information.\n\n#         \"\"\"\n#         super().__init__()\n#         self.profile = profile\n\n#     def _validate_pattern(self, pattern):\n#         \"\"\"\n#         Validate if the pattern is supported by the device.\n\n#         Args:\n#             pattern (str): The type of pattern to validate.\n\n#         Raises:\n#             ValueError: If the pattern is not supported.\n\n#         \"\"\"\n#         standard_patterns = [p.upper() for p in self.profile.get('waveforms', {}).get('standard', [])]\n#         if pattern.upper() not in standard_patterns:\n#             raise ValueError(f\"Invalid pattern: {pattern}. Supported types: {standard_patterns}\")\n\n#     def set_pattern(self, channel, pattern):\n#         \"\"\"\n#         Sets the pattern for the specified channel after validation.\n\n#         Args:\n#             channel (int or str): The channel for which to set the pattern.\n#             pattern (str): The type of pattern to set.\n\n#         \"\"\"\n#         self._validate_pattern(pattern)\n#         self._send_command(f\"SOUR{channel}:FUNC {pattern.upper()}\")\n",
    "pytestlab\\profiles\\__init__.py": "",
    "pytestlab\\profiles\\keysight\\infiniium.py": "\noscilloscope_profile = {\n    \"MXR054A\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"MXR054A\", \n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"bandwidth\": \"500 MHz\",\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n    },\n    \"MXR058A\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"MXR058A\", \n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n      1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      2: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },  \n      3: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      4: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      5: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      6: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }, \n      7: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      8: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"bandwidth\": \"500 MHz\",  \n    \"analog_channels\": 8,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n    \"MXR104A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR104A\",\n    \"bandwidth\": \"1 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR108A\": {\n    # Same as MXR058A except: \n    \"model\": \"MXR108A\",\n    \"bandwidth\": \"1 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR204A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR204A\",\n    \"bandwidth\": \"2 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR208A\": {\n    # Same as MXR058A except:\n    \"model\": \"MXR208A\",\n    \"bandwidth\": \"2 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR254A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR254A\",\n    \"bandwidth\": \"2.5 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n  \n  \"MXR258A\": {\n    # Same as MXR058A except:\n    \"model\": \"MXR258A\",\n    \"bandwidth\": \"2.5 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR404A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR404A\", \n    \"bandwidth\": \"4 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR408A\": {\n    # Same as MXR058A except:\n    \"model\": \"MXR408A\",\n    \"bandwidth\": \"4 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR604A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR604A\",\n    \"bandwidth\": \"6 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR608A\": {\n    # Same as MXR058A except:\n    \"model\": \"MXR608A\",\n    \"bandwidth\": \"6 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  }\n}",
    "pytestlab\\profiles\\keysight\\smartbench.py": "oscilloscope_profile = {\n    \"DSOX1204A\":{\n    \"manufacturer\": \"Keysight\",\n    \"vendor_id\": 0x2A8D,\n    \"product_id\": 0x0396,\n    \"model\": \"DSOX1204A\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Analog Channel 1\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"], \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        2: {\n        \"description\": \"Analog Channel 2\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        3: {\n        \"description\": \"Analog Channel 3\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        4: {\n        \"description\": \"Analog Channel 4\",\n        \"min\": -5,\n        \"max\": 5, \n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        }\n    },\n    \"bandwidth\": 70e6,\n    \"sampling_rate\": 2e9,\n    \"memory\": 2e6,\n    \"waveform_update_rate\": 2e5,\n    \"trigger_modes\": [\"Edge\", \"Pulse Width\", \"Video\", \"I2C\", \"SPI\", \"UART/RS232\", \"CAN\", \"LIN\"],\n    \"timebase\": {  \n        \"min\": 5e-9,\n        \"max\": 50\n    }\n    },\n    \"DSOX1204G\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"DSOX1204G\",\n    \"vendor_id\": 0x2A8D,\n    \"product_id\": 0x0396,\n    \"device_type\": \"Oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Analog Channel 1\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10],\n        \"timebase\": {\n            \"range\": {\n            \"min\": 5e-9,\n            \"max\": 50\n            },\n            \"horizontal_resolution\": 1e-12\n        }\n        },\n        2: {\n        \"description\": \"Analog Channel 2\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        3: {\n        \"description\": \"Analog Channel 3\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        4: {\n        \"description\": \"Analog Channel 4\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        }\n    },\n    \"bandwidth\": 70e6,\n    \"sampling_rate\": 2e9,\n    \"memory\": 2e6,\n    \"waveform_update_rate\": 2e5,\n    \"trigger_modes\": [\"EDGE\", \"PULSe\", \"VIDEo\", \"I2C\", \"SPI\", \"UART\", \"RS232\", \"CAN\", \"LIN\"],\n    \"timebase\": {\n        \"min\": 5e-9,\n        \"max\": 50\n    },\n    \"fft\": {\n        \"window_types\": [\"RECTangular\", \"HANNing\", \"FLATtop\", \"BHARris\"],\n        \"units\": [\"DECibel\", \"VRMS\"]\n    },\n    \"function_generator\": {\n        \"waveform_types\": [\"SINusoid\", \"SQUare\", \"RAMp\", \"PULse\", \"NOISe\", \"DC\"],\n        \"supported_states\": [\"ON\", \"OFF\"],\n        \"offset\": { \n        \"min\": -5,\n        \"max\": 5\n        },\n        \"frequency\": {\n        \"min\": 0.1,\n        \"max\": 20e6\n        },\n        \"amplitude\": {\n        \"min\": 2e-3,\n        \"max\": 20    \n        }\n    }\n    }\n}\n\npower_supply_profile = {\n  \"EDU36311A\": {\n    \"manufacturer\": \"Keysight\",\n    \"vendor_id\": 0x2a8d,\n    \"product_id\": 0x8f01,\n    \"model\": \"EDU36311A\",\n    \"device_type\": \"powersupply\",\n    \n    \"outputs\": {\n      1: {\n        \"voltage\": {\n          \"min\": 0,\n          \"max\": 6\n        },\n        \"current\": {\n          \"min\": 0, \n          \"max\": 5\n        }\n      },\n      2: {\n        \"voltage\": {\n          \"min\": 0,\n          \"max\": 30\n        },\n        \"current\": {\n          \"min\": 0,\n          \"max\": 1\n        }\n      },\n      3: {\n        \"voltage\": {\n          \"min\": 0,\n          \"max\": 30\n        },\n        \"current\": {\n          \"min\": 0,\n          \"max\": 1  \n        }\n      }\n    },\n    \n    \"total_power\": 90, \n    \"line_regulation\": 0.01, \n    \"load_regulation\": 0.2,\n    \"programming_accuracy\": {\n      \"voltage\": 0.05,\n      \"current\": 0.2  \n    },\n    \n    \"readback_accuracy\": {\n      \"voltage\": 0.05,\n      \"current\": 0.2\n    },\n    \n    \"interfaces\": [\"USB\", \"LAN\"],\n    \"remote_control\": [\"SCPI\", \"IVI\", \"Web Browser\"]\n  }\n}\n\nawg_profile = {\n  \"EDU33212A\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"EDU33212A\", \n    \"vendor_id\": 0x2a8d,\n    \"product_id\": 0x8d01,\n    \"device_type\": \"Arbitrary Waveform Generator\",\n    \n    \"channels\": {\n        1: {\n        \"description\": \"Channel 1\",\n        },\n        2: {\n        \"description\": \"Channel 2\",\n        },\n    },\n    \"max_frequency\": 20e6, \n    \n    \"waveforms\": {\n      \"standard\": [\"sine\", \"square\", \"ramp\", \"pulse\", \"triangle\", \"noise\", \"PRBS\", \"DC\"],\n      \"built-in\": [\"cardiac\", \"exponential_fall\", \"exponential_rise\", \"gaussian_pulse\", \n                  \"haversine\", \"lorentz\", \"dlorentz\", \"negative_ramp\", \"sinc\"],\n      \"arbitrary\": {\n        \"memory\": 8e6, \n        \"max_length\": 1e6,\n        \"sampling_rate\": {\n          \"min\": 1e-6,\n          \"max\": 250e6\n        },\n        \"resolution\": 16\n      }\n    },\n    \n    \"modulation_types\": [\"AM\", \"FM\", \"PM\", \"FSK\", \"BPSK\", \"PWM\"],\n    \n    \"amplitude\": {\n      \"min\": 1e-3,\n      \"max\": 10\n    },\n    \n    \"dc_offset\": {\n      \"min\": -5,\n      \"max\": 5  \n    },\n\n    \"accuracy\": {\n      \"amplitude\": 0.02, \n      \"frequency\": 1e-6\n    },\n    \n    \"interfaces\": [\"USB\", \"LAN\"], \n    \"remote_control\": [\"SCPI\", \"IVI\", \"Web Browser\"]\n  }\n}\n\nmultimeter_profile = {\n    \"EDU34450A\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"EDU34450A\",\n    \"vendor_id\": 0x2a8d,\n    \"product_id\": 0x8e01,\n    \"device_type\": \"multimeter\",\n\n    \"channels\": 1,\n    \"resolution\": 5.5,\n    \"max_voltage\": 1000,\n    \"max_current\": 10,\n    \"max_resistance\": 100e6,\n    \"max_capacitance\": 10e-6,\n    \"max_frequency\": 1e6,\n    }\n  }"
}