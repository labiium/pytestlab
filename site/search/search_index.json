{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"A modern, async-first Python toolbox for laboratory test-and-measurement automation, data analysis, and management. <ul> <li> <p>:material-flash:{ .lg .middle } Async by Design</p> <p>Harness the power of Python's <code>async/await</code> for non-blocking instrument I/O, enabling concurrent operations and responsive applications.</p> <p>:octicons-arrow-right-24: Learn about Async</p> </li> <li> <p>:material-tools:{ .lg .middle } Unified Driver Layer</p> <p>A consistent, high-level API for oscilloscopes, PSUs, DMMs, VNAs, AWGs, and more, simplifying instrument control.</p> <p>:octicons-arrow-right-24: Browse Instruments</p> </li> <li> <p>:material-play:{ .lg .middle } Simulation Mode</p> <p>Develop and test anywhere using the built-in YAML-driven simulation backend. No hardware required.</p> <p>:octicons-arrow-right-24: Explore Simulation</p> </li> <li> <p>:material-file-document-outline:{ .lg .middle } Declarative Benches</p> <p>Define and manage your entire test setup, including safety limits and automation hooks, in a single <code>bench.yaml</code> file.</p> <p>:octicons-arrow-right-24: Master Benches</p> </li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#installation","title":"Installation","text":"CoreFullWith NI-VISA <pre><code>pip install pytestlab\n</code></pre> <pre><code>pip install pytestlab[full]  # includes plotting, uncertainties, etc.\n</code></pre> <pre><code># Install NI-VISA or Keysight IO Libraries first\npip install -U pyvisa\n</code></pre>"},{"location":"#hello-simulated-oscilloscope","title":"Hello, Simulated Oscilloscope!","text":"<p>Here's a quick look at PyTestLab's intuitive, asynchronous API.</p> Simulated Scope Example<pre><code>import asyncio\nfrom pytestlab.instruments import AutoInstrument\n\nasync def main():\n    # Load a simulated oscilloscope using its profile key\n    # `simulate=True` uses the powerful SimBackendV2\n    scope = await AutoInstrument.from_config(\"keysight/DSOX1204G\", simulate=True)\n    await scope.connect_backend()\n\n    # Configure channels and trigger using a fluent, chainable API\n    await scope.channel(1).setup(scale=0.5, offset=0).enable()\n    await scope.trigger.setup_edge(source=\"CH1\", level=0.25)\n\n    # Acquire and print waveform data\n    result = await scope.read_channels(1)  # Returns a MeasurementResult\n    print(\"Acquired waveform data:\")\n    print(result.values.head()) # .values is a Polars DataFrame\n\n    await scope.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#dive-in","title":"\ud83d\udcda Dive In","text":"<ul> <li>New to PyTestLab? Start with our 10-minute tour</li> <li>Setting up instruments? Check the connection guide</li> <li>Need specific instruments? Browse the profile gallery</li> <li>Want to contribute? See our contributing guide</li> </ul> <p>Pro Tip</p> <p>Use <code>pytestlab list-profiles</code> in your terminal to see all available instrument profiles!</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial migration to new documentation structure under <code>docs/en/</code>.</li> <li>Enhanced theme and navigation for multilingual and modern Material for MkDocs features.</li> <li>Improved simulation backend documentation and CLI reference.</li> <li>New API reference structure with detailed Pydantic model documentation.</li> <li>Bench descriptor and safety limit documentation improvements.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Home page and quick start rewritten for clarity and modern async-first focus.</li> <li>Installation instructions updated for clarity and VISA backend support.</li> <li>User guide reorganized for better onboarding and discoverability.</li> <li>Custom styles simplified for new theme.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Navigation bugs and broken links in documentation.</li> <li>Outdated references to old profile and bench formats.</li> </ul>"},{"location":"changelog/#015-2024-06-01","title":"0.1.5 - 2024-06-01","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for YAML-driven simulation backend (SimBackendV2).</li> <li>Bench safety limits and automation hooks.</li> <li>CLI commands for profile and bench management.</li> <li>Initial support for uncertainty propagation using <code>uncertainties</code> package.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Async-first instrument API with facade pattern.</li> <li>Improved error handling and custom exception types.</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Various bugs in instrument connection and simulation logic.</li> </ul>"},{"location":"changelog/#010-2024-04-15","title":"0.1.0 - 2024-04-15","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>First public release of PyTestLab.</li> <li>Core instrument drivers: Oscilloscope, PowerSupply, Multimeter, WaveformGenerator, DCActiveLoad.</li> <li>Profile-based configuration system.</li> <li>Database and experiment management modules.</li> <li>Basic simulation backend.</li> </ul>"},{"location":"contributing/","title":"Contributing to PyTestLab","text":"<p>Thank you for your interest in contributing to PyTestLab! Your help makes this project better for everyone in the scientific and engineering community.</p> <p>This guide explains how to get started, the development workflow, and best practices for contributing code, documentation, and ideas.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors are expected to follow the PyTestLab Code of Conduct. Please help us keep the community welcoming and inclusive.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li>Fork the repository on GitHub.</li> <li>Clone your fork locally:     <pre><code>git clone https://github.com/YOUR_USERNAME/pytestlab.git\ncd pytestlab\n</code></pre></li> <li>Set up a virtual environment (recommended):     <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre></li> <li>Install dependencies (including development tools):     <pre><code>pip install -e .[dev,full]\n</code></pre></li> <li>Install pre-commit hooks (for linting and formatting):     <pre><code>pre-commit install\n</code></pre></li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ul> <li>Create a feature branch for your work:     <pre><code>git checkout -b feat/short-description\n</code></pre></li> <li>Make your changes (code, docs, or tests).</li> <li>Add or update tests to cover your changes.</li> <li>Run the test suite:     <pre><code>pytest\n</code></pre></li> <li>Run pre-commit checks (these will also run automatically on commit):     <pre><code>pre-commit run --all-files\n</code></pre></li> <li>Commit using Conventional Commits (enforced by commitizen):     <pre><code>cz c\n</code></pre></li> <li>Push your branch to your fork:     <pre><code>git push origin feat/short-description\n</code></pre></li> <li>Open a Pull Request against the <code>main</code> branch on GitHub.</li> </ul>"},{"location":"contributing/#code-style-quality","title":"Code Style &amp; Quality","text":"<ul> <li>Linting &amp; Formatting: PyTestLab uses Ruff for linting and formatting, and Black for code style. These are enforced by pre-commit.</li> <li>Type Checking: Use MyPy for static type checking.</li> <li>Commit Messages: Follow the Conventional Commits specification. Use <code>cz c</code> to help format your commit messages.</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Docs live in <code>docs/</code> and are written in Markdown or Jupyter Notebooks.</li> <li>API docs are generated using mkdocstrings.</li> <li>To preview docs locally: <pre><code>mkdocs serve\n</code></pre></li> <li>Update or add docstrings to your code as needed.</li> </ul>"},{"location":"contributing/#tests","title":"Tests","text":"<ul> <li>Unit tests live in the <code>tests/</code> directory.</li> <li>All new features and bugfixes must include tests.</li> <li>Run the full test suite before submitting a PR.</li> </ul>"},{"location":"contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ul> <li>Ensure your branch is up to date with <code>main</code>.</li> <li>Provide a clear title and description for your PR.</li> <li>Link to any relevant issues.</li> <li>Be responsive to code review feedback.</li> </ul>"},{"location":"contributing/#need-help","title":"Need Help?","text":"<ul> <li>Bugs &amp; Feature Requests: Open an issue on GitHub.</li> <li>Questions: Use GitHub Discussions or reach out via the project chat (see the README for links).</li> <li>Security Issues: Please report security vulnerabilities privately to the maintainers.</li> </ul> <p>Thank you for helping make PyTestLab better!</p>"},{"location":"installation/","title":"Installation","text":"<p>PyTestLab requires Python 3.9 or higher.</p>"},{"location":"installation/#standard-installation","title":"Standard Installation","text":"<p>We recommend installing PyTestLab in a virtual environment.</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre> <p>You can install PyTestLab from PyPI using <code>pip</code>.</p>"},{"location":"installation/#core-package","title":"Core Package","text":"<p>For the core functionality:</p> <pre><code>pip install pytestlab\n</code></pre>"},{"location":"installation/#full-installation","title":"Full Installation","text":"<p>To include all optional dependencies for plotting, extended data formats, and development tools:</p> <pre><code>pip install pytestlab[full]\n</code></pre>"},{"location":"installation/#visa-backend-support","title":"VISA Backend Support","text":"<p>To communicate with most physical instruments, you will need to install a VISA backend library. PyTestLab uses <code>pyvisa</code> to interface with these libraries.</p> <ol> <li> <p>Install a VISA implementation from your hardware vendor:</p> <ul> <li>National Instruments NI-VISA</li> <li>Keysight IO Libraries Suite</li> <li>Rohde &amp; Schwarz VISA</li> </ul> </li> <li> <p>Install <code>pyvisa</code>:</p> <pre><code>pip install pyvisa\n</code></pre> </li> </ol> <p>PyTestLab will automatically detect and use the installed VISA backend.</p>"},{"location":"installation/#upgrading","title":"Upgrading","text":"<p>To upgrade PyTestLab to the latest version:</p> <pre><code>pip install --upgrade pytestlab\n</code></pre>"},{"location":"installation/#verifying-your-installation","title":"Verifying Your Installation","text":"<p>After installation, you can verify that PyTestLab is installed and working:</p> <pre><code>pytestlab --version\npytestlab profile list\n</code></pre> <p>If you see a list of available instrument profiles, your installation is successful.</p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If you encounter issues with instrument connectivity, ensure your VISA library is installed and accessible in your system's PATH.</li> <li>For simulation-only development, you do not need to install any VISA libraries.</li> </ul>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide</li> <li>Async vs. Sync Programming</li> <li>Connecting to Instruments</li> </ul>"},{"location":"api/backends/","title":"Instrument Backends","text":"<p>PyTestLab supports multiple instrument communication backends, each designed for a specific class of hardware or simulation use case. This page documents the main backend classes and their roles.</p>"},{"location":"api/backends/#overview","title":"Overview","text":"<p>A backend is the low-level driver responsible for communicating with an instrument. Backends abstract the transport mechanism (VISA, Lamb, simulation, etc.) so that high-level instrument drivers can use a unified API.</p> <p>Backends are typically not used directly by end-users. Instead, they are selected automatically based on your instrument profile, connection string, and simulation settings.</p>"},{"location":"api/backends/#available-backends","title":"Available Backends","text":""},{"location":"api/backends/#asyncvisabackend","title":"<code>AsyncVisaBackend</code>","text":"<p>Asynchronous backend for VISA-compatible instruments (e.g., GPIB, USB, TCPIP, RS232). Uses PyVISA under the hood.</p>"},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend","title":"<code>pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend(address, timeout_ms=5000)</code>","text":"<p>An asynchronous backend for communicating with instruments using pyvisa, by running blocking calls in a separate thread via anyio. This class implements the AsyncInstrumentIO protocol.</p> Source code in <code>pytestlab/instruments/backends/async_visa_backend.py</code> <pre><code>def __init__(self, address: str, timeout_ms: Optional[int] = 5000):\n    self.address = address\n    self.rm = pyvisa.ResourceManager()\n    self.instrument: Optional[MessageBasedResource] = None\n    self._timeout_ms = timeout_ms if timeout_ms is not None else 5000 # Default to 5 seconds\n    self._lock = anyio.Lock() # For thread-safety around instrument access\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend-attributes","title":"Attributes","text":""},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.address","title":"<code>address = address</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.instrument","title":"<code>instrument = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.rm","title":"<code>rm = pyvisa.ResourceManager()</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend-functions","title":"Functions","text":""},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Closes the connection asynchronously (alias for disconnect).</p> Source code in <code>pytestlab/instruments/backends/async_visa_backend.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Closes the connection asynchronously (alias for disconnect).\"\"\"\n    await self.disconnect()\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Connects to the VISA resource asynchronously.</p> Source code in <code>pytestlab/instruments/backends/async_visa_backend.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"Connects to the VISA resource asynchronously.\"\"\"\n    async with self._lock:\n        if self.instrument is not None:\n            try:\n                # Ensure existing instrument is closed before reconnecting\n                await anyio.to_thread.run_sync(self.instrument.close)\n            except Exception:\n                # Ignore errors if already closed or in a bad state\n                pass\n            self.instrument = None\n\n        try:\n            # Run the blocking open_resource call in a thread\n            resource = await anyio.to_thread.run_sync(self.rm.open_resource, self.address)\n            if not isinstance(resource, pyvisa.resources.MessageBasedResource):\n                raise InstrumentConnectionError(\n                    f\"Resource at {self.address} is not a MessageBasedResource. Type: {type(resource).__name__}\"\n                )\n            self.instrument = cast('MessageBasedResource', resource) # Cast for type checker\n\n            # Set timeout on the instrument object\n            def _set_timeout_on_instrument(instr: MessageBasedResource, timeout: int) -&gt; None:\n                instr.timeout = timeout\n            await anyio.to_thread.run_sync(_set_timeout_on_instrument, self.instrument, self._timeout_ms)\n\n        except pyvisa.Error as e:\n            raise InstrumentConnectionError(f\"Failed to connect to VISA resource {self.address}: {e}\") from e\n        except Exception as e:\n            raise InstrumentConnectionError(f\"An unexpected error occurred while connecting to VISA resource {self.address}: {e}\") from e\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Disconnects from the VISA resource asynchronously.</p> Source code in <code>pytestlab/instruments/backends/async_visa_backend.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"\"\"Disconnects from the VISA resource asynchronously.\"\"\"\n    async with self._lock:\n        if self.instrument is not None:\n            try:\n                await anyio.to_thread.run_sync(self.instrument.close)\n            except pyvisa.Error as e:\n                raise InstrumentConnectionError(f\"Error disconnecting from VISA resource {self.address}: {e}\") from e\n            except Exception as e:\n                raise InstrumentConnectionError(f\"An unexpected error occurred while disconnecting VISA resource {self.address}: {e}\") from e\n            finally:\n                self.instrument = None\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.get_timeout","title":"<code>get_timeout()</code>  <code>async</code>","text":"<p>Gets the communication timeout in milliseconds.</p> Source code in <code>pytestlab/instruments/backends/async_visa_backend.py</code> <pre><code>async def get_timeout(self) -&gt; int:\n    \"\"\"Gets the communication timeout in milliseconds.\"\"\"\n    # Return the locally stored timeout. Reading from instrument is not always reliable\n    # and the local value is the intended setting.\n    return self._timeout_ms\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.query","title":"<code>query(cmd, delay=None)</code>  <code>async</code>","text":"<p>Sends a query and returns the string response asynchronously.</p> Source code in <code>pytestlab/instruments/backends/async_visa_backend.py</code> <pre><code>async def query(self, cmd: str, delay: Optional[float] = None) -&gt; str:\n    \"\"\"Sends a query and returns the string response asynchronously.\"\"\"\n    if self.instrument is None:\n        raise InstrumentConnectionError(\"Not connected to VISA resource. Call connect() first.\")\n\n    instr = self.instrument # Local reference\n    def _blocking_query(command: str, q_delay: Optional[float]) -&gt; str:\n        return instr.query(command, delay=q_delay).strip()\n\n    async with self._lock:\n        if self.instrument is None:\n             raise InstrumentConnectionError(\"Instrument became disconnected before query.\")\n        try:\n            response = await anyio.to_thread.run_sync(_blocking_query, cmd, delay)\n            return response\n        except pyvisa.Error as e:\n            raise InstrumentCommunicationError(f\"Failed to query '{cmd}' from {self.address}: {e}\") from e\n        except Exception as e:\n            raise InstrumentCommunicationError(f\"An unexpected error occurred querying '{cmd}' from {self.address}: {e}\") from e\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.query_raw","title":"<code>query_raw(cmd, delay=None)</code>  <code>async</code>","text":"<p>Sends a query and returns the raw bytes response asynchronously.</p> Source code in <code>pytestlab/instruments/backends/async_visa_backend.py</code> <pre><code>async def query_raw(self, cmd: str, delay: Optional[float] = None) -&gt; bytes:\n    \"\"\"Sends a query and returns the raw bytes response asynchronously.\"\"\"\n    if self.instrument is None:\n        raise InstrumentConnectionError(\"Not connected to VISA resource. Call connect() first.\")\n\n    instr = self.instrument # Local reference\n    def _blocking_query_raw(command: str, q_delay: Optional[float]) -&gt; bytes:\n        instr.write(command) # Write the command\n        if q_delay is not None:\n            time.sleep(q_delay) # Blocking sleep in the thread\n        # Assuming read_bytes is the appropriate method for raw data.\n        # Adjust chunk_size or method (e.g. read_raw()) as needed.\n        return instr.read_bytes(instr.chunk_size) \n\n    async with self._lock:\n        if self.instrument is None:\n             raise InstrumentConnectionError(\"Instrument became disconnected before query_raw.\")\n        try:\n            data = await anyio.to_thread.run_sync(_blocking_query_raw, cmd, delay)\n            return data\n        except pyvisa.Error as e:\n            raise InstrumentCommunicationError(f\"Failed to query_raw '{cmd}' from {self.address}: {e}\") from e\n        except Exception as e:\n            raise InstrumentCommunicationError(f\"An unexpected error occurred during query_raw '{cmd}' from {self.address}: {e}\") from e\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.set_timeout","title":"<code>set_timeout(timeout_ms)</code>  <code>async</code>","text":"<p>Sets the communication timeout in milliseconds asynchronously.</p> Source code in <code>pytestlab/instruments/backends/async_visa_backend.py</code> <pre><code>async def set_timeout(self, timeout_ms: int) -&gt; None:\n    \"\"\"Sets the communication timeout in milliseconds asynchronously.\"\"\"\n    if timeout_ms &lt;= 0:\n        raise ValueError(\"Timeout must be positive.\")\n\n    self._timeout_ms = timeout_ms # Update local store immediately\n\n    if self.instrument:\n        instr = self.instrument # Local reference\n        def _blocking_set_timeout(timeout_val: int) -&gt; None:\n            instr.timeout = timeout_val\n\n        async with self._lock: # Ensure instrument object isn't changed during this\n            if self.instrument: # Re-check after lock\n                try:\n                    await anyio.to_thread.run_sync(_blocking_set_timeout, timeout_ms)\n                except pyvisa.Error as e:\n                    # Log this, but don't necessarily fail the operation.\n                    print(f\"Warning: Could not set timeout on async VISA resource {self.address}: {e}\")\n                except Exception as e:\n                    print(f\"Warning: An unexpected error occurred setting timeout on async VISA resource {self.address}: {e}\")\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.async_visa_backend.AsyncVisaBackend.write","title":"<code>write(cmd)</code>  <code>async</code>","text":"<p>Writes a command to the instrument asynchronously.</p> Source code in <code>pytestlab/instruments/backends/async_visa_backend.py</code> <pre><code>async def write(self, cmd: str) -&gt; None:\n    \"\"\"Writes a command to the instrument asynchronously.\"\"\"\n    if self.instrument is None:\n        raise InstrumentConnectionError(\"Not connected to VISA resource. Call connect() first.\")\n\n    instr = self.instrument # Local reference for thread safety\n    def _blocking_write(command: str) -&gt; None:\n        instr.write(command)\n\n    async with self._lock: # Ensure exclusive access for the write operation\n        if self.instrument is None: # Re-check after acquiring lock\n             raise InstrumentConnectionError(\"Instrument became disconnected before write.\")\n        try:\n            await anyio.to_thread.run_sync(_blocking_write, cmd)\n        except pyvisa.Error as e:\n            raise InstrumentCommunicationError(f\"Failed to write command '{cmd}' to {self.address}: {e}\") from e\n        except Exception as e:\n            raise InstrumentCommunicationError(f\"An unexpected error occurred writing command '{cmd}' to {self.address}: {e}\") from e\n</code></pre>"},{"location":"api/backends/#asynclambbackend","title":"<code>AsyncLambBackend</code>","text":"<p>Backend for instruments accessible via the Lamb remote instrument server protocol. Supports async TCP communication with Lamb daemons.</p>"},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend","title":"<code>pytestlab.instruments.backends.lamb.AsyncLambBackend(address=None, url='http://lamb-server:8000', timeout_ms=10000, model_name=None, serial_number=None)</code>","text":"<p>An asynchronous backend for communicating with instruments via a Lamb server. Supports both direct visa_string and auto-connect via model/serial_number.</p> PARAMETER DESCRIPTION <code>address</code> <p>The visa_string or unique instrument address. If not provided, model_name and serial_number must be provided.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>url</code> <p>Lamb server base URL.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://lamb-server:8000'</code> </p> <code>timeout_ms</code> <p>Communication timeout in ms.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>10000</code> </p> <code>model_name</code> <p>Model name for auto-connect.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>serial_number</code> <p>Serial number for auto-connect.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>pytestlab/instruments/backends/lamb.py</code> <pre><code>def __init__(\n    self,\n    address: Optional[str] = None,\n    url: str = \"http://lamb-server:8000\",\n    timeout_ms: Optional[int] = 10000,\n    model_name: Optional[str] = None,\n    serial_number: Optional[str] = None,\n):\n    \"\"\"\n    Args:\n        address: The visa_string or unique instrument address. If not provided, model_name and serial_number must be provided.\n        url: Lamb server base URL.\n        timeout_ms: Communication timeout in ms.\n        model_name: Model name for auto-connect.\n        serial_number: Serial number for auto-connect.\n    \"\"\"\n    self.base_url: str = url.rstrip('/')\n    self.instrument_address: Optional[str] = address  # visa_string\n    self.model_name: Optional[str] = model_name\n    self.serial_number: Optional[str] = serial_number\n    self._timeout_sec: float = (timeout_ms / 1000.0) if timeout_ms and timeout_ms &gt; 0 else 5.0\n    self._client: Optional[httpx.AsyncClient] = None\n    self._auto_connect_performed: bool = False\n\n    lamb_logger.info(\n        f\"AsyncLambBackend initialized for address='{address}', model='{model_name}', serial='{serial_number}' at URL '{url}'\"\n    )\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend-attributes","title":"Attributes","text":""},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.base_url","title":"<code>base_url = url.rstrip('/')</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.instrument_address","title":"<code>instrument_address = address</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.model_name","title":"<code>model_name = model_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.serial_number","title":"<code>serial_number = serial_number</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend-functions","title":"Functions","text":""},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.close","title":"<code>close()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/lamb.py</code> <pre><code>async def close(self) -&gt; None:\n    await self.disconnect()\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Ensures the instrument is registered with Lamb and ready.</p> Source code in <code>pytestlab/instruments/backends/lamb.py</code> <pre><code>async def connect(self) -&gt; None:\n    \"\"\"\n    Ensures the instrument is registered with Lamb and ready.\n    \"\"\"\n    await self._ensure_connected()\n    # Optionally, ping instrument status endpoint here\n    lamb_logger.info(f\"Connected to Lamb instrument '{self.instrument_address}'.\")\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/lamb.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    lamb_logger.info(f\"AsyncLambBackend for '{self.instrument_address}' disconnected (simulated, as client is per-request or context-managed).\")\n    pass\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.get_timeout","title":"<code>get_timeout()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/lamb.py</code> <pre><code>async def get_timeout(self) -&gt; int:\n    return int(self._timeout_sec * 1000)\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.query","title":"<code>query(cmd, delay=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/lamb.py</code> <pre><code>async def query(self, cmd: str, delay: Optional[float] = None) -&gt; str:\n    await self._ensure_connected()\n    lamb_logger.debug(f\"QUERY to '{self.instrument_address}': {cmd}\")\n    try:\n        async with httpx.AsyncClient(timeout=self._timeout_sec) as client:\n            response = await client.post(\n                f\"{self.base_url}/instrument/query\",\n                json={\"visa_string\": self.instrument_address, \"command\": cmd},\n                headers={\"Accept\": \"application/json\", 'Accept-Charset': 'utf-8'}\n            )\n            response.raise_for_status()\n            content: str = response.content.decode('utf-8')\n            return content.strip()\n    except httpx.HTTPStatusError as e:\n        raise InstrumentCommunicationError(\n            f\"Lamb server query failed: {e.response.status_code} - {e.response.text}\"\n        ) from e\n    except httpx.RequestError as e:\n        raise InstrumentCommunicationError(\n            f\"Network error during Lamb query: {e}\"\n        ) from e\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.query_raw","title":"<code>query_raw(cmd, delay=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/lamb.py</code> <pre><code>async def query_raw(self, cmd: str, delay: Optional[float] = None) -&gt; bytes:\n    await self._ensure_connected()\n    lamb_logger.debug(f\"QUERY_RAW to '{self.instrument_address}': {cmd}\")\n    try:\n        async with httpx.AsyncClient(timeout=self._timeout_sec) as client:\n            response = await client.post(\n                f\"{self.base_url}/instrument/query_raw\",\n                json={\"visa_string\": self.instrument_address, \"command\": cmd},\n                headers={\"Accept\": \"application/octet-stream\"}\n            )\n            response.raise_for_status()\n            return response.content\n    except httpx.HTTPStatusError as e:\n        raise InstrumentCommunicationError(\n            f\"Lamb server query_raw failed: {e.response.status_code} - {e.response.text}\"\n        ) from e\n    except httpx.RequestError as e:\n        raise InstrumentCommunicationError(\n            f\"Network error during Lamb query_raw: {e}\"\n        ) from e\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.set_timeout","title":"<code>set_timeout(timeout_ms)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/lamb.py</code> <pre><code>async def set_timeout(self, timeout_ms: int) -&gt; None:\n    if timeout_ms &lt;= 0:\n        self._timeout_sec = 0.001\n    else:\n        self._timeout_sec = timeout_ms / 1000.0\n    lamb_logger.debug(f\"AsyncLambBackend timeout set to {self._timeout_sec} seconds.\")\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.lamb.AsyncLambBackend.write","title":"<code>write(cmd)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/lamb.py</code> <pre><code>async def write(self, cmd: str) -&gt; None:\n    await self._ensure_connected()\n    lamb_logger.debug(f\"WRITE to '{self.instrument_address}': {cmd}\")\n    try:\n        async with httpx.AsyncClient(timeout=self._timeout_sec) as client:\n            response = await client.post(\n                f\"{self.base_url}/instrument/write\",\n                json={\"visa_string\": self.instrument_address, \"command\": cmd},\n                headers={\"Accept\": \"application/json\", 'Accept-Charset': 'utf-8'}\n            )\n            response.raise_for_status()\n    except httpx.HTTPStatusError as e:\n        raise InstrumentCommunicationError(\n            f\"Lamb server write failed: {e.response.status_code} - {e.response.text}\"\n        ) from e\n    except httpx.RequestError as e:\n        raise InstrumentCommunicationError(\n            f\"Network error during Lamb write: {e}\"\n        ) from e\n</code></pre>"},{"location":"api/backends/#simbackendv2","title":"<code>SimBackendV2</code>","text":"<p>YAML-driven simulation backend. Provides deterministic, profile-based simulation for development, CI, and testing. Reads the <code>simulation</code> section of instrument profiles.</p>"},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2","title":"<code>pytestlab.instruments.backends.sim_backend_v2.SimBackendV2(profile_path, *, model=None, timeout_ms=None)</code>","text":"<p>Drop-in replacement for the existing SimBackend with vastly richer functionality (see module docstring for highlights).</p> Source code in <code>pytestlab/instruments/backends/sim_backend_v2.py</code> <pre><code>def __init__(\n    self,\n    profile_path: str | os.PathLike,\n    *,\n    model: str | None = None,\n    timeout_ms: int | None = None,\n) -&gt; None:\n    self.profile_path = Path(profile_path)\n    self.timeout_ms = timeout_ms or self.DEFAULT_TIMEOUT_MS\n    self.model = model or self.profile_path.stem\n    # main data\n    self._profile = self._load_profile()\n    self._state: dotdict = dotdict(self._profile[\"simulation\"].get(\"initial_state\", {}))\n    self._error_queue: List[Tuple[int, str]] = []\n    # dispatcher\n    self._exact_map: Dict[str, Any] = {}\n    self._pattern_rules: List[_PatternRule] = []\n    self._build_dispatch_tables()\n    logger.info(\"SimBackendV2 initialised for %s\", self.model)\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2-attributes","title":"Attributes","text":""},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.DEFAULT_TIMEOUT_MS","title":"<code>DEFAULT_TIMEOUT_MS = 5000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.USER_OVERRIDE_ROOT","title":"<code>USER_OVERRIDE_ROOT = Path.home() / '.pytestlab' / 'sim_profiles'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.model","title":"<code>model = model or self.profile_path.stem</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.profile_path","title":"<code>profile_path = Path(profile_path)</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.timeout_ms","title":"<code>timeout_ms = timeout_ms or self.DEFAULT_TIMEOUT_MS</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2-functions","title":"Functions","text":""},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.close","title":"<code>close()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/sim_backend_v2.py</code> <pre><code>async def close(self) -&gt; None:\n    await self.disconnect()\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.connect","title":"<code>connect()</code>  <code>async</code>","text":"<p>Establish connection (no-op in simulation).</p> Source code in <code>pytestlab/instruments/backends/sim_backend_v2.py</code> <pre><code>async def connect(self) -&gt; None:  # noqa: D401\n    \"Establish connection (no-op in simulation).\"\n    logger.debug(\"%s: connect()\", self.model)\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Close connection (no-op).</p> Source code in <code>pytestlab/instruments/backends/sim_backend_v2.py</code> <pre><code>async def disconnect(self) -&gt; None:\n    \"Close connection (no-op).\"\n    logger.debug(\"%s: disconnect()\", self.model)\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.get_timeout","title":"<code>get_timeout()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/sim_backend_v2.py</code> <pre><code>async def get_timeout(self) -&gt; int:\n    return self.timeout_ms\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.query","title":"<code>query(cmd, delay=None)</code>  <code>async</code>","text":"<p>Handle a SCPI query and return a decoded string.</p> Source code in <code>pytestlab/instruments/backends/sim_backend_v2.py</code> <pre><code>async def query(self, cmd: str, delay: float | None = None) -&gt; str:\n    \"Handle a SCPI query and return a **decoded** string.\"\n    if delay:\n        await asyncio.sleep(delay)\n    response = self._handle_command(cmd, expect_response=True)\n    logger.debug(\"%s QUERY \u2039%s\u203a \u2192 %s\", self.model, cmd.strip(), response)\n    return response\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.query_raw","title":"<code>query_raw(cmd, delay=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/sim_backend_v2.py</code> <pre><code>async def query_raw(self, cmd: str, delay: float | None = None) -&gt; bytes:\n    resp = await self.query(cmd, delay)\n    if isinstance(resp, bytes):\n        return resp\n    return resp.encode()\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.set_timeout","title":"<code>set_timeout(timeout_ms)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/backends/sim_backend_v2.py</code> <pre><code>async def set_timeout(self, timeout_ms: int) -&gt; None:\n    self.timeout_ms = timeout_ms\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.sim_backend_v2.SimBackendV2.write","title":"<code>write(cmd)</code>  <code>async</code>","text":"<p>Handle a SCPI write.</p> Source code in <code>pytestlab/instruments/backends/sim_backend_v2.py</code> <pre><code>async def write(self, cmd: str) -&gt; None:\n    \"Handle a SCPI write.\"\n    logger.debug(\"%s WRITE \u2039%s\u203a\", self.model, cmd.strip())\n    self._handle_command(cmd)\n</code></pre>"},{"location":"api/backends/#recordingbackend","title":"<code>RecordingBackend</code>","text":"<p>A backend that wraps another backend and records all SCPI commands and responses. Used for generating simulation profiles and debugging.</p>"},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend","title":"<code>pytestlab.instruments.backends.recording_backend.RecordingBackend(backend, output_path=None, base_profile=None)</code>","text":"<p>A backend that records interactions to a simulation profile.</p> Source code in <code>pytestlab/instruments/backends/recording_backend.py</code> <pre><code>def __init__(self, backend, output_path=None, base_profile=None):\n    self.backend = backend\n    self.output_path = output_path\n    self.base_profile = base_profile if base_profile is not None else {}\n    self.log = []\n    self.start_time = time.monotonic()\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend-attributes","title":"Attributes","text":""},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.backend","title":"<code>backend = backend</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.base_profile","title":"<code>base_profile = base_profile if base_profile is not None else {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.log","title":"<code>log = []</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.output_path","title":"<code>output_path = output_path</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.start_time","title":"<code>start_time = time.monotonic()</code>  <code>instance-attribute</code>","text":""},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend-functions","title":"Functions","text":""},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Delegate other attributes to the wrapped backend.</p> Source code in <code>pytestlab/instruments/backends/recording_backend.py</code> <pre><code>def __getattr__(self, name):\n    \"\"\"Delegate other attributes to the wrapped backend.\"\"\"\n    return getattr(self.backend, name)\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the backend and write the simulation profile.</p> Source code in <code>pytestlab/instruments/backends/recording_backend.py</code> <pre><code>async def close(self):\n    \"\"\"Close the backend and write the simulation profile.\"\"\"\n    if hasattr(self.backend, 'close') and callable(getattr(self.backend, 'close')):\n        result = self.backend.close()\n        if asyncio.iscoroutine(result):\n            await result\n    print(\"DEBUG: Calling generate_profile from RecordingBackend.close()\")\n    self.generate_profile()\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.generate_profile","title":"<code>generate_profile()</code>","text":"<p>Generate the YAML simulation profile from the log.</p> Source code in <code>pytestlab/instruments/backends/recording_backend.py</code> <pre><code>def generate_profile(self):\n    \"\"\"Generate the YAML simulation profile from the log.\"\"\"\n    print(f\"DEBUG: generate_profile called. Output path: {self.output_path}\")\n    scpi_map = {}\n    for entry in self.log:\n        if entry[\"type\"] == \"query\":\n            scpi_map[entry[\"command\"]] = entry[\"response\"]\n        elif entry[\"type\"] == \"query_raw\":\n            command_slug = re.sub(r\"[^a-zA-Z0-9]\", \"_\", entry[\"command\"])\n            binary_filename = f\"{command_slug}.bin\"\n            binary_filepath = Path(self.output_path).parent / binary_filename\n            with open(binary_filepath, \"wb\") as f:\n                f.write(entry[\"response\"])\n            scpi_map[entry[\"command\"]] = {\"binary\": binary_filename}\n        elif entry[\"type\"] == \"write\":\n            # For writes, we record the command with an empty response,\n            # which is suitable for commands that don't return a value.\n            scpi_map[entry[\"command\"]] = \"\"\n\n    profile = self.base_profile\n    if \"simulation\" not in profile:\n        profile[\"simulation\"] = {}\n    profile[\"simulation\"][\"scpi\"] = scpi_map\n    print(f\"DEBUG: Profile data to be written: {profile}\")\n    if self.output_path:\n        try:\n            output_file = Path(self.output_path)\n            print(f\"DEBUG: Creating parent directory for {output_file}\")\n            output_file.parent.mkdir(parents=True, exist_ok=True)\n            print(f\"DEBUG: Writing to file {output_file}\")\n            with open(output_file, \"w\") as f:\n                yaml.dump(profile, f, sort_keys=False)\n            print(\"DEBUG: File write complete.\")\n            LOGGER.info(f\"Simulation profile saved to {self.output_path}\")\n        except Exception as e:\n            print(f\"DEBUG: ERROR in generate_profile: {e}\")\n    else:\n        # In a real scenario, this would go to a user cache directory.\n        # For now, let's just print it if no path is provided.\n        print(\"DEBUG: No output path provided. Printing to stdout.\")\n        print(yaml.dump(profile, sort_keys=False))\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.query","title":"<code>query(command, *args, **kwargs)</code>  <code>async</code>","text":"<p>Async query to the instrument, log it, and return the response.</p> Source code in <code>pytestlab/instruments/backends/recording_backend.py</code> <pre><code>async def query(self, command: str, *args, **kwargs):\n    \"\"\"Async query to the instrument, log it, and return the response.\"\"\"\n    if hasattr(self.backend, 'query') and callable(getattr(self.backend, 'query')):\n        result = self.backend.query(command, *args, **kwargs)\n        if asyncio.iscoroutine(result):\n            response = await result\n        else:\n            response = result\n        self.log.append({\n            \"type\": \"query\",\n            \"command\": command.strip(),\n            \"response\": getattr(response, 'strip', lambda: response)()\n        })\n        return response\n    raise NotImplementedError(\"Backend does not support query method.\")\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.query_raw","title":"<code>query_raw(command, *args, **kwargs)</code>  <code>async</code>","text":"<p>Async query to the instrument, log it, and return the response.</p> Source code in <code>pytestlab/instruments/backends/recording_backend.py</code> <pre><code>async def query_raw(self, command: str, *args, **kwargs):\n    \"\"\"Async query to the instrument, log it, and return the response.\"\"\"\n    if hasattr(self.backend, 'query_raw') and callable(getattr(self.backend, 'query_raw')):\n        result = self.backend.query_raw(command, *args, **kwargs)\n        if asyncio.iscoroutine(result):\n            response = await result\n        else:\n            response = result\n        self.log.append({\n            \"type\": \"query_raw\",\n            \"command\": command.strip(),\n            \"response\": response\n        })\n        return response\n    raise NotImplementedError(\"Backend does not support query_raw method.\")\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.read","title":"<code>read()</code>","text":"<p>Read from the instrument and log it.</p> Source code in <code>pytestlab/instruments/backends/recording_backend.py</code> <pre><code>def read(self) -&gt; str:\n    \"\"\"Read from the instrument and log it.\"\"\"\n    response = self.backend.read()\n    self.log.append({\"type\": \"read\", \"response\": response.strip()})\n    return response\n</code></pre>"},{"location":"api/backends/#pytestlab.instruments.backends.recording_backend.RecordingBackend.write","title":"<code>write(command, *args, **kwargs)</code>  <code>async</code>","text":"<p>Async write a command to the instrument and log it.</p> Source code in <code>pytestlab/instruments/backends/recording_backend.py</code> <pre><code>async def write(self, command: str, *args, **kwargs):\n    \"\"\"Async write a command to the instrument and log it.\"\"\"\n    self.log.append({\"type\": \"write\", \"command\": command.strip()})\n    if hasattr(self.backend, 'write') and callable(getattr(self.backend, 'write')):\n        result = self.backend.write(command, *args, **kwargs)\n        if asyncio.iscoroutine(result):\n            return await result\n        return result\n    raise NotImplementedError(\"Backend does not support write method.\")\n</code></pre>"},{"location":"api/backends/#backend-selection-logic","title":"Backend Selection Logic","text":"<p>PyTestLab chooses the backend automatically based on:</p> <ul> <li>The <code>simulate</code> flag (in code or <code>bench.yaml</code>)</li> <li>The instrument's <code>address</code> (e.g., <code>\"sim\"</code> triggers simulation)</li> <li>The <code>backend</code> or <code>backend_defaults</code> fields in your configuration</li> </ul> <p>You can override backend selection by specifying <code>backend_type_hint</code> when creating an instrument.</p>"},{"location":"api/backends/#extending-backends","title":"Extending Backends","text":"<p>To add support for a new hardware interface, subclass <code>InstrumentBackendBase</code> and implement the required async methods (<code>open</code>, <code>close</code>, <code>write</code>, <code>query</code>, etc.). See the source code and existing backends for examples.</p> <p>For more details on simulation, see the Simulation Guide.</p>"},{"location":"api/common/","title":"Common Utilities","text":"<p>This section documents shared enums, health checks, and other utility modules used throughout PyTestLab.</p>"},{"location":"api/common/#enums","title":"Enums","text":""},{"location":"api/common/#pytestlab.common.enums","title":"<code>pytestlab.common.enums</code>","text":""},{"location":"api/common/#pytestlab.common.enums.__all__","title":"<code>__all__ = ['SCPIOnOff', 'WaveformType', 'TriggerSlope', 'AcquisitionType', 'OutputLoadImpedance', 'OutputPolarity', 'VoltageUnit', 'TriggerSource', 'SyncMode', 'ModulationSource']</code>  <code>module-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.AcquisitionType","title":"<code>AcquisitionType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.AcquisitionType.AVERAGE","title":"<code>AVERAGE = 'AVER'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.AcquisitionType.HIGH_RES","title":"<code>HIGH_RES = 'HRES'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.AcquisitionType.NORMAL","title":"<code>NORMAL = 'NORM'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.AcquisitionType.PEAK","title":"<code>PEAK = 'PEAK'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.ArbAdvanceMode","title":"<code>ArbAdvanceMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.ArbAdvanceMode.SRATE","title":"<code>SRATE = 'SRATe'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.ArbAdvanceMode.TRIGGER","title":"<code>TRIGGER = 'TRIGger'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.ArbFilterType","title":"<code>ArbFilterType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.ArbFilterType.NORMAL","title":"<code>NORMAL = 'NORMal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.ArbFilterType.OFF","title":"<code>OFF = 'OFF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.ArbFilterType.STEP","title":"<code>STEP = 'STEP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.BurstMode","title":"<code>BurstMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.BurstMode.GATED","title":"<code>GATED = 'GATed'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.BurstMode.TRIGGERED","title":"<code>TRIGGERED = 'TRIGgered'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.ModulationSource","title":"<code>ModulationSource</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.ModulationSource.CH1","title":"<code>CH1 = 'CH1'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.ModulationSource.CH2","title":"<code>CH2 = 'CH2'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.ModulationSource.EXTERNAL","title":"<code>EXTERNAL = 'EXTernal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.ModulationSource.INTERNAL","title":"<code>INTERNAL = 'INTernal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.OutputLoadImpedance","title":"<code>OutputLoadImpedance</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.OutputLoadImpedance.DEFAULT","title":"<code>DEFAULT = 'DEFault'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.OutputLoadImpedance.FIFTY_OHM","title":"<code>FIFTY_OHM = '50'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.OutputLoadImpedance.INFINITY","title":"<code>INFINITY = 'INFinity'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.OutputLoadImpedance.MAXIMUM","title":"<code>MAXIMUM = 'MAXimum'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.OutputLoadImpedance.MINIMUM","title":"<code>MINIMUM = 'MINimum'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.OutputPolarity","title":"<code>OutputPolarity</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.OutputPolarity.INVERTED","title":"<code>INVERTED = 'INVerted'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.OutputPolarity.NORMAL","title":"<code>NORMAL = 'NORMal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.SCPIOnOff","title":"<code>SCPIOnOff</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.SCPIOnOff.OFF","title":"<code>OFF = 'OFF'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.SCPIOnOff.ON","title":"<code>ON = 'ON'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.SweepSpacing","title":"<code>SweepSpacing</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.SweepSpacing.LINEAR","title":"<code>LINEAR = 'LINear'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.SweepSpacing.LOGARITHMIC","title":"<code>LOGARITHMIC = 'LOGarithmic'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.SyncMode","title":"<code>SyncMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.SyncMode.CARRIER","title":"<code>CARRIER = 'CARRier'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.SyncMode.MARKER","title":"<code>MARKER = 'MARKer'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.SyncMode.NORMAL","title":"<code>NORMAL = 'NORMal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.TriggerSlope","title":"<code>TriggerSlope</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.TriggerSlope.ALTERNATING","title":"<code>ALTERNATING = 'ALT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.TriggerSlope.EITHER","title":"<code>EITHER = 'EITH'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.TriggerSlope.NEGATIVE","title":"<code>NEGATIVE = 'NEG'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.TriggerSlope.POSITIVE","title":"<code>POSITIVE = 'POS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.TriggerSource","title":"<code>TriggerSource</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.TriggerSource.BUS","title":"<code>BUS = 'BUS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.TriggerSource.EXTERNAL","title":"<code>EXTERNAL = 'EXTernal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.TriggerSource.IMMEDIATE","title":"<code>IMMEDIATE = 'IMMediate'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.TriggerSource.TIMER","title":"<code>TIMER = 'TIMer'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.VoltageUnit","title":"<code>VoltageUnit</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.VoltageUnit.DBM","title":"<code>DBM = 'DBM'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.VoltageUnit.VPP","title":"<code>VPP = 'VPP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.VoltageUnit.VRMS","title":"<code>VRMS = 'VRMS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.WaveformType","title":"<code>WaveformType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.enums.WaveformType.ARB","title":"<code>ARB = 'ARB'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.WaveformType.DC","title":"<code>DC = 'DC'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.WaveformType.NOISE","title":"<code>NOISE = 'NOIS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.WaveformType.PULSE","title":"<code>PULSE = 'PULS'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.WaveformType.RAMP","title":"<code>RAMP = 'RAMP'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.WaveformType.SINE","title":"<code>SINE = 'SIN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.enums.WaveformType.SQUARE","title":"<code>SQUARE = 'SQU'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#health-checks","title":"Health Checks","text":""},{"location":"api/common/#pytestlab.common.health","title":"<code>pytestlab.common.health</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthReport","title":"<code>HealthReport</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/common/#pytestlab.common.health.HealthReport.backend_status","title":"<code>backend_status = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthReport.errors","title":"<code>errors = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthReport.instrument_idn","title":"<code>instrument_idn = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthReport.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthReport.status","title":"<code>status = HealthStatus.UNKNOWN</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthReport.supported_features","title":"<code>supported_features = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthReport.warnings","title":"<code>warnings = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthStatus","title":"<code>HealthStatus</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"api/common/#pytestlab.common.health.HealthStatus.ERROR","title":"<code>ERROR = 'ERROR'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthStatus.OK","title":"<code>OK = 'OK'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthStatus.UNKNOWN","title":"<code>UNKNOWN = 'UNKNOWN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/common/#pytestlab.common.health.HealthStatus.WARNING","title":"<code>WARNING = 'WARNING'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/","title":"Configuration Models","text":"<p>This section details the Pydantic models used for instrument and bench configuration in PyTestLab. These models define the schema for instrument profiles, bench descriptors, and related configuration files.</p>"},{"location":"api/config/#bench-configuration","title":"Bench Configuration","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended","title":"<code>pytestlab.config.bench_config.BenchConfigExtended</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.automation","title":"<code>automation = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.backend_defaults","title":"<code>backend_defaults = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.bench_name","title":"<code>bench_name</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.changelog","title":"<code>changelog = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.continue_on_automation_error","title":"<code>continue_on_automation_error = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.custom_validations","title":"<code>custom_validations = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.experiment","title":"<code>experiment = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.instruments","title":"<code>instruments</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.last_modified","title":"<code>last_modified = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.measurement_plan","title":"<code>measurement_plan = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.model_config","title":"<code>model_config = ConfigDict(extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.simulate","title":"<code>simulate = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.traceability","title":"<code>traceability = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.version","title":"<code>version = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended-functions","title":"Functions","text":""},{"location":"api/config/#pytestlab.config.bench_config.BenchConfigExtended.check_instruments","title":"<code>check_instruments()</code>","text":"Source code in <code>pytestlab/config/bench_config.py</code> <pre><code>@model_validator(mode=\"after\")\ndef check_instruments(self) -&gt; \"BenchConfigExtended\":\n    if not self.instruments:\n        raise ValueError(\"At least one instrument must be defined in 'instruments'.\")\n    return self\n</code></pre>"},{"location":"api/config/#instrument-configuration-models","title":"Instrument Configuration Models","text":"<p>Each instrument profile YAML must specify a <code>device_type</code> that matches one of the following configuration models. These models define the required and optional fields for each instrument type.</p>"},{"location":"api/config/#base-instrument-model","title":"Base Instrument Model","text":""},{"location":"api/config/#pytestlab.config.instrument_config.InstrumentConfig","title":"<code>pytestlab.config.instrument_config.InstrumentConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"api/config/#pytestlab.config.instrument_config.InstrumentConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.instrument_config.InstrumentConfig.address","title":"<code>address = Field(None, description='Instrument connection address (e.g., VISA resource string)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.instrument_config.InstrumentConfig.device_type","title":"<code>device_type = Field(..., description=\"Type of the device (e.g., 'PSU', 'Oscilloscope')\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.instrument_config.InstrumentConfig.manufacturer","title":"<code>manufacturer = Field(..., description='Manufacturer of the instrument')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.instrument_config.InstrumentConfig.measurement_accuracy","title":"<code>measurement_accuracy = Field(default_factory=dict, description='Measurement accuracy specifications')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.instrument_config.InstrumentConfig.model","title":"<code>model = Field(..., description='Model number of the instrument')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.instrument_config.InstrumentConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='ignore')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.instrument_config.InstrumentConfig.serial_number","title":"<code>serial_number = Field(None, description='Serial number of the instrument')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#power-supply","title":"Power Supply","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig","title":"<code>pytestlab.config.power_supply_config.PowerSupplyConfig</code>","text":"<p>               Bases: <code>InstrumentConfig</code></p> <p>Pydantic model for Power Supply configuration.</p>"},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig.channels","title":"<code>channels = Field(..., min_length=1, description='List of power supply channel configurations')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig.device_type","title":"<code>device_type = Field('PSU', description=\"Device type identifier, must be 'PSU' or 'power_supply'.\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig.line_regulation","title":"<code>line_regulation = Field(None, description='Line regulation specification for the PSU.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig.load_regulation","title":"<code>load_regulation = Field(None, description='Load regulation specification for the PSU.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig.over_current_protection","title":"<code>over_current_protection = Field(None, description='Global Over Current Protection setting for the PSU, if applicable.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig.over_voltage_protection","title":"<code>over_voltage_protection = Field(None, description='Global Over Voltage Protection setting for the PSU, if applicable.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig.total_power","title":"<code>total_power = Field(None, description='Total output power rating for the PSU.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig-functions","title":"Functions","text":""},{"location":"api/config/#pytestlab.config.power_supply_config.PowerSupplyConfig.check_channel_ids_unique","title":"<code>check_channel_ids_unique()</code>","text":"Source code in <code>pytestlab/config/power_supply_config.py</code> <pre><code>@model_validator(mode='after')\ndef check_channel_ids_unique(self) -&gt; 'PowerSupplyConfig':\n    if self.channels:\n        ids = [ch.channel_id for ch in self.channels]\n        if len(ids) != len(set(ids)):\n            raise ValueError(\"Channel IDs must be unique.\")\n    return self\n</code></pre>"},{"location":"api/config/#oscilloscope","title":"Oscilloscope","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig","title":"<code>pytestlab.config.oscilloscope_config.OscilloscopeConfig</code>","text":"<p>               Bases: <code>InstrumentConfig</code></p>"},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.bandwidth","title":"<code>bandwidth = Field(..., gt=0, description='Analog bandwidth of the oscilloscope in Hz')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.channels","title":"<code>channels = Field(..., min_length=1, description='List of channel configurations')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.device_type","title":"<code>device_type = Field('oscilloscope', description='Type of the device (oscilloscope)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.fft","title":"<code>fft = Field(None, description='FFT capabilities, if available')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.franalysis","title":"<code>franalysis = Field(None, description='Frequency Response Analysis capabilities, if available')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.function_generator","title":"<code>function_generator = Field(None, description='Integrated function generator capabilities, if available')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.memory","title":"<code>memory = Field(..., gt=0, description='Maximum memory depth (e.g., in points or seconds)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.sampling_rate","title":"<code>sampling_rate = Field(..., gt=0, description='Maximum sampling rate in Samples/sec')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.timebase_settings","title":"<code>timebase_settings = Field(None, description='Global timebase settings, if applicable beyond per-channel')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.trigger","title":"<code>trigger = Field(..., description='Trigger system configuration')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig.waveform_update_rate","title":"<code>waveform_update_rate = Field(..., gt=0, description='Waveform update rate in waveforms/sec')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#waveform-generator","title":"Waveform Generator","text":""},{"location":"api/config/#pytestlab.config.waveform_generator_config.WaveformGeneratorConfig","title":"<code>pytestlab.config.waveform_generator_config.WaveformGeneratorConfig</code>","text":"<p>               Bases: <code>InstrumentConfig</code></p>"},{"location":"api/config/#pytestlab.config.waveform_generator_config.WaveformGeneratorConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.waveform_generator_config.WaveformGeneratorConfig.channels","title":"<code>channels = Field(..., min_length=1, description='List of waveform generator channel configurations')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.waveform_generator_config.WaveformGeneratorConfig.device_type","title":"<code>device_type = Field('waveform_generator', description=\"Type of the device (e.g., 'AWG', 'waveform_generator')\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.waveform_generator_config.WaveformGeneratorConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.waveform_generator_config.WaveformGeneratorConfig.waveforms","title":"<code>waveforms = Field(..., description='Waveform capabilities configuration')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#multimeter","title":"Multimeter","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig","title":"<code>pytestlab.config.multimeter_config.MultimeterConfig</code>","text":"<p>               Bases: <code>InstrumentConfig</code></p> <p>Pydantic model for Multimeter configuration, designed to load from a device spec YAML.</p>"},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig.autorange","title":"<code>autorange = Field(default=True, description='Enable (True) or disable (False) autoranging for measurements.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig.default_measurement_function","title":"<code>default_measurement_function = Field(default=DMMFunction.VOLTAGE_DC, description='Primary or default measurement function for the DMM.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig.device_type","title":"<code>device_type = Field('multimeter', description='Device type identifier for multimeters.')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig.limits","title":"<code>limits</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig.math_functions","title":"<code>math_functions</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig.measurement_functions","title":"<code>measurement_functions</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='ignore')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig.sampling_rates_rps","title":"<code>sampling_rates_rps</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.multimeter_config.MultimeterConfig.trigger_source","title":"<code>trigger_source = Field(default='IMM', description='Default trigger source: IMM (Immediate), EXT (External), BUS (Software/System).')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#dc-active-load","title":"DC Active Load","text":""},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig","title":"<code>pytestlab.config.dc_active_load_config.DCActiveLoadConfig</code>","text":"<p>               Bases: <code>InstrumentConfig</code></p> <p>Pydantic model for DC Active Load configuration, parsed from a device spec YAML.</p>"},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig.device_type","title":"<code>device_type</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig.environmental","title":"<code>environmental</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig.features","title":"<code>features</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig.general_specifications","title":"<code>general_specifications</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig.operating_modes","title":"<code>operating_modes</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig.other_characteristics_typical","title":"<code>other_characteristics_typical</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig.protection","title":"<code>protection</code>  <code>instance-attribute</code>","text":""},{"location":"api/config/#vector-network-analyzer-vna","title":"Vector Network Analyzer (VNA)","text":""},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig","title":"<code>pytestlab.config.vna_config.VNAConfig</code>","text":"<p>               Bases: <code>InstrumentConfig</code></p>"},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig.device_type","title":"<code>device_type = 'vna'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig.if_bandwidth","title":"<code>if_bandwidth = Field(None, description='IF bandwidth in Hz')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig.num_points","title":"<code>num_points = Field(None, description='Number of points in the sweep')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig.power_level","title":"<code>power_level = Field(None, description='Source power level in dBm')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig.s_parameters","title":"<code>s_parameters = Field(default_factory=lambda: ['S11', 'S21'], description=\"List of S-parameters to measure (e.g., ['S11', 'S21'])\")</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig.start_frequency","title":"<code>start_frequency = Field(None, description='Start frequency for the sweep in Hz')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.vna_config.VNAConfig.stop_frequency","title":"<code>stop_frequency = Field(None, description='Stop frequency for the sweep in Hz')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#spectrum-analyzer","title":"Spectrum Analyzer","text":""},{"location":"api/config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig","title":"<code>pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig</code>","text":"<p>               Bases: <code>InstrumentConfig</code></p>"},{"location":"api/config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig.attenuation","title":"<code>attenuation = Field(None, description='Input attenuation in dB')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig.device_type","title":"<code>device_type = 'spectrum_analyzer'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig.frequency_center","title":"<code>frequency_center = Field(None, description='Center frequency in Hz')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig.frequency_span","title":"<code>frequency_span = Field(None, description='Frequency span in Hz')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig.reference_level","title":"<code>reference_level = Field(None, description='Reference level in dBm')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig.resolution_bandwidth","title":"<code>resolution_bandwidth = Field(None, description='Resolution bandwidth in Hz (RBW)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#power-meter","title":"Power Meter","text":""},{"location":"api/config/#pytestlab.config.power_meter_config.PowerMeterConfig","title":"<code>pytestlab.config.power_meter_config.PowerMeterConfig</code>","text":"<p>               Bases: <code>InstrumentConfig</code></p>"},{"location":"api/config/#pytestlab.config.power_meter_config.PowerMeterConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.power_meter_config.PowerMeterConfig.averaging_count","title":"<code>averaging_count = Field(None, description='Number of readings to average for a measurement')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_meter_config.PowerMeterConfig.device_type","title":"<code>device_type = 'power_meter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_meter_config.PowerMeterConfig.frequency_compensation_value","title":"<code>frequency_compensation_value = Field(None, description='Frequency for sensor compensation in Hz')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_meter_config.PowerMeterConfig.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.power_meter_config.PowerMeterConfig.power_units","title":"<code>power_units = Field('dBm', description='Units for power measurement')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#virtual-instrument","title":"Virtual Instrument","text":""},{"location":"api/config/#pytestlab.config.virtual_instrument_config.VirtualInstrumentConfig","title":"<code>pytestlab.config.virtual_instrument_config.VirtualInstrumentConfig</code>","text":"<p>               Bases: <code>InstrumentConfig</code></p> <p>Pydantic model for the Virtual Instrument configuration.</p>"},{"location":"api/config/#pytestlab.config.virtual_instrument_config.VirtualInstrumentConfig-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.virtual_instrument_config.VirtualInstrumentConfig.device_type","title":"<code>device_type = 'virtual_instrument'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#accuracy-specification","title":"Accuracy Specification","text":"<p>Many instrument models include an <code>accuracy</code> field or section. This is typically defined using the <code>AccuracySpec</code> model.</p>"},{"location":"api/config/#pytestlab.config.accuracy.AccuracySpec","title":"<code>pytestlab.config.accuracy.AccuracySpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single accuracy specification for a measurement mode. The standard deviation (sigma) is typically calculated as: sqrt((percent_reading * reading)^2 + (offset_value)^2) or other forms depending on how specs are given (e.g., % of range).</p>"},{"location":"api/config/#pytestlab.config.accuracy.AccuracySpec-attributes","title":"Attributes","text":""},{"location":"api/config/#pytestlab.config.accuracy.AccuracySpec.model_config","title":"<code>model_config = ConfigDict(validate_assignment=True, extra='forbid')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.accuracy.AccuracySpec.offset_value","title":"<code>offset_value = Field(None, ge=0, description='Fixed offset accuracy in units of the measurement (e.g., 0.005 V)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.accuracy.AccuracySpec.percent_reading","title":"<code>percent_reading = Field(None, ge=0, description='Accuracy as a percentage of the reading (e.g., 0.0001 for 0.01%)')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/config/#pytestlab.config.accuracy.AccuracySpec-functions","title":"Functions","text":""},{"location":"api/config/#pytestlab.config.accuracy.AccuracySpec.calculate_std_dev","title":"<code>calculate_std_dev(reading_value, range_value=None)</code>","text":"<p>Calculates the standard deviation (sigma) for a given reading. This is a simplified example; real datasheets can be more complex. Assumes reading_value is positive for typical instrument readings.</p> Source code in <code>pytestlab/config/accuracy.py</code> <pre><code>def calculate_std_dev(self, reading_value: float, range_value: Optional[float] = None) -&gt; float:\n    \"\"\"\n    Calculates the standard deviation (sigma) for a given reading.\n    This is a simplified example; real datasheets can be more complex.\n    Assumes reading_value is positive for typical instrument readings.\n    \"\"\"\n    if reading_value &lt; 0:\n        # Or handle as per specific instrument/measurement context\n        # For now, using absolute value for calculation if negative readings are possible and meaningful\n        # reading_value = abs(reading_value)\n        pass # Assuming reading_value is typically positive or magnitude.\n\n    variance = 0.0\n    if self.percent_reading is not None:\n        if self.percent_reading &lt; 0:\n            raise ValueError(\"percent_reading must be non-negative.\")\n        variance += (self.percent_reading * reading_value)**2\n\n    if self.offset_value is not None:\n        if self.offset_value &lt; 0:\n            raise ValueError(\"offset_value must be non-negative.\")\n        variance += self.offset_value**2\n\n    # Example for percent_range if it were added:\n    # percent_range: Optional[float] = Field(None, ge=0, description=\"Accuracy as a percentage of the range\")\n    # if self.percent_range is not None and range_value is not None:\n    #     if self.percent_range &lt; 0:\n    #         raise ValueError(\"percent_range must be non-negative.\")\n    #     if range_value &lt;= 0: # Range should be positive\n    #         raise ValueError(\"range_value must be positive for percent_range calculation.\")\n    #     variance += (self.percent_range * range_value)**2\n\n    if variance &lt; 0.0: # Should not happen with non-negative inputs and squaring\n         raise ValueError(\"Calculated variance is negative, check inputs and logic.\")\n    if variance == 0.0: # No spec provided, or spec results in zero uncertainty\n        return 0.0 # Or raise an error, or return a very small number if appropriate\n\n    return math.sqrt(variance)\n</code></pre>"},{"location":"api/config/#configuration-loader","title":"Configuration Loader","text":"<p>For advanced users, PyTestLab provides a configuration loader utility for validating and loading profiles.</p> <p>For more information on creating and validating instrument profiles, see the Creating Profiles Guide.</p>"},{"location":"api/config/#pytestlab.config.loader.ConfigLoader","title":"<code>pytestlab.config.loader.ConfigLoader</code>","text":"<p>Dummy ConfigLoader class for documentation compatibility. This is not used in runtime code, but allows mkdocstrings to resolve 'pytestlab.config.ConfigLoader' for API docs.</p>"},{"location":"api/errors/","title":"Exceptions","text":"<p>This page documents the custom exception types used throughout PyTestLab. Understanding these exceptions is essential for writing robust, reliable, and safe test scripts.</p>"},{"location":"api/errors/#exception-reference","title":"Exception Reference","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentConnectionError","title":"<code>pytestlab.errors.InstrumentConnectionError(instrument=None, message='')</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for SCPI instrument connection errors.</p> Source code in <code>pytestlab/errors.py</code> <pre><code>def __init__(self, instrument=None, message=\"\"):\n    self.instrument = instrument\n    self.message = message\n    if instrument:\n        super().__init__(f\"Failed to connect to instrument '{instrument}'. {message}\")\n    else:\n        super().__init__(f\"Failed to connect to instrument. {message}\")\n</code></pre>"},{"location":"api/errors/#pytestlab.errors.InstrumentConnectionError-attributes","title":"Attributes","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentConnectionError.instrument","title":"<code>instrument = instrument</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentConnectionError.message","title":"<code>message = message</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentConnectionError-functions","title":"Functions","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentCommunicationError","title":"<code>pytestlab.errors.InstrumentCommunicationError(instrument=None, command=None, message='')</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for SCPI communication errors.</p> Source code in <code>pytestlab/errors.py</code> <pre><code>def __init__(self, instrument=None, command=None, message=\"\"):\n    self.instrument = instrument\n    self.command = command\n    self.message = message\n    full_message = f\"Error in SCPI communication with instrument '{instrument}'\"\n    if command:\n        full_message += f\" while sending command '{command}'\"\n    full_message += f\". {message}\"\n    super().__init__(full_message)\n</code></pre>"},{"location":"api/errors/#pytestlab.errors.InstrumentCommunicationError-attributes","title":"Attributes","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentCommunicationError.command","title":"<code>command = command</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentCommunicationError.instrument","title":"<code>instrument = instrument</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentCommunicationError.message","title":"<code>message = message</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentCommunicationError-functions","title":"Functions","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentParameterError","title":"<code>pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Exception raised for invalid parameters given to an instrument.</p> Source code in <code>pytestlab/errors.py</code> <pre><code>def __init__(self, parameter=None, value=None, valid_range=None, message=\"\"):\n    self.parameter = parameter\n    self.value = value\n    self.valid_range = valid_range\n    self.message = message\n    full_message = \"Invalid parameter value for instrument\"\n    if parameter:\n        full_message += f\" for parameter '{parameter}'\"\n    if value is not None:\n        full_message += f\": received '{value}'\"\n    if valid_range:\n        full_message += f\", but expected a value in the range {valid_range}\"\n    full_message += f\". {message}\"\n    super().__init__(full_message)\n</code></pre>"},{"location":"api/errors/#pytestlab.errors.InstrumentParameterError-attributes","title":"Attributes","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentParameterError.message","title":"<code>message = message</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentParameterError.parameter","title":"<code>parameter = parameter</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentParameterError.valid_range","title":"<code>valid_range = valid_range</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentParameterError.value","title":"<code>value = value</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentParameterError-functions","title":"Functions","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentConfigurationError","title":"<code>pytestlab.errors.InstrumentConfigurationError(instrument=None, message='')</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for instrument configuration errors.</p> Source code in <code>pytestlab/errors.py</code> <pre><code>def __init__(self, instrument=None, message=\"\"):\n    self.instrument = instrument\n    self.message = message\n    if instrument:\n        super().__init__(f\"Invalid configuration for instrument '{instrument}'. {message}\")\n    else:\n        super().__init__(f\"Invalid instrument configuration. {message}\")\n</code></pre>"},{"location":"api/errors/#pytestlab.errors.InstrumentConfigurationError-attributes","title":"Attributes","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentConfigurationError.instrument","title":"<code>instrument = instrument</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentConfigurationError.message","title":"<code>message = message</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentConfigurationError-functions","title":"Functions","text":""},{"location":"api/errors/#pytestlab.errors.DatabaseError","title":"<code>pytestlab.errors.DatabaseError(operation=None, message='')</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for database errors.</p> Source code in <code>pytestlab/errors.py</code> <pre><code>def __init__(self, operation=None, message=\"\"):\n    self.operation = operation\n    self.message = message\n    if operation:\n        super().__init__(f\"Error in database operation '{operation}'. {message}\")\n    else:\n        super().__init__(f\"Error in database operation. {message}\")\n</code></pre>"},{"location":"api/errors/#pytestlab.errors.DatabaseError-attributes","title":"Attributes","text":""},{"location":"api/errors/#pytestlab.errors.DatabaseError.message","title":"<code>message = message</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.DatabaseError.operation","title":"<code>operation = operation</code>  <code>instance-attribute</code>","text":""},{"location":"api/errors/#pytestlab.errors.DatabaseError-functions","title":"Functions","text":""},{"location":"api/errors/#pytestlab.errors.InstrumentNotFoundError","title":"<code>pytestlab.errors.InstrumentNotFoundError(name)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>For instrument not found errors.</p> Source code in <code>pytestlab/errors.py</code> <pre><code>def __init__(self, name):\n    super().__init__(f\"Instrument {name} not found in the manager's collection.\")\n</code></pre>"},{"location":"api/errors/#pytestlab.errors.InstrumentNotFoundError-functions","title":"Functions","text":""},{"location":"api/errors/#usage-example","title":"Usage Example","text":"<pre><code>from pytestlab.errors import (\n    InstrumentConnectionError,\n    InstrumentParameterError,\n    DatabaseError,\n)\n\ntry:\n    # ... instrument operations ...\n    await bench.psu.set_voltage(1, 6.0)  # May raise InstrumentParameterError or other errors\nexcept InstrumentConnectionError as e:\n    print(f\"Failed to connect: {e}\")\nexcept InstrumentParameterError as e:\n    print(f\"Invalid parameter: {e}\")\nexcept DatabaseError as e:\n    print(f\"Database error: {e}\")\n</code></pre> <p>For a practical guide to error handling, see the Error Handling Guide.</p>"},{"location":"api/experiments/","title":"Experiments &amp; Sweeps","text":"<p>This section documents the core classes and utilities for managing experiments, sweeps, and measurement results in PyTestLab.</p>"},{"location":"api/experiments/#database-results","title":"Database &amp; Results","text":""},{"location":"api/experiments/#pytestlab.experiments.database.Database","title":"<code>pytestlab.experiments.database.Database = MeasurementDatabase</code>  <code>module-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult","title":"<code>pytestlab.experiments.results.MeasurementResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs)</code>","text":"<p>A class to represent a collection of measurement values.</p> ATTRIBUTE DESCRIPTION <code>values</code> <p>The measurement data.</p> <p> TYPE: <code>Union[ndarray, DataFrame, float64, List[Any], UFloat]</code> </p> <code>units</code> <p>The units of the measurements.</p> <p> TYPE: <code>str</code> </p> <code>instrument</code> <p>The name of the instrument used for the measurements.</p> <p> TYPE: <code>str</code> </p> <code>measurement_type</code> <p>The type of measurement.</p> <p> TYPE: <code>str</code> </p> <code>timestamp</code> <p>Timestamp of when the result was created.</p> <p> TYPE: <code>float</code> </p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __init__(self, values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat],\n             instrument: str,\n             units: str,\n             measurement_type: str,\n             timestamp: Optional[float] = None, # Allow optional timestamp override\n             envelope: Optional[Dict[str, Any]] = None, # Add envelope as an explicit argument\n             sampling_rate: Optional[float] = None, # Add sampling_rate for FFT\n             **kwargs: Any) -&gt; None: # Added **kwargs and type hint\n    self.values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat] = values\n    self.units: str = units\n    self.instrument: str = instrument\n    self.measurement_type: str = measurement_type\n    self.timestamp: float = timestamp if timestamp is not None else time.time()\n    # Envelope logic: always provide an envelope attribute\n    if envelope is not None:\n        self.envelope = envelope\n    else:\n        # Default: minimal valid envelope (empty dict, or customize as needed)\n        self.envelope = {}\n\n    # Store sampling rate for FFT calculations\n    self.sampling_rate = sampling_rate\n\n    # Store any additional kwargs as attributes\n    for key, value in kwargs.items():\n        setattr(self, key, value)\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult-attributes","title":"Attributes","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.envelope","title":"<code>envelope = envelope</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.instrument","title":"<code>instrument = instrument</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.measurement_type","title":"<code>measurement_type = measurement_type</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.nominal","title":"<code>nominal</code>  <code>property</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.sampling_rate","title":"<code>sampling_rate = sampling_rate</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.sigma","title":"<code>sigma</code>  <code>property</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.timestamp","title":"<code>timestamp = timestamp if timestamp is not None else time.time()</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.units","title":"<code>units = units</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.values","title":"<code>values = values</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult-functions","title":"Functions","text":""},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.__delitem__","title":"<code>__delitem__(index)</code>","text":"<p>Allows deleting an item from 'values' if it's a list or ndarray.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __delitem__(self, index: int) -&gt; None:\n    \"\"\"Allows deleting an item from 'values' if it's a list or ndarray.\"\"\"\n    if isinstance(self.values, list):\n        del self.values[index]\n    elif isinstance(self.values, np.ndarray):\n        self.values = np.delete(self.values, index, axis=0)\n    else:\n        raise TypeError(f\"Deletion by index not supported for type {type(self.values)}\")\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Allows indexing into the 'values' attribute.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __getitem__(self, index: int) -&gt; Any:\n    \"\"\"Allows indexing into the 'values' attribute.\"\"\"\n    if isinstance(self.values, (np.ndarray, list)):\n        return self.values[index]\n    elif isinstance(self.values, pl.DataFrame):\n        return self.values[index] # Returns a row as a new DataFrame\n    elif isinstance(self.values, (np.float64, UFloat)) and index == 0:\n        return self.values\n    raise IndexError(f\"Index {index} not applicable for type {type(self.values)}\")\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.__iter__","title":"<code>__iter__()</code>","text":"<p>Allows iteration over the 'values' attribute.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Any]:\n    \"\"\"Allows iteration over the 'values' attribute.\"\"\"\n    if isinstance(self.values, (np.ndarray, list)):\n        return iter(self.values)\n    elif isinstance(self.values, pl.DataFrame):\n        return iter(self.values.iter_rows())\n    elif isinstance(self.values, (np.float64, UFloat)):\n        return iter([self.values])\n    raise TypeError(f\"Iteration not supported for type {type(self.values)}\")\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.__len__","title":"<code>__len__()</code>","text":"Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __len__(self) -&gt; int:\n    if isinstance(self.values, (np.ndarray, list)):\n        return len(self.values)\n    elif isinstance(self.values, (np.float64, UFloat)):\n        return 1\n    elif isinstance(self.values, pl.DataFrame):\n        return self.values.height # Number of rows\n    return 0 # Default for unknown types\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.__repr__","title":"<code>__repr__()</code>","text":"<p>For backward compatibility with tests: - 1D arrays return a newline-separated list of values with units (like str) - Other types use a detailed representation</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    For backward compatibility with tests:\n    - 1D arrays return a newline-separated list of values with units (like __str__)\n    - Other types use a detailed representation\n    \"\"\"\n    if isinstance(self.values, np.ndarray) and self.values.ndim == 1:\n        return '\\n'.join([f\"{val} {self.units}\" for val in self.values])\n    return (f\"MeasurementResult(instrument='{self.instrument}', type='{self.measurement_type}', \"\n            f\"units='{self.units}', values_type='{type(self.values).__name__}', timestamp={self.timestamp})\")\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the measurement result.</p> <p>For backward compatibility with tests, returns a newline-separated list for arrays. For other types, uses a more descriptive representation.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation of the measurement result.\n\n    For backward compatibility with tests, returns a newline-separated list for arrays.\n    For other types, uses a more descriptive representation.\n    \"\"\"\n    if isinstance(self.values, UFloat):\n        return f\"{self.values} {self.units}\"\n    elif isinstance(self.values, np.float64):\n        return f\"{self.values} {self.units}\"\n    elif isinstance(self.values, pl.DataFrame):\n        return str(self.values)\n    elif isinstance(self.values, np.ndarray):\n        # For numpy arrays, handle 1D arrays specially for backward compatibility\n        if self.values.ndim == 1:\n            return '\\n'.join([f\"{val} {self.units}\" for val in self.values])\n        # For multi-dimensional arrays, provide a concise representation\n        return f\"NumPy Array (shape: {self.values.shape}, dtype: {self.values.dtype}) {self.units}\"\n    elif isinstance(self.values, list):\n        # For lists, special handling for backward compatibility\n        if all(isinstance(x, (int, float)) for x in self.values):\n            return '\\n'.join([f\"{val} {self.units}\" for val in self.values])\n        # For lists with mixed types or nested lists, show first few items if long\n        if len(self.values) &gt; 5:\n            return f\"List (first 5 of {len(self.values)}): {self.values[:5]}... {self.units}\"\n        return f\"List: {self.values} {self.units}\"\n\n    # Fallback for other types\n    return f\"Values: {str(self.values)[:100]}... Type: {type(self.values)} {self.units}\"\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.add","title":"<code>add(value)</code>","text":"<p>Adds a new value to the collection. Behavior depends on self.values type.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def add(self, value: Any) -&gt; None:\n    \"\"\"Adds a new value to the collection. Behavior depends on self.values type.\"\"\"\n    if isinstance(self.values, np.ndarray):\n        # This might be inefficient for frequent additions. Consider list then convert.\n        self.values = np.append(self.values, value)\n    elif isinstance(self.values, list):\n        self.values.append(value)\n    elif isinstance(self.values, np.float64):\n        # Convert to list or ndarray if adding to a single float\n        self.values = np.array([self.values, value]) # type: ignore\n        print(\"Warning: Added value to np.float64, converted 'values' to np.ndarray.\")\n    elif isinstance(self.values, UFloat):\n        # If current value is UFloat, adding another value implies creating a list/array of UFloats\n        self.values = [self.values, value] # type: ignore\n        print(\"Warning: Added value to UFloat, converted 'values' to a list. Consider using a list of UFloats initially.\")\n    elif isinstance(self.values, pl.DataFrame):\n        # Appending to Polars DataFrame is complex; typically done by creating a new DF and vstacking.\n        # This simple 'add' might not be suitable.\n        raise NotImplementedError(\"Direct 'add' to Polars DataFrame not supported. Use 'set_values' or manage DataFrame externally.\")\n    else:\n        raise TypeError(f\"Cannot 'add' to type {type(self.values)}\")\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.clear","title":"<code>clear()</code>","text":"<p>Clears all the MeasurementValues from the collection, resetting to an empty/default state.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clears all the MeasurementValues from the collection, resetting to an empty/default state.\"\"\"\n    if isinstance(self.values, np.ndarray):\n        self.values = np.array([])\n    elif isinstance(self.values, (np.float64, UFloat)): # Reset UFloat to a default float or ufloat(0,0)\n        self.values = np.float64(0.0) # Or ufloat(0,0) if preferred default for UFloat\n    elif isinstance(self.values, pl.DataFrame):\n        self.values = pl.DataFrame()\n    elif isinstance(self.values, list):\n        self.values = []\n    else: # Fallback for unknown types, attempt to set to a default float64\n        print(f\"Warning: Clearing unknown type {type(self.values)}, setting to np.float64(0.0).\")\n        self.values = np.float64(0.0)\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.get","title":"<code>get(index)</code>","text":"<p>Gets the MeasurementValue at a specified index. Assumes indexable values.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def get(self, index: int) -&gt; Any:\n    \"\"\"Gets the MeasurementValue at a specified index. Assumes indexable values.\"\"\"\n    if isinstance(self.values, (np.ndarray, list)):\n        return self.values[index]\n    elif isinstance(self.values, pl.DataFrame):\n        # For DataFrame, 'get' by index might mean row.\n        # This returns a new DataFrame with one row.\n        return self.values[index]\n    elif isinstance(self.values, (np.float64, UFloat)) and index == 0:\n        return self.values\n    raise IndexError(f\"Index {index} out of range or type {type(self.values)} not directly indexable by single int.\")\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.get_all","title":"<code>get_all()</code>","text":"<p>Returns all the MeasurementValues in the collection.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def get_all(self) -&gt; Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat]:\n    \"\"\"Returns all the MeasurementValues in the collection.\"\"\"\n    return self.values\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.items","title":"<code>items()</code>","text":"<p>Return items for dict-like behavior.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def items(self):\n    \"\"\"Return items for dict-like behavior.\"\"\"\n    return self.to_dict().items()\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.keys","title":"<code>keys()</code>","text":"<p>Return the keys for dict-like behavior.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def keys(self):\n    \"\"\"Return the keys for dict-like behavior.\"\"\"\n    return self.to_dict().keys()\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.perform_fft","title":"<code>perform_fft()</code>","text":"<p>Perform Fast Fourier Transform on the measurement data.</p> <p>Requires: - self.values to be a numpy array of time-domain data - self.sampling_rate to be set (in Hz)</p> RETURNS DESCRIPTION <code>'MeasurementResult'</code> <p>A new MeasurementResult containing the FFT data, with frequency in Hz</p> <code>'MeasurementResult'</code> <p>and magnitude in the same units as the original data.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def perform_fft(self) -&gt; 'MeasurementResult':\n    \"\"\"Perform Fast Fourier Transform on the measurement data.\n\n    Requires:\n    - self.values to be a numpy array of time-domain data\n    - self.sampling_rate to be set (in Hz)\n\n    Returns:\n        A new MeasurementResult containing the FFT data, with frequency in Hz\n        and magnitude in the same units as the original data.\n    \"\"\"\n    if self.sampling_rate is None:\n        raise ValueError(\"Sampling rate must be set to perform FFT\")\n\n    if not isinstance(self.values, np.ndarray):\n        raise TypeError(f\"FFT requires numpy array, got {type(self.values)}\")\n\n    # Ensure we're working with a 1D array\n    values = self.values.flatten() if self.values.ndim &gt; 1 else self.values\n\n    # Perform FFT\n    fft_values = np.fft.rfft(values)\n    fft_magnitude = np.abs(fft_values)\n\n    # Create frequency axis\n    freqs = np.fft.rfftfreq(len(values), 1/self.sampling_rate)\n\n    # Create result with frequency and magnitude\n    result_df = pl.DataFrame({\n        \"frequency\": freqs,\n        \"magnitude\": fft_magnitude\n    })\n\n    return MeasurementResult(\n        values=result_df,\n        instrument=self.instrument,\n        units=self.units,\n        measurement_type=\"FFT\",\n        timestamp=time.time(),\n        original_type=self.measurement_type,\n        sampling_rate=self.sampling_rate\n    )\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.save","title":"<code>save(path)</code>","text":"<p>Saves the measurement data to a file.</p> <p>If the data is a numpy array, it will be saved as a .npy file. If the data is a Polars DataFrame, it will be saved as a .parquet file. Other list-like data will be converted to numpy array and saved as .npy. np.float64 will be saved as a 0-D numpy array. UFloat objects will be saved as a two-element numpy array [nominal, std_dev] in a .npy file.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def save(self, path: str) -&gt; None:\n    \"\"\"Saves the measurement data to a file.\n\n    If the data is a numpy array, it will be saved as a .npy file.\n    If the data is a Polars DataFrame, it will be saved as a .parquet file.\n    Other list-like data will be converted to numpy array and saved as .npy.\n    np.float64 will be saved as a 0-D numpy array.\n    UFloat objects will be saved as a two-element numpy array [nominal, std_dev] in a .npy file.\n    \"\"\"\n    default_ext = \".npy\"\n    if isinstance(self.values, pl.DataFrame):\n        default_ext = \".parquet\"\n\n    if not path.endswith(('.npy', '.parquet')):\n        path += default_ext\n        print(f\"Warning: File extension not specified. Saving as {path}\")\n\n    if isinstance(self.values, np.ndarray):\n        np.save(path, self.values)\n    elif isinstance(self.values, pl.DataFrame):\n        if not path.endswith(\".parquet\"):\n            print(f\"Warning: Saving Polars DataFrame to non-parquet file '{path}'. Consider using .parquet for DataFrames.\")\n        self.values.write_parquet(path)\n    elif isinstance(self.values, UFloat):\n        if not path.endswith(\".npy\"):\n            print(f\"Warning: Saving UFloat to non-npy file '{path}'. Consider using .npy.\")\n        np.save(path, np.array([self.values.nominal_value, self.values.std_dev]))\n    elif isinstance(self.values, (list, np.float64)): # Convert list or float64 to ndarray\n        if not path.endswith(\".npy\"):\n            print(f\"Warning: Saving {type(self.values).__name__} to non-npy file '{path}'. Consider using .npy.\")\n        np.save(path, np.array(self.values))\n    else:\n        raise TypeError(f\"Unsupported data type for saving: {type(self.values)}. Can save np.ndarray, pl.DataFrame, list, np.float64, or UFloat.\")\n    print(f\"Measurement saved to {path}\")\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.set_values","title":"<code>set_values(values)</code>","text":"<p>Sets the MeasurementValues in the collection.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def set_values(self, values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat]) -&gt; None:\n    \"\"\"Sets the MeasurementValues in the collection.\"\"\"\n    self.values = values\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.results.MeasurementResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert MeasurementResult to a dict for DataFrame conversion.</p> <p>This allows MeasurementResult objects to be directly used in Experiment.add_trial.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert MeasurementResult to a dict for DataFrame conversion.\n\n    This allows MeasurementResult objects to be directly used in Experiment.add_trial.\n    \"\"\"\n    if isinstance(self.values, pl.DataFrame):\n        # If values is already a DataFrame, convert to dict representation\n        result = {}\n        for col in self.values.columns:\n            result[col] = self.values[col].to_list()\n        return result\n    elif isinstance(self.values, (np.ndarray, list)):\n        # Convert array or list to a dict with a 'values' key\n        return {'values': self.values}\n    elif isinstance(self.values, (np.float64, UFloat)):\n        # Convert scalar value to a dict with a 'value' key\n        return {'value': self.values}\n    else:\n        # Default fallback\n        return {'values': self.values}\n</code></pre>"},{"location":"api/experiments/#experiments-sweeps_1","title":"Experiments &amp; Sweeps","text":""},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment","title":"<code>pytestlab.experiments.experiments.Experiment(name, description='', notes='')</code>","text":"<p>Experiment tracker to store measurements and parameters.</p> <p>This class maintains an internal Polars DataFrame (self.data) for trial data, regardless of whether the input is provided as a Polars DataFrame, dict, or list.</p> It provides two export functionalities <ul> <li>save_parquet(file_path): Saves the internal data as a Parquet file.</li> </ul> <p>Additionally, printing the Experiment instance (via str) shows a summary and the head (first few rows) of the data.</p> Source code in <code>pytestlab/experiments/experiments.py</code> <pre><code>def __init__(self, name: str, description: str = \"\", notes: str = \"\") -&gt; None:\n    self.name: str = name\n    self.description: str = description\n    self.notes: str = notes\n    self.parameters: Dict[str, ExperimentParameter] = {}\n    self.data: pl.DataFrame = pl.DataFrame()\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment-attributes","title":"Attributes","text":""},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.data","title":"<code>data = pl.DataFrame()</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.description","title":"<code>description = description</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.name","title":"<code>name = name</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.notes","title":"<code>notes = notes</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.parameters","title":"<code>parameters = {}</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment-functions","title":"Functions","text":""},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate over each trial (row) as a dictionary.</p> Source code in <code>pytestlab/experiments/experiments.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Dict[str, Any]]:\n    \"\"\"Iterate over each trial (row) as a dictionary.\"\"\"\n    for row in self.data.to_dicts():\n        yield row\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of trials.</p> Source code in <code>pytestlab/experiments/experiments.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of trials.\"\"\"\n    return self.data.height\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the experiment.</p> <p>This includes a summary of the experiment details and prints the first 5 rows of the trial data (the head).</p> Source code in <code>pytestlab/experiments/experiments.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the experiment.\n\n    This includes a summary of the experiment details and prints the first 5 rows\n    of the trial data (the head).\n    \"\"\"\n    param_str = \", \".join(str(param) for param in self.parameters.values())\n    head_data: Union[pl.DataFrame, str]\n    if not self.data.is_empty():\n        head_data = self.data.head(5)\n    else:\n        head_data = \"No trial data available.\"\n\n    return (f\"Experiment: {self.name}\\n\"\n            f\"Description: {self.description}\\n\"\n            f\"Notes: {self.notes or 'No notes'}\\n\"\n            f\"Parameters: {param_str}\\n\"\n            f\"Trial Data (first 5 rows):\\n{head_data}\")\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.add_parameter","title":"<code>add_parameter(name, units, notes='')</code>","text":"<p>Add a new parameter to the experiment.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name of the parameter.</p> <p> TYPE: <code>str</code> </p> <code>units</code> <p>Units for the parameter.</p> <p> TYPE: <code>str</code> </p> <code>notes</code> <p>Additional notes.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>pytestlab/experiments/experiments.py</code> <pre><code>def add_parameter(self, name: str, units: str, notes: str = \"\") -&gt; None:\n    \"\"\"\n    Add a new parameter to the experiment.\n\n    Args:\n        name (str): Name of the parameter.\n        units (str): Units for the parameter.\n        notes (str, optional): Additional notes.\n    \"\"\"\n    self.parameters[name] = ExperimentParameter(name, units, notes)\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.add_trial","title":"<code>add_trial(measurement_result, **parameter_values)</code>","text":"<p>Add a new trial to the experiment.</p> <p>Accepts measurement data in various formats (list, dict, Polars DataFrame, or MeasurementResult) and converts it into a Polars DataFrame if needed. Additional parameter values are added as new columns.</p> PARAMETER DESCRIPTION <code>measurement_result</code> <p>The measurement data.</p> <p> TYPE: <code>Union[DataFrame, Dict[str, Any], List[Any], MeasurementResult]</code> </p> <code>**parameter_values</code> <p>Additional parameters to include with this trial.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the conversion to a Polars DataFrame fails or if a         provided parameter is not defined.</p> Source code in <code>pytestlab/experiments/experiments.py</code> <pre><code>def add_trial(self, measurement_result: Union[pl.DataFrame, Dict[str, Any], List[Any], 'MeasurementResult'], **parameter_values: Any) -&gt; None:\n    \"\"\"\n    Add a new trial to the experiment.\n\n    Accepts measurement data in various formats (list, dict, Polars DataFrame, or MeasurementResult)\n    and converts it into a Polars DataFrame if needed. Additional parameter values\n    are added as new columns.\n\n    Args:\n        measurement_result (Union[pl.DataFrame, Dict[str, Any], List[Any], MeasurementResult]): The measurement data.\n        **parameter_values: Additional parameters to include with this trial.\n\n    Raises:\n        ValueError: If the conversion to a Polars DataFrame fails or if a\n                    provided parameter is not defined.\n    \"\"\"\n    trial_df: pl.DataFrame\n\n    # Special handling for MeasurementResult objects\n    if hasattr(measurement_result, 'values') and hasattr(measurement_result, 'to_dict'):\n        # If it's a MeasurementResult, extract its values\n        if isinstance(measurement_result.values, pl.DataFrame):\n            trial_df = measurement_result.values\n        else:\n            # Convert to dict and then to DataFrame\n            try:\n                trial_df = pl.DataFrame(measurement_result.to_dict(), strict=False)\n            except Exception as e:\n                raise ValueError(f\"Failed to convert MeasurementResult to DataFrame: {e}\") from e\n    elif not isinstance(measurement_result, pl.DataFrame):\n        try:\n            trial_df = pl.DataFrame(measurement_result, strict=False)\n        except Exception as e:\n            raise ValueError(f\"Failed to convert measurement_result to a Polars DataFrame: {e}\") from e\n    else:\n        trial_df = measurement_result\n\n    for param_name, value in parameter_values.items():\n        if param_name not in self.parameters:\n            raise ValueError(f\"Parameter '{param_name}' is not defined in the experiment. Add it first using add_parameter().\")\n        trial_df = trial_df.with_columns(pl.lit(value).alias(param_name))\n\n    if self.data.is_empty():\n        self.data = trial_df\n    else:\n        try:\n            self.data = self.data.vstack(trial_df)\n        except Exception as e: \n            raise ValueError(f\"Failed to stack new trial data. Check for schema compatibility. Error: {e}\") from e\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.list_trials","title":"<code>list_trials()</code>","text":"<p>Print the full trials DataFrame.</p> Source code in <code>pytestlab/experiments/experiments.py</code> <pre><code>def list_trials(self) -&gt; None:\n    \"\"\"Print the full trials DataFrame.\"\"\"\n    print(self.data)\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.experiments.Experiment.save_parquet","title":"<code>save_parquet(file_path)</code>","text":"<p>Save the internal Polars DataFrame as a Parquet file.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>The file path (including filename) where the Parquet file will be saved.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pytestlab/experiments/experiments.py</code> <pre><code>def save_parquet(self, file_path: str) -&gt; None:\n    \"\"\"\n    Save the internal Polars DataFrame as a Parquet file.\n\n    Args:\n        file_path (str): The file path (including filename) where the Parquet file will be saved.\n    \"\"\"\n    self.data.write_parquet(file_path)\n    print(f\"Data saved to Parquet file at: {file_path}\")\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep","title":"<code>pytestlab.experiments.sweep</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep-attributes","title":"Attributes","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.R","title":"<code>R = TypeVar('R')</code>  <code>module-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.T","title":"<code>T = TypeVar('T')</code>  <code>module-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.grid_sweep_impl","title":"<code>grid_sweep_impl = grid_sweep</code>  <code>module-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.gwass_impl","title":"<code>gwass_impl = gwass</code>  <code>module-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.monte_carlo_sweep_impl","title":"<code>monte_carlo_sweep_impl = monte_carlo_sweep</code>  <code>module-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep-classes","title":"Classes","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace","title":"<code>ParameterSpace(ranges='auto', names=None, constraint=None)</code>","text":"<p>Represents a parameter space for sweep operations.</p> <p>This class helps define and manage parameter spaces for various sweep strategies, including parameter ranges, constraints, and integration with MeasurementSession.</p> <p>Initialize a parameter space.</p> PARAMETER DESCRIPTION <code>ranges</code> <p>Parameter ranges in one of these formats: - List of (min, max) tuples: [(min1, max1), (min2, max2), ...] - Dict of {name: (min, max)}: {\"x\": (0, 10), \"y\": (-5, 5), ...} - \"auto\" to extract from MeasurementSession</p> <p> TYPE: <code>Union[List[Tuple[float, float]], str, Dict[str, Tuple[float, float]]]</code> DEFAULT: <code>'auto'</code> </p> <code>names</code> <p>Parameter names (required if ranges is a list of tuples)</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>constraint</code> <p>Optional function that takes a dict of parameter values         and returns True if the combination is valid</p> <p> TYPE: <code>Optional[Callable[[Dict[str, float]], bool]]</code> DEFAULT: <code>None</code> </p> Source code in <code>pytestlab/experiments/sweep.py</code> <pre><code>def __init__(self,\n             ranges: Union[List[Tuple[float, float]], str, Dict[str, Tuple[float, float]]] = \"auto\",\n             names: Optional[List[str]] = None,\n             constraint: Optional[Callable[[Dict[str, float]], bool]] = None):\n    \"\"\"\n    Initialize a parameter space.\n\n    Args:\n        ranges: Parameter ranges in one of these formats:\n            - List of (min, max) tuples: [(min1, max1), (min2, max2), ...]\n            - Dict of {name: (min, max)}: {\"x\": (0, 10), \"y\": (-5, 5), ...}\n            - \"auto\" to extract from MeasurementSession\n        names: Parameter names (required if ranges is a list of tuples)\n        constraint: Optional function that takes a dict of parameter values\n                    and returns True if the combination is valid\n    \"\"\"\n    self.ranges = ranges\n    self.names = names or []\n    self.constraint = constraint\n    self._session = None\n\n    # Validate ranges and names\n    if isinstance(ranges, list) and names and len(ranges) != len(names):\n        raise ValueError(\"Number of ranges must match number of parameter names\")\n\n    # Convert dict to list format if provided as dict\n    if isinstance(ranges, dict):\n        self.names = list(ranges.keys())\n        self.ranges = [ranges[name] for name in self.names]\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace-attributes","title":"Attributes","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace.constraint","title":"<code>constraint = constraint</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace.names","title":"<code>names = names or []</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace.ranges","title":"<code>ranges = ranges</code>  <code>instance-attribute</code>","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace-functions","title":"Functions","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace.from_session","title":"<code>from_session(session, constraint=None)</code>  <code>classmethod</code>","text":"<p>Create a ParameterSpace from a MeasurementSession.</p> PARAMETER DESCRIPTION <code>session</code> <p>A MeasurementSession with defined parameters</p> <p> </p> <code>constraint</code> <p>Optional constraint function</p> <p> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ParameterSpace</code> <p>A configured parameter space</p> Source code in <code>pytestlab/experiments/sweep.py</code> <pre><code>@classmethod\ndef from_session(cls, session, constraint=None):\n    \"\"\"\n    Create a ParameterSpace from a MeasurementSession.\n\n    Args:\n        session: A MeasurementSession with defined parameters\n        constraint: Optional constraint function\n\n    Returns:\n        ParameterSpace: A configured parameter space\n    \"\"\"\n    space = cls(\"auto\", constraint=constraint)\n    space._session = session\n\n    # Extract parameter information\n    param_names = []\n    param_ranges = []\n\n    for name, param in session._parameters.items():\n        param_names.append(name)\n        values = param.values\n\n        # Calculate range from values\n        min_val = min(values)\n        max_val = max(values)\n        param_ranges.append((min_val, max_val))\n\n    space.names = param_names\n    space.ranges = param_ranges\n\n    return space\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace.get_parameters","title":"<code>get_parameters()</code>","text":"<p>Get parameter information.</p> RETURNS DESCRIPTION <code>tuple</code> <p>(names, ranges) where: - names is a list of parameter names - ranges is a list of (min, max) tuples</p> Source code in <code>pytestlab/experiments/sweep.py</code> <pre><code>def get_parameters(self):\n    \"\"\"\n    Get parameter information.\n\n    Returns:\n        tuple: (names, ranges) where:\n            - names is a list of parameter names\n            - ranges is a list of (min, max) tuples\n    \"\"\"\n    # If auto, extract from session\n    if self.ranges == \"auto\":\n        if not self._session:\n            raise ValueError(\"'auto' ranges require a MeasurementSession\")\n        return ParameterSpace.from_session(self._session, self.constraint).get_parameters()\n\n    return self.names, self.ranges\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace.is_valid","title":"<code>is_valid(param_values)</code>","text":"<p>Check if a parameter combination is valid according to the constraint.</p> PARAMETER DESCRIPTION <code>param_values</code> <p>Parameter values as a list or dict</p> <p> TYPE: <code>Union[List[float], Dict[str, float]]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if valid, False otherwise</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pytestlab/experiments/sweep.py</code> <pre><code>def is_valid(self, param_values: Union[List[float], Dict[str, float]]) -&gt; bool:\n    \"\"\"\n    Check if a parameter combination is valid according to the constraint.\n\n    Args:\n        param_values: Parameter values as a list or dict\n\n    Returns:\n        bool: True if valid, False otherwise\n    \"\"\"\n    if not self.constraint:\n        return True\n\n    # Convert list to dict if needed\n    if isinstance(param_values, list):\n        param_dict = dict(zip(self.names, param_values))\n    else:\n        param_dict = param_values\n\n    return self.constraint(param_dict)\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep.ParameterSpace.wrap_function","title":"<code>wrap_function(func)</code>","text":"<p>Wrap a function to handle parameter passing and session integration.</p> PARAMETER DESCRIPTION <code>func</code> <p>The measurement function to wrap</p> <p> TYPE: <code>Callable</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A wrapped function that handles parameters appropriately</p> Source code in <code>pytestlab/experiments/sweep.py</code> <pre><code>def wrap_function(self, func: Callable):\n    \"\"\"\n    Wrap a function to handle parameter passing and session integration.\n\n    Args:\n        func: The measurement function to wrap\n\n    Returns:\n        Callable: A wrapped function that handles parameters appropriately\n    \"\"\"\n    # Get parameter information\n    names, _ = self.get_parameters()\n\n    # Define wrapper function for session usage\n    def wrapped_func(*params):\n        # Convert positional params to dict\n        param_dict = dict(zip(names, params))\n\n        # Apply constraint if any\n        if self.constraint and not self.constraint(param_dict):\n            # Return a default value for invalid combinations\n            return float('nan')\n\n        # Call the original function with named parameters\n        return func(**param_dict)\n\n    return wrapped_func\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep.Sweep","title":"<code>Sweep</code>","text":"<p>Dummy Sweep class for documentation compatibility. This is not used in runtime code, but allows mkdocstrings to resolve 'pytestlab.experiments.Sweep' for API docs.</p>"},{"location":"api/experiments/#pytestlab.experiments.sweep-functions","title":"Functions","text":""},{"location":"api/experiments/#pytestlab.experiments.sweep.f_evaluate","title":"<code>f_evaluate(params, f)</code>","text":"Source code in <code>pytestlab/experiments/sweep.py</code> <pre><code>def f_evaluate(params: Tuple[Any, ...], f: Callable[..., Any]) -&gt; Any:\n    return f(*params)\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep.grid_sweep","title":"<code>grid_sweep(param_space=None, points=10)</code>","text":"<p>Apply a grid sweep to a measurement function.</p> PARAMETER DESCRIPTION <code>param_space</code> <p>Parameter space definition, one of: - ParameterSpace object - List of (min, max) tuples - Dict of {name: (min, max)} - \"auto\" to extract from MeasurementSession</p> <p> DEFAULT: <code>None</code> </p> <code>points</code> <p>Points per dimension, either: - Single integer (same for all dimensions) - List of integers (one per dimension)</p> <p> DEFAULT: <code>10</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A decorator that applies a grid sweep</p> Example <p>@grid_sweep({\"voltage\": (0, 10), \"current\": (0, 1)}, 20) def measure(voltage, current):     # Measurement code     return result</p> Source code in <code>pytestlab/experiments/sweep.py</code> <pre><code>def grid_sweep(param_space=None, points=10):\n    \"\"\"\n    Apply a grid sweep to a measurement function.\n\n    Args:\n        param_space: Parameter space definition, one of:\n            - ParameterSpace object\n            - List of (min, max) tuples\n            - Dict of {name: (min, max)}\n            - \"auto\" to extract from MeasurementSession\n        points: Points per dimension, either:\n            - Single integer (same for all dimensions)\n            - List of integers (one per dimension)\n\n    Returns:\n        Callable: A decorator that applies a grid sweep\n\n    Example:\n        @grid_sweep({\"voltage\": (0, 10), \"current\": (0, 1)}, 20)\n        def measure(voltage, current):\n            # Measurement code\n            return result\n\n        # Or with auto parameter extraction from session\n        @session.acquire\n        @grid_sweep(points=15)\n        async def measure(voltage, current, instrument):\n            # Measurement code\n            return result\n\n        # With constraint\n        def valid_region(params):\n            return params[\"voltage\"] &gt; 2 * params[\"current\"]\n\n        @grid_sweep(\n            ParameterSpace({\"voltage\": (0, 10), \"current\": (0, 1)}, constraint=valid_region),\n            points=15\n        )\n        def measure(voltage, current):\n            # Measurement code\n            return result\n    \"\"\"\n    # Handle different param_space types\n    if param_space is None:\n        param_space = \"auto\"\n\n    if not isinstance(param_space, ParameterSpace):\n        param_space = ParameterSpace(param_space)\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            # Handle session as first argument\n            if args and hasattr(args[0], '_parameters') and hasattr(args[0], 'acquire'):\n                session = args[0]\n                local_space = ParameterSpace.from_session(session, param_space.constraint)\n\n                # Create measurement function that closes over the original func\n                def measure_func(**params):\n                    return func(**params, **kwargs)\n\n                # Get parameters and run grid sweep\n                names, ranges = local_space.get_parameters()\n                wrapped_func = local_space.wrap_function(measure_func)\n\n                # Run the original grid_sweep function\n                results = grid_sweep_impl(wrapped_func, ranges, points)\n\n                # Format results if needed\n                return results\n            else:\n                # Standard usage without session\n                if param_space.ranges == \"auto\":\n                    raise ValueError(\"'auto' parameter space requires a MeasurementSession\")\n\n                # Get parameters and run grid sweep\n                names, ranges = param_space.get_parameters()\n                wrapped_func = param_space.wrap_function(func)\n\n                # Run the original grid_sweep function\n                return grid_sweep_impl(wrapped_func, ranges, points)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep.grid_sweep--or-with-auto-parameter-extraction-from-session","title":"Or with auto parameter extraction from session","text":"<p>@session.acquire @grid_sweep(points=15) async def measure(voltage, current, instrument):     # Measurement code     return result</p>"},{"location":"api/experiments/#pytestlab.experiments.sweep.grid_sweep--with-constraint","title":"With constraint","text":"<p>def valid_region(params):     return params[\"voltage\"] &gt; 2 * params[\"current\"]</p> <p>@grid_sweep(     ParameterSpace({\"voltage\": (0, 10), \"current\": (0, 1)}, constraint=valid_region),     points=15 ) def measure(voltage, current):     # Measurement code     return result</p>"},{"location":"api/experiments/#pytestlab.experiments.sweep.gwass","title":"<code>gwass(param_space=None, budget=100, initial_percentage=0.1)</code>","text":"<p>Apply gradient-weighted adaptive stochastic sampling to a measurement function.</p> PARAMETER DESCRIPTION <code>param_space</code> <p>Parameter space definition, one of: - ParameterSpace object - List of (min, max) tuples - Dict of {name: (min, max)} - \"auto\" to extract from MeasurementSession</p> <p> DEFAULT: <code>None</code> </p> <code>budget</code> <p>Total number of function evaluations allowed</p> <p> DEFAULT: <code>100</code> </p> <code>initial_percentage</code> <p>Percentage of budget to use for initial grid</p> <p> DEFAULT: <code>0.1</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A decorator that applies GWASS</p> Example <p>@gwass({\"voltage\": (0, 10), \"current\": (0, 1)}, budget=200) def measure(voltage, current):     # Measurement code     return result</p> Source code in <code>pytestlab/experiments/sweep.py</code> <pre><code>def gwass(param_space=None, budget=100, initial_percentage=0.1):\n    \"\"\"\n    Apply gradient-weighted adaptive stochastic sampling to a measurement function.\n\n    Args:\n        param_space: Parameter space definition, one of:\n            - ParameterSpace object\n            - List of (min, max) tuples\n            - Dict of {name: (min, max)}\n            - \"auto\" to extract from MeasurementSession\n        budget: Total number of function evaluations allowed\n        initial_percentage: Percentage of budget to use for initial grid\n\n    Returns:\n        Callable: A decorator that applies GWASS\n\n    Example:\n        @gwass({\"voltage\": (0, 10), \"current\": (0, 1)}, budget=200)\n        def measure(voltage, current):\n            # Measurement code\n            return result\n\n        # Or with constraint\n        def valid_region(params):\n            # Only accept points where voltage &gt; 2*current\n            return params[\"voltage\"] &gt; 2 * params[\"current\"]\n\n        @gwass(\n            ParameterSpace({\"voltage\": (0, 10), \"current\": (0, 1)}, constraint=valid_region),\n            budget=150\n        )\n        def measure(voltage, current):\n            # Measurement code\n            return result\n    \"\"\"\n    # Handle different param_space types\n    if param_space is None:\n        param_space = \"auto\"\n\n    if not isinstance(param_space, ParameterSpace):\n        param_space = ParameterSpace(param_space)\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            # Handle session as first argument\n            if args and hasattr(args[0], '_parameters') and hasattr(args[0], 'acquire'):\n                session = args[0]\n                local_space = ParameterSpace.from_session(session, param_space.constraint)\n\n                # Create measurement function that closes over the original func\n                def measure_func(**params):\n                    return func(**params, **kwargs)\n\n                # Get parameters and run GWASS\n                names, ranges = local_space.get_parameters()\n                wrapped_func = local_space.wrap_function(measure_func)\n\n                # Run the original GWASS function\n                return gwass_impl(wrapped_func, ranges, budget, initial_percentage)\n            else:\n                # Standard usage without session\n                if param_space.ranges == \"auto\":\n                    raise ValueError(\"'auto' parameter space requires a MeasurementSession\")\n\n                # Get parameters and run GWASS\n                names, ranges = param_space.get_parameters()\n                wrapped_func = param_space.wrap_function(func)\n\n                return gwass_impl(wrapped_func, ranges, budget, initial_percentage)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep.gwass--or-with-constraint","title":"Or with constraint","text":"<p>def valid_region(params):     # Only accept points where voltage &gt; 2*current     return params[\"voltage\"] &gt; 2 * params[\"current\"]</p> <p>@gwass(     ParameterSpace({\"voltage\": (0, 10), \"current\": (0, 1)}, constraint=valid_region),     budget=150 ) def measure(voltage, current):     # Measurement code     return result</p>"},{"location":"api/experiments/#pytestlab.experiments.sweep.monte_carlo_sweep","title":"<code>monte_carlo_sweep(param_space=None, samples=50)</code>","text":"<p>Apply a Monte Carlo sweep to a measurement function.</p> PARAMETER DESCRIPTION <code>param_space</code> <p>Parameter space definition, one of: - ParameterSpace object - List of (min, max) tuples - Dict of {name: (min, max)} - \"auto\" to extract from MeasurementSession</p> <p> DEFAULT: <code>None</code> </p> <code>samples</code> <p>Number of samples, either: - Single integer (total samples) - List of integers (samples per dimension)</p> <p> DEFAULT: <code>50</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A decorator that applies a Monte Carlo sweep</p> Example <p>@monte_carlo_sweep({\"voltage\": (0, 10), \"current\": (0, 1)}, 100) def measure(voltage, current):     # Measurement code     return result</p> Source code in <code>pytestlab/experiments/sweep.py</code> <pre><code>def monte_carlo_sweep(param_space=None, samples=50):\n    \"\"\"\n    Apply a Monte Carlo sweep to a measurement function.\n\n    Args:\n        param_space: Parameter space definition, one of:\n            - ParameterSpace object\n            - List of (min, max) tuples\n            - Dict of {name: (min, max)}\n            - \"auto\" to extract from MeasurementSession\n        samples: Number of samples, either:\n            - Single integer (total samples)\n            - List of integers (samples per dimension)\n\n    Returns:\n        Callable: A decorator that applies a Monte Carlo sweep\n\n    Example:\n        @monte_carlo_sweep({\"voltage\": (0, 10), \"current\": (0, 1)}, 100)\n        def measure(voltage, current):\n            # Measurement code\n            return result\n\n        # With constraint function\n        def valid_region(params):\n            return params[\"voltage\"] &gt; 0.5 and params[\"current\"] &lt; 0.8\n\n        @monte_carlo_sweep(\n            ParameterSpace({\"voltage\": (0, 10), \"current\": (0, 1)}, constraint=valid_region),\n            samples=200\n        )\n        def measure(voltage, current):\n            # Measurement code\n            return result\n    \"\"\"\n    # Handle different param_space types\n    if param_space is None:\n        param_space = \"auto\"\n\n    if not isinstance(param_space, ParameterSpace):\n        param_space = ParameterSpace(param_space)\n\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            # Handle session as first argument\n            if args and hasattr(args[0], '_parameters') and hasattr(args[0], 'acquire'):\n                session = args[0]\n                local_space = ParameterSpace.from_session(session, param_space.constraint)\n\n                # Create measurement function that closes over the original func\n                def measure_func(**params):\n                    return func(**params, **kwargs)\n\n                # Get parameters and run Monte Carlo sweep\n                names, ranges = local_space.get_parameters()\n                wrapped_func = local_space.wrap_function(measure_func)\n\n                # Convert samples to per-dimension if needed\n                samples_list = samples\n                if isinstance(samples, int):\n                    # Equal distribution among parameters\n                    samples_list = [int(samples**(1/len(ranges)))] * len(ranges)\n\n                # Run the original Monte Carlo sweep function\n                return monte_carlo_sweep_impl(wrapped_func, ranges, samples_list)\n            else:\n                # Standard usage without session\n                if param_space.ranges == \"auto\":\n                    raise ValueError(\"'auto' parameter space requires a MeasurementSession\")\n\n                # Get parameters and run Monte Carlo sweep\n                names, ranges = param_space.get_parameters()\n                wrapped_func = param_space.wrap_function(func)\n\n                # Convert samples to per-dimension if needed\n                samples_list = samples\n                if isinstance(samples, int):\n                    # Equal distribution among parameters\n                    samples_list = [int(samples**(1/len(ranges)))] * len(ranges)\n\n                return monte_carlo_sweep_impl(wrapped_func, ranges, samples_list)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/experiments/#pytestlab.experiments.sweep.monte_carlo_sweep--with-constraint-function","title":"With constraint function","text":"<p>def valid_region(params):     return params[\"voltage\"] &gt; 0.5 and params[\"current\"] &lt; 0.8</p> <p>@monte_carlo_sweep(     ParameterSpace({\"voltage\": (0, 10), \"current\": (0, 1)}, constraint=valid_region),     samples=200 ) def measure(voltage, current):     # Measurement code     return result</p>"},{"location":"api/instruments/","title":"Instrument Drivers","text":"<p>This section documents the main instrument driver classes provided by PyTestLab. All drivers support both real and simulated backends, and expose a modern, async-first API.</p>"},{"location":"api/instruments/#core-instrument-classes","title":"Core Instrument Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument","title":"<code>pytestlab.instruments.AutoInstrument</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument-classes","title":"Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument.AutoInstrument","title":"<code>AutoInstrument</code>","text":"<p>A factory class for creating and configuring instrument objects.</p> <p>This class provides a high-level interface to instantiate various types of instruments based on configuration files, instrument types, or other identifiers. It handles the complexities of locating configuration data, selecting the appropriate communication backend (e.g., VISA, simulation), and initializing the correct instrument driver.</p> <p>The primary methods are <code>from_config</code> for creating an instrument from a configuration source and <code>from_type</code> for creating one based on a generic instrument category.</p>"},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument.AutoInstrument-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument.AutoInstrument.from_config","title":"<code>from_config(config_source, *args, serial_number=None, debug_mode=False, simulate=None, backend_type_hint=None, address_override=None, timeout_override_ms=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Initializes an instrument from a configuration source.</p> <p>This is the primary factory method for creating instrument instances. It orchestrates the entire setup process: 1. Loads configuration from a dictionary, a local file, or a CDN URL. 2. Determines whether to run in simulation or live mode. 3. Selects and instantiates the appropriate communication backend (Sim, VISA, Lamb). 4. Instantiates the final instrument driver with the config and backend.</p> <p>Note: This method creates and configures the instrument object but does not establish the connection. The caller must explicitly call <code>await instrument.connect_backend()</code> on the returned object.</p> PARAMETER DESCRIPTION <code>config_source</code> <p>A dictionary containing the configuration, a string            identifier for a CDN/local profile, or a file path.</p> <p> TYPE: <code>Union[str, Dict[str, Any]]</code> </p> <code>serial_number</code> <p>An optional serial number to override the one in the config.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>debug_mode</code> <p>If True, prints detailed logs during the setup process.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>simulate</code> <p>Explicitly enable or disable simulation mode, overriding       environment variables and config settings.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> <code>backend_type_hint</code> <p>Manually specify the backend ('visa' or 'lamb'),                bypassing automatic detection.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>address_override</code> <p>Use a specific communication address, overriding the               one in the config.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>timeout_override_ms</code> <p>Use a specific communication timeout in milliseconds.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Instrument[Any]</code> <p>An initialized instrument object ready to be connected.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the configuration source is a string and the                corresponding file cannot be found.</p> <code>InstrumentConfigurationError</code> <p>If the configuration is invalid or a                           required setting is missing.</p> <code>TypeError</code> <p>If <code>config_source</code> is not a dictionary or a string.</p> Source code in <code>pytestlab/instruments/AutoInstrument.py</code> <pre><code>@classmethod\nasync def from_config(cls: Type[AutoInstrument],\n                config_source: Union[str, Dict[str, Any]],\n                *args,\n                serial_number: Optional[str] = None,\n                debug_mode: bool = False, # For logging during config load\n                simulate: Optional[bool] = None,\n                backend_type_hint: Optional[str] = None,\n                address_override: Optional[str] = None,\n                timeout_override_ms: Optional[int] = None\n               ) -&gt; Instrument[Any]: # Returns an instance of a subclass of Instrument\n    \"\"\"Initializes an instrument from a configuration source.\n\n    This is the primary factory method for creating instrument instances. It\n    orchestrates the entire setup process:\n    1. Loads configuration from a dictionary, a local file, or a CDN URL.\n    2. Determines whether to run in simulation or live mode.\n    3. Selects and instantiates the appropriate communication backend (Sim, VISA, Lamb).\n    4. Instantiates the final instrument driver with the config and backend.\n\n    Note: This method creates and configures the instrument object but does not\n    establish the connection. The caller must explicitly call `await\n    instrument.connect_backend()` on the returned object.\n\n    Args:\n        config_source: A dictionary containing the configuration, a string\n                       identifier for a CDN/local profile, or a file path.\n        serial_number: An optional serial number to override the one in the config.\n        debug_mode: If True, prints detailed logs during the setup process.\n        simulate: Explicitly enable or disable simulation mode, overriding\n                  environment variables and config settings.\n        backend_type_hint: Manually specify the backend ('visa' or 'lamb'),\n                           bypassing automatic detection.\n        address_override: Use a specific communication address, overriding the\n                          one in the config.\n        timeout_override_ms: Use a specific communication timeout in milliseconds.\n\n    Returns:\n        An initialized instrument object ready to be connected.\n\n    Raises:\n        FileNotFoundError: If the configuration source is a string and the\n                           corresponding file cannot be found.\n        InstrumentConfigurationError: If the configuration is invalid or a\n                                      required setting is missing.\n        TypeError: If `config_source` is not a dictionary or a string.\n    \"\"\"\n    # Support serial_number as positional second argument\n    if len(args) &gt; 0 and isinstance(args[0], str):\n        serial_number = args[0]\n\n    config_data: Dict[str, Any]\n\n    # Step 1: Load configuration data from the provided source\n    config_model: PydanticInstrumentConfig\n    if isinstance(config_source, PydanticInstrumentConfig):\n        config_model = config_source\n        config_data = config_model.model_dump(mode='python')\n    elif isinstance(config_source, dict):\n        config_data = config_source\n        config_model = load_profile(config_data)\n    elif isinstance(config_source, str):\n        try:\n            # Try fetching from the CDN first\n            config_data = await cls.get_config_from_cdn(config_source)\n            if debug_mode: print(f\"Successfully loaded configuration for '{config_source}' from CDN.\")\n        except FileNotFoundError:\n            try:\n                # Fallback to local file system if not found on CDN\n                config_data = await cls.get_config_from_local(config_source)\n                if debug_mode: print(f\"Successfully loaded configuration for '{config_source}' from local.\")\n            except FileNotFoundError:\n                # If not found in either location, raise an error\n                raise FileNotFoundError(f\"Configuration '{config_source}' not found in CDN or local paths.\")\n        config_model = load_profile(config_data)\n    else:\n        raise TypeError(\"config_source must be a file path (str), a dict, or an InstrumentConfig object.\")\n\n    # Override the serial number in the config if one is provided as an argument\n    if serial_number is not None and hasattr(config_model, 'serial_number'):\n        config_model.serial_number = serial_number # type: ignore\n\n    backend_instance: AsyncInstrumentIO\n\n    # Step 2: Determine the final simulation mode based on a clear priority\n    final_simulation_mode: bool\n    if simulate is not None:\n        # Highest priority: explicit argument to the function\n        final_simulation_mode = simulate\n        if debug_mode: print(f\"Simulation mode explicitly set to {final_simulation_mode} by argument.\")\n    else:\n        # Second priority: environment variable\n        env_simulate = os.getenv(\"PYTESTLAB_SIMULATE\")\n        if env_simulate is not None:\n            final_simulation_mode = env_simulate.lower() in ('true', '1', 'yes')\n            if debug_mode: print(f\"Simulation mode set to {final_simulation_mode} by PYTESTLAB_SIMULATE environment variable.\")\n        else:\n            # Lowest priority: default to False\n            final_simulation_mode = False\n            if debug_mode: print(f\"Simulation mode defaulted to {final_simulation_mode} (no explicit argument or PYTESTLAB_SIMULATE).\")\n\n    # Step 3: Determine the actual communication address and timeout\n    actual_address: Optional[str]\n    if address_override is not None:\n        # Argument override has the highest priority for address\n        actual_address = address_override\n        if debug_mode: print(f\"Address overridden to '{actual_address}'.\")\n    else:\n        # Otherwise, get the address from the configuration data\n        actual_address = getattr(config_model, 'address', getattr(config_model, 'resource_name', None))\n        if debug_mode: print(f\"Address from config: '{actual_address}'.\")\n\n    actual_timeout: int\n    default_communication_timeout_ms = 30000 # Default if not in override or config\n    if timeout_override_ms is not None:\n        actual_timeout = timeout_override_ms\n        if debug_mode: print(f\"Timeout overridden to {actual_timeout}ms.\")\n    else:\n        # Assuming 'communication.timeout_ms' or 'communication_timeout_ms' might exist\n        # Prefer 'communication_timeout_ms' as per previous logic if 'communication' object isn't standard\n        timeout_from_config = getattr(config_model, 'communication_timeout_ms', None)\n        if hasattr(config_model, 'communication') and hasattr(config_model.communication, 'timeout_ms'): # type: ignore\n             timeout_from_config = config_model.communication.timeout_ms # type: ignore\n\n        if isinstance(timeout_from_config, int) and timeout_from_config &gt; 0:\n            actual_timeout = timeout_from_config\n            if debug_mode: print(f\"Timeout from config: {actual_timeout}ms.\")\n        else:\n            actual_timeout = default_communication_timeout_ms\n            if debug_mode: print(f\"Warning: Invalid or missing timeout in config, using default {actual_timeout}ms.\")\n\n    if not isinstance(actual_timeout, int) or actual_timeout &lt;= 0: # Final safety check\n        actual_timeout = default_communication_timeout_ms\n        if debug_mode: print(f\"Warning: Corrected invalid timeout to default {actual_timeout}ms.\")\n\n\n    # Step 4: Instantiate the appropriate backend based on the mode and configuration\n    if final_simulation_mode:\n        # Helper to resolve sim profile path\n        def resolve_sim_profile_path(profile_key_or_path: str) -&gt; str:\n            # 1. User override in ~/.pytestlab/profiles\n            user_profile = os.path.expanduser(os.path.join(\"~/.pytestlab/profiles\", profile_key_or_path + \".yaml\"))\n            if os.path.exists(user_profile):\n                return user_profile\n            # 2. User sim_profiles (legacy)\n            user_sim_profile = os.path.expanduser(os.path.join(\"~/.pytestlab/sim_profiles\", profile_key_or_path + \".yaml\"))\n            if os.path.exists(user_sim_profile):\n                return user_sim_profile\n            # 3. Package profile\n            import pytestlab as ptl\n            pkg_profile = os.path.join(os.path.dirname(ptl.__file__), \"profiles\", profile_key_or_path + \".yaml\")\n            if os.path.exists(pkg_profile):\n                return pkg_profile\n            # 4. Direct path\n            if os.path.exists(profile_key_or_path):\n                return profile_key_or_path\n            raise FileNotFoundError(f\"Simulation profile not found for '{profile_key_or_path}'\")\n\n        device_model_str = getattr(config_model, \"model\", \"GenericSimulatedModel\")\n        if isinstance(config_source, str):\n            sim_profile_path = os.path.abspath(resolve_sim_profile_path(config_source))\n            if debug_mode:\n                print(f\"Resolved sim profile path: {sim_profile_path}\")\n        else:\n            # Write dict config to a temp file\n            with tempfile.NamedTemporaryFile(\"w\", suffix=\".yaml\", delete=False) as tf:\n                yaml.dump(config_data, tf)\n                sim_profile_path = os.path.abspath(tf.name)\n            if debug_mode:\n                print(f\"Wrote temp sim profile: {sim_profile_path}\")\n        backend_instance = SimBackendV2(\n            profile_path=sim_profile_path,\n            model=device_model_str,\n            timeout_ms=actual_timeout,\n        )\n        if debug_mode:\n            print(\n                f\"Using SimBackendV2 for {device_model_str} with timeout {actual_timeout}ms. Profile: {sim_profile_path}\"\n            )\n    else:\n        # For live hardware, determine the backend type (VISA or Lamb)\n        if backend_type_hint:\n            # Explicit hint overrides any inference\n            chosen_backend_type = backend_type_hint.lower()\n            if debug_mode: print(f\"Backend type hint provided: '{chosen_backend_type}'.\")\n        elif actual_address and \"LAMB::\" in actual_address.upper():\n            # Infer 'lamb' backend from the address format\n            chosen_backend_type = 'lamb'\n            if debug_mode: print(f\"Inferred backend type: 'lamb' from address '{actual_address}'.\")\n        elif actual_address:\n            # Infer 'visa' for any other address type\n            chosen_backend_type = 'visa'\n            if debug_mode: print(f\"Inferred backend type: 'visa' from address '{actual_address}'.\")\n        else:\n            # Default to 'lamb' if no address is provided (e.g., for remote discovery)\n            chosen_backend_type = 'lamb'\n            if debug_mode: print(f\"Defaulting backend type to 'lamb' (no address present).\")\n\n        if chosen_backend_type == 'visa':\n            if actual_address is None:\n                raise InstrumentConfigurationError(\n                    config_source, \"Missing address/resource_name for VISA backend.\"\n                )\n            backend_instance = AsyncVisaBackend(address=actual_address, timeout_ms=actual_timeout)\n            if debug_mode: print(f\"Using AsyncVisaBackend for '{actual_address}' with timeout {actual_timeout}ms.\")\n        elif chosen_backend_type == 'lamb':\n            lamb_server_url = getattr(config_model, 'lamb_url', 'http://lamb-server:8000')\n            if actual_address:\n                backend_instance = AsyncLambBackend(address=actual_address, url=lamb_server_url, timeout_ms=actual_timeout)\n            elif hasattr(config_model, \"model\") and hasattr(config_model, \"serial_number\"):\n                backend_instance = AsyncLambBackend(\n                    address=None,\n                    url=lamb_server_url,\n                    timeout_ms=actual_timeout,\n                    model_name=getattr(config_model, \"model\"),\n                    serial_number=getattr(config_model, \"serial_number\")\n                )\n            else:\n                raise InstrumentConfigurationError(\n                    config_source,\n                    \"Lamb backend requires either an address or both model and serial_number in the config.\",\n                )\n            if debug_mode:\n                print(f\"Using AsyncLambBackend for model='{getattr(config_model, 'model', None)}', serial='{getattr(config_model, 'serial_number', None)}' via '{lamb_server_url}' with timeout {actual_timeout}ms.\")\n        else:\n            raise InstrumentConfigurationError(\n                config_source, f\"Unsupported backend_type '{chosen_backend_type}'.\"\n            )\n\n    # Step 5: Instantiate the final instrument driver class\n    device_type_str: str = config_model.device_type\n    instrument_class_to_init = cls._instrument_mapping.get(device_type_str.lower())\n\n    if instrument_class_to_init is None:\n        raise InstrumentConfigurationError(\n            config_source,\n            f\"Unknown device_type: '{device_type_str}'. No registered instrument class.\",\n        )\n\n    # The instrument's constructor receives the parsed configuration model and the\n    # instantiated backend.\n    instrument = instrument_class_to_init(config=config_model, backend=backend_instance)\n\n    if debug_mode:\n        print(f\"Instantiated {instrument_class_to_init.__name__} with {type(backend_instance).__name__}.\")\n        print(\"Note: Backend connection is not established by __init__. Call 'await instrument.connect_backend()' explicitly.\")\n\n    return instrument\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument.AutoInstrument.from_type","title":"<code>from_type(instrument_type, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initializes a specific instrument driver based on its type string.</p> <p>This factory method uses a mapping to find the appropriate instrument class for a given <code>instrument_type</code> string (e.g., 'oscilloscope') and passes any additional arguments to its constructor.</p> PARAMETER DESCRIPTION <code>instrument_type</code> <p>The type of the instrument to initialize.</p> <p> TYPE: <code>str</code> </p> <code>*args</code> <p>Positional arguments to pass to the instrument's constructor.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments to pass to the instrument's constructor.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Instrument</code> <p>An instance of a specific Instrument subclass.</p> RAISES DESCRIPTION <code>InstrumentConfigurationError</code> <p>If the instrument_type is not recognized.</p> Source code in <code>pytestlab/instruments/AutoInstrument.py</code> <pre><code>@classmethod\ndef from_type(cls: Type[AutoInstrument], instrument_type: str, *args: Any, **kwargs: Any) -&gt; Instrument:\n    \"\"\"Initializes a specific instrument driver based on its type string.\n\n    This factory method uses a mapping to find the appropriate instrument class\n    for a given `instrument_type` string (e.g., 'oscilloscope') and passes\n    any additional arguments to its constructor.\n\n    Args:\n        instrument_type: The type of the instrument to initialize.\n        *args: Positional arguments to pass to the instrument's constructor.\n        **kwargs: Keyword arguments to pass to the instrument's constructor.\n\n    Returns:\n        An instance of a specific Instrument subclass.\n\n    Raises:\n        InstrumentConfigurationError: If the instrument_type is not recognized.\n    \"\"\"\n    instrument_class = cls._instrument_mapping.get(instrument_type.lower())\n    if instrument_class:\n        return instrument_class(*args, **kwargs) # type: ignore\n    else:\n        raise InstrumentConfigurationError(\n            instrument_type, f\"Unknown instrument type: {instrument_type}\"\n        )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument.AutoInstrument.get_config_from_cdn","title":"<code>get_config_from_cdn(identifier)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Fetches an instrument configuration from a CDN with local caching.</p> <p>This method attempts to retrieve a configuration file from a predefined CDN URL. For efficiency, it caches the configuration locally. If a cached version is available, it's used directly. Otherwise, the file is downloaded, cached for future use, and then returned.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>The unique identifier for the configuration, which is         used to construct the CDN URL (e.g., 'keysight/dsox1204g').</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The loaded configuration data as a dictionary.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the configuration is not found on the CDN.</p> <code>InstrumentConfigurationError</code> <p>If the downloaded configuration is invalid.</p> Source code in <code>pytestlab/instruments/AutoInstrument.py</code> <pre><code>@classmethod\nasync def get_config_from_cdn(cls: Type[AutoInstrument], identifier: str) -&gt; Dict[str, Any]:\n    \"\"\"Fetches an instrument configuration from a CDN with local caching.\n\n    This method attempts to retrieve a configuration file from a predefined\n    CDN URL. For efficiency, it caches the configuration locally. If a cached\n    version is available, it's used directly. Otherwise, the file is\n    downloaded, cached for future use, and then returned.\n\n    Args:\n        identifier: The unique identifier for the configuration, which is\n                    used to construct the CDN URL (e.g., 'keysight/dsox1204g').\n\n    Returns:\n        The loaded configuration data as a dictionary.\n\n    Raises:\n        FileNotFoundError: If the configuration is not found on the CDN.\n        InstrumentConfigurationError: If the downloaded configuration is invalid.\n    \"\"\"\n    import pytestlab as ptl\n\n    cache_dir = os.path.join(os.path.dirname(ptl.__file__), \"cache\", \"configs\")\n    os.makedirs(cache_dir, exist_ok=True)\n\n    cache_file = os.path.join(cache_dir, f\"{identifier}.yaml\")\n\n    # Check for a cached version of the configuration first\n    if os.path.exists(cache_file):\n        try:\n            async with aiofiles.open(cache_file, 'r') as f:\n                content = await f.read()\n                loaded_config = yaml.safe_load(content)\n                # Validate the cached content; if corrupt, proceed to download\n                if not isinstance(loaded_config, dict):\n                    os.remove(cache_file)\n                    raise InstrumentConfigurationError(\n                        identifier, \"Cached config is not a valid dictionary.\"\n                    )\n                return loaded_config\n        except Exception as e:\n            # If reading the cache fails, remove the broken file and fetch from CDN\n            print(f\"Cache read failed for {identifier}: {e}. Fetching from CDN.\")\n            if os.path.exists(cache_file):\n                try:\n                    os.remove(cache_file)\n                except OSError:\n                    pass\n\n    # If not cached, fetch from the official CDN\n    url = f\"https://pytestlab.org/config/{identifier}.yaml\"\n    async with httpx.AsyncClient() as client:\n        try:\n            response = await client.get(url, timeout=10)\n            response.raise_for_status()  # Raise an exception for bad status codes\n\n            config_text = response.text\n            loaded_config = yaml.safe_load(config_text)\n            if not isinstance(loaded_config, dict):\n                raise InstrumentConfigurationError(\n                    identifier,\n                    f\"CDN config for {identifier} is not a valid dictionary.\",\n                )\n\n            # Cache the newly downloaded configuration\n            async with aiofiles.open(cache_file, 'w') as f:\n                await f.write(config_text)\n\n            return loaded_config\n        except httpx.HTTPStatusError as http_err:\n            # Handle HTTP errors, specifically 404 for not found\n            if http_err.response.status_code == 404:\n                 raise FileNotFoundError(f\"Configuration file not found at {url} (HTTP 404).\") from http_err\n            else:\n                 raise FileNotFoundError(f\"Failed to fetch configuration from CDN ({url}): HTTP {http_err.response.status_code}\") from http_err\n        except httpx.RequestError as e:\n            # Handle network-related errors\n            raise FileNotFoundError(f\"Failed to fetch configuration from CDN ({url}): {str(e)}\") from e\n        except yaml.YAMLError as ye:\n            # Handle errors in parsing the YAML content\n            raise InstrumentConfigurationError(\n                identifier, f\"Error parsing YAML from CDN for {identifier}: {ye}\"\n            ) from ye\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument.AutoInstrument.get_config_from_local","title":"<code>get_config_from_local(identifier, normalized_identifier=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Loads an instrument configuration from the local filesystem.</p> <p>This method searches for a configuration file in two primary locations: 1. A built-in 'profiles' directory within the PyTestLab package. 2. A direct file path provided by the user.</p> PARAMETER DESCRIPTION <code>identifier</code> <p>The identifier for the profile (e.g., 'keysight/dsox1204g')         or a direct path to a .yaml or .json file.</p> <p> TYPE: <code>str</code> </p> <code>normalized_identifier</code> <p>A pre-normalized version of the identifier.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>The loaded configuration data as a dictionary.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If no configuration file can be found at any of the                searched locations.</p> <code>InstrumentConfigurationError</code> <p>If the file is found but is not a valid                           YAML/JSON dictionary.</p> Source code in <code>pytestlab/instruments/AutoInstrument.py</code> <pre><code>@classmethod\nasync def get_config_from_local(cls: Type[AutoInstrument], identifier: str, normalized_identifier: Optional[str] = None) -&gt; Dict[str, Any]:\n    \"\"\"Loads an instrument configuration from the local filesystem.\n\n    This method searches for a configuration file in two primary locations:\n    1. A built-in 'profiles' directory within the PyTestLab package.\n    2. A direct file path provided by the user.\n\n    Args:\n        identifier: The identifier for the profile (e.g., 'keysight/dsox1204g')\n                    or a direct path to a .yaml or .json file.\n        normalized_identifier: A pre-normalized version of the identifier.\n\n    Returns:\n        The loaded configuration data as a dictionary.\n\n    Raises:\n        FileNotFoundError: If no configuration file can be found at any of the\n                           searched locations.\n        InstrumentConfigurationError: If the file is found but is not a valid\n                                      YAML/JSON dictionary.\n    \"\"\"\n    import pytestlab as ptl\n\n    norm_id = normalized_identifier if normalized_identifier is not None else os.path.normpath(identifier)\n\n    current_file_directory = os.path.dirname(ptl.__file__)\n    preset_path = os.path.join(current_file_directory, \"profiles\", norm_id + '.yaml')\n\n    # Determine the correct file path to load from\n    path_to_try: Optional[str] = None\n    if os.path.exists(preset_path):\n        # First, check for a built-in profile matching the identifier\n        path_to_try = preset_path\n    elif os.path.exists(identifier) and (identifier.endswith('.yaml') or identifier.endswith('.json')):\n        # Next, check if the identifier is a direct path to an existing file\n        path_to_try = identifier\n\n    if path_to_try:\n        try:\n            async with aiofiles.open(path_to_try, 'r') as file:\n                content = await file.read()\n                loaded_config = yaml.safe_load(content)\n                if not isinstance(loaded_config, dict):\n                    raise InstrumentConfigurationError(\n                        identifier,\n                        f\"Local config file '{path_to_try}' did not load as a dictionary.\",\n                    )\n                return loaded_config\n        except yaml.YAMLError as ye:\n            raise InstrumentConfigurationError(\n                identifier,\n                f\"Error parsing YAML from local file '{path_to_try}': {ye}\",\n            ) from ye\n        except Exception as e:\n            raise FileNotFoundError(f\"Error reading local config file '{path_to_try}': {e}\") from e\n\n    raise FileNotFoundError(f\"No configuration found for identifier '{identifier}' in local paths.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument.AutoInstrument.register_instrument","title":"<code>register_instrument(instrument_type, instrument_class)</code>  <code>classmethod</code>","text":"<p>Dynamically registers a new custom instrument class.</p> <p>This allows users to extend PyTestLab with their own instrument drivers. Once registered, the new instrument type can be used with the factory methods like <code>from_config</code> and <code>from_type</code>.</p> PARAMETER DESCRIPTION <code>instrument_type</code> <p>The string identifier for the new instrument type              (e.g., 'my_custom_scope'). This is case-insensitive.</p> <p> TYPE: <code>str</code> </p> <code>instrument_class</code> <p>The class object that implements the instrument driver.               It must be a subclass of <code>pytestlab.Instrument</code>.</p> <p> TYPE: <code>Type[Instrument[Any]]</code> </p> RAISES DESCRIPTION <code>InstrumentConfigurationError</code> <p>If the instrument type name is already                           in use or if the provided class is not a                           valid subclass of <code>Instrument</code>.</p> Source code in <code>pytestlab/instruments/AutoInstrument.py</code> <pre><code>@classmethod\ndef register_instrument(cls: Type[AutoInstrument], instrument_type: str, instrument_class: Type[Instrument[Any]]) -&gt; None:\n    \"\"\"Dynamically registers a new custom instrument class.\n\n    This allows users to extend PyTestLab with their own instrument drivers.\n    Once registered, the new instrument type can be used with the factory\n    methods like `from_config` and `from_type`.\n\n    Args:\n        instrument_type: The string identifier for the new instrument type\n                         (e.g., 'my_custom_scope'). This is case-insensitive.\n        instrument_class: The class object that implements the instrument driver.\n                          It must be a subclass of `pytestlab.Instrument`.\n\n    Raises:\n        InstrumentConfigurationError: If the instrument type name is already\n                                      in use or if the provided class is not a\n                                      valid subclass of `Instrument`.\n    \"\"\"\n    type_key = instrument_type.lower() \n    if type_key in cls._instrument_mapping:\n        raise InstrumentConfigurationError(\n            instrument_type,\n            f\"Instrument type '{instrument_type}' already registered with class {cls._instrument_mapping[type_key].__name__}\",\n        )\n    if not issubclass(instrument_class, Instrument):\n        raise InstrumentConfigurationError(\n            instrument_type,\n            f\"Cannot register class {instrument_class.__name__}. It must be a subclass of Instrument.\",\n        )\n    cls._instrument_mapping[type_key] = instrument_class\n    # Consider using a logger if available, instead of print\n    print(f\"Instrument type '{instrument_type}' registered with class {instrument_class.__name__}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.AutoInstrument-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.Instrument","title":"<code>pytestlab.instruments.Instrument(config, backend, **kwargs)</code>","text":"<p>               Bases: <code>Generic[ConfigType]</code></p> <p>Base class for all instrument drivers.</p> <p>This class provides the core functionality for interacting with an instrument through a standardized, asynchronous interface. It handles command sending, querying, error checking, and logging. It is designed to be subclassed for specific instrument types (e.g., Oscilloscope, PowerSupply).</p> <p>The <code>Instrument</code> class is generic and typed with <code>ConfigType</code>, which allows each subclass to specify its own Pydantic configuration model.</p> ATTRIBUTE DESCRIPTION <code>config</code> <p>The Pydantic configuration model instance for this                  instrument.</p> <p> TYPE: <code>ConfigType</code> </p> <code>_backend</code> <p>The communication backend used to interact                           with the hardware or simulation.</p> <p> TYPE: <code>AsyncInstrumentIO</code> </p> <code>_command_log</code> <p>A log of all commands sent and                                  responses received.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p> <code>_logger</code> <p>The logger instance for this instrument.</p> <p> TYPE: <code>Any</code> </p> <p>Initialize the Instrument class.</p> PARAMETER DESCRIPTION <code>config</code> <p>Configuration for the instrument.</p> <p> TYPE: <code>ConfigType</code> </p> <code>backend</code> <p>The communication backend instance.</p> <p> TYPE: <code>AsyncInstrumentIO</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO\n    \"\"\"\n    Initialize the Instrument class.\n\n    Args:\n        config (ConfigType): Configuration for the instrument.\n        backend (AsyncInstrumentIO): The communication backend instance.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    if not isinstance(config, InstrumentConfig): # Check against the bound base\n        raise InstrumentConfigurationError(\n            self.__class__.__name__,\n            f\"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.\",\n        )\n\n    self.config = config\n    self._backend = backend # This will be an AsyncInstrumentIO instance\n    self._command_log = []\n\n    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__\n    self._logger = get_logger(logger_name)\n\n    self._logger.info(f\"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.Instrument.config","title":"<code>config = config</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Instrument-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.Instrument.clear_status","title":"<code>clear_status()</code>  <code>async</code>","text":"<p>Clears the instrument's status registers and error queue (*CLS).</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def clear_status(self) -&gt; None:\n    \"\"\"\n    Clears the instrument's status registers and error queue (*CLS).\n    \"\"\"\n    await self._send_command(\"*CLS\", skip_check=True)\n    self._logger.debug(\"Status registers and error queue cleared (*CLS).\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the connection to the instrument via the backend.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the connection to the instrument via the backend.\"\"\"\n    try:\n        model_name_for_logger = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__\n        self._logger.info(f\"Instrument '{model_name_for_logger}': Closing connection.\")\n        await self._backend.close() # Changed to use close as per AsyncInstrumentIO\n        self._logger.info(f\"Instrument '{model_name_for_logger}': Connection closed.\")\n    except Exception as e:\n        self._logger.error(f\"Instrument '{model_name_for_logger}': Error during backend close: {e}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.connect_backend","title":"<code>connect_backend()</code>  <code>async</code>","text":"<p>Establishes the connection to the instrument via the backend.</p> <p>This method must be called after the instrument is instantiated to open the communication channel. It delegates the connection logic to the underlying backend.</p> RAISES DESCRIPTION <code>InstrumentConnectionError</code> <p>If the backend fails to connect.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def connect_backend(self) -&gt; None:\n    \"\"\"Establishes the connection to the instrument via the backend.\n\n    This method must be called after the instrument is instantiated to open\n    the communication channel. It delegates the connection logic to the\n    underlying backend.\n\n    Raises:\n        InstrumentConnectionError: If the backend fails to connect.\n    \"\"\"\n    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__\n    try:\n        await self._backend.connect()\n        self._logger.info(f\"Instrument '{logger_name}': Backend connected.\")\n    except Exception as e:\n        self._logger.error(f\"Instrument '{logger_name}': Failed to connect backend: {e}\")\n        if hasattr(self._backend, 'disconnect'): # Check if disconnect is available (it should be for AsyncInstrumentIO)\n            try:\n                await self._backend.disconnect()\n            except Exception as disc_e:\n                self._logger.error(f\"Instrument '{logger_name}': Error disconnecting backend during failed connect: {disc_e}\")\n        raise InstrumentConnectionError(\n            instrument=logger_name, message=f\"Failed to connect backend: {e}\"\n        ) from e\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.from_config","title":"<code>from_config(config, debug_mode=False)</code>  <code>classmethod</code>","text":"Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>@classmethod\ndef from_config(cls: Type[Instrument], config: InstrumentConfig, debug_mode: bool = False) -&gt; Instrument:\n    # This method will likely need significant changes to support async backends.\n    # For now, it's a placeholder and might not work correctly with async backends.\n    # It should ideally accept an async_mode flag or similar to determine backend type.\n    if not isinstance(config, InstrumentConfig):\n        raise InstrumentConfigurationError(\n            cls.__name__, \"from_config expects an InstrumentConfig object.\"\n        )\n    # The backend instantiation is missing here and is crucial.\n    # This will be handled by AutoInstrument.from_config later.\n    raise NotImplementedError(\n        \"from_config needs to be updated for async backend instantiation.\"\n    )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.get_all_errors","title":"<code>get_all_errors()</code>  <code>async</code>","text":"<p>Reads and clears all errors currently present in the instrument's error queue.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def get_all_errors(self) -&gt; TypingList[Tuple[int, str]]:\n    \"\"\"\n    Reads and clears all errors currently present in the instrument's error queue.\n    \"\"\"\n    errors: TypingList[Tuple[int, str]] = []\n    max_errors_to_read = 50\n    for i in range(max_errors_to_read):\n        try:\n            code, message = await self.get_error()\n        except InstrumentCommunicationError as e:\n            self._logger.debug(f\"Communication error while reading error queue (iteration {i+1}): {e}\")\n            if errors:\n                 self._logger.debug(f\"Returning errors read before communication failure: {errors}\")\n            return errors\n\n        if code == 0:\n            break\n        errors.append((code, message))\n        if code == -350:\n             self._logger.debug(\"Error queue overflow (-350) detected. Stopping read.\")\n             break\n    else:\n        self._logger.debug(f\"Warning: Read {max_errors_to_read} errors without reaching 'No error'. \"\n                  \"Error queue might still contain errors or be in an unexpected state.\")\n\n    if not errors:\n        self._logger.debug(\"No errors found in instrument queue.\")\n    else:\n         self._logger.debug(f\"Retrieved {len(errors)} error(s) from queue: {errors}\")\n    return errors\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.get_communication_timeout","title":"<code>get_communication_timeout()</code>  <code>async</code>","text":"<p>Gets the communication timeout from the backend.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def get_communication_timeout(self) -&gt; int:\n    \"\"\"Gets the communication timeout from the backend.\"\"\"\n    timeout = await self._backend.get_timeout()\n    self._logger.debug(f\"Communication timeout retrieved from backend: {timeout} ms.\")\n    return timeout\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.get_error","title":"<code>get_error()</code>  <code>async</code>","text":"<p>Reads and clears the oldest error from the instrument's error queue.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def get_error(self) -&gt; Tuple[int, str]:\n    \"\"\"\n    Reads and clears the oldest error from the instrument's error queue.\n    \"\"\"\n    response = (await self._query(\"SYSTem:ERRor?\")).strip()\n    try:\n        code_str, msg_part = response.split(',', 1)\n        code = int(code_str)\n        message = msg_part.strip().strip('\"')\n    except (ValueError, IndexError) as e:\n        self._logger.debug(f\"Warning: Unexpected error response format: '{response}'. Raising error.\")\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=\"SYSTem:ERRor?\",\n            message=f\"Could not parse error response: '{response}'\",\n        ) from e\n\n    if code != 0:\n         self._logger.debug(f\"Instrument Error Query: Code={code}, Message='{message}'\")\n    return code, message\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.get_scpi_version","title":"<code>get_scpi_version()</code>  <code>async</code>","text":"<p>Queries the version of the SCPI standard the instrument complies with.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def get_scpi_version(self) -&gt; str:\n    \"\"\"\n    Queries the version of the SCPI standard the instrument complies with.\n    \"\"\"\n    response = (await self._query(\"SYSTem:VERSion?\")).strip()\n    self._logger.debug(f\"SCPI Version reported: {response}\")\n    return response\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.health_check","title":"<code>health_check()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Performs a basic health check of the instrument.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>@abstractmethod\nasync def health_check(self) -&gt; HealthReport: # Type hint HealthReport\n    \"\"\"Performs a basic health check of the instrument.\"\"\"\n    # Base implementation could try IDN and error queue check\n    # report = HealthReport() # Initialize HealthReport\n    # try:\n    #     report.instrument_idn = await self.id() # Ensure await for async calls\n    #     instrument_errors = await self.get_all_errors() # Ensure await for async calls\n    #     if instrument_errors:\n    #         report.warnings.extend([f\"Stored Error: {code} - {msg}\" for code, msg in instrument_errors])\n    #\n    #     if not report.errors and not report.warnings:\n    #          report.status = HealthStatus.OK\n    #     elif report.warnings and not report.errors:\n    #          report.status = HealthStatus.WARNING\n    #     else: # if errors are present\n    #          report.status = HealthStatus.ERROR\n    #\n    # except Exception as e:\n    #     report.status = HealthStatus.ERROR\n    #     report.errors.append(f\"Health check failed during IDN/Error Query: {str(e)}\")\n    # return report\n    pass # Replace with actual base implementation\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.id","title":"<code>id()</code>  <code>async</code>","text":"<p>Query the instrument for its identification string (*IDN?).</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def id(self) -&gt; str:\n    \"\"\"\n    Query the instrument for its identification string (*IDN?).\n    \"\"\"\n    name = await self._query(\"*IDN?\")\n    self._logger.debug(f\"Connected to {name}\")\n    return name\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.lock_panel","title":"<code>lock_panel(lock=True)</code>  <code>async</code>","text":"<p>Locks or unlocks the front panel of the instrument.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def lock_panel(self, lock: bool = True) -&gt; None:\n    \"\"\"\n    Locks or unlocks the front panel of the instrument.\n    \"\"\"\n    if lock:\n        await self._send_command(\":SYSTem:LOCK\")\n    else:\n        await self._send_command(\":SYSTem:LOCal\")\n    self._logger.debug(f\"Panel {'locked' if lock else 'unlocked (local control enabled)'}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.requires","title":"<code>requires(requirement)</code>  <code>classmethod</code>","text":"<p>Decorator to specify method requirements based on instrument configuration.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>@classmethod\ndef requires(cls, requirement: str) -&gt; Callable:\n    \"\"\"\n    Decorator to specify method requirements based on instrument configuration.\n    \"\"\"\n    def decorator(func: Callable) -&gt; Callable:\n        def wrapped_func(self: Instrument, *args: Any, **kwargs: Any) -&gt; Any:\n            if not hasattr(self.config, 'requires') or not callable(self.config.requires):\n                raise InstrumentConfigurationError(\n                    self.config.model,\n                    \"Config object missing 'requires' method for decorator.\",\n                )\n\n            if self.config.requires(requirement):\n                return func(self, *args, **kwargs)\n            else:\n                raise InstrumentConfigurationError(\n                    self.config.model,\n                    f\"Method '{func.__name__}' requires '{requirement}', which is not available for this instrument model/configuration.\",\n                )\n        return wrapped_func\n    return decorator\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.reset","title":"<code>reset()</code>  <code>async</code>","text":"<p>Reset the instrument to its default settings (*RST).</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def reset(self) -&gt; None:\n    \"\"\"Reset the instrument to its default settings (*RST).\"\"\"\n    await self._send_command(\"*RST\")\n    self._logger.debug(\"Instrument reset to default settings (*RST).\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.run_self_test","title":"<code>run_self_test(full_test=True)</code>  <code>async</code>","text":"<p>Executes the instrument's internal self-test routine (*TST?) and reports result.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def run_self_test(self, full_test: bool = True) -&gt; str:\n    \"\"\"\n    Executes the instrument's internal self-test routine (*TST?) and reports result.\n    \"\"\"\n    if not full_test:\n         self._logger.debug(\"Note: `full_test=False` currently ignored, running standard *TST? self-test.\")\n\n    self._logger.debug(\"Running self-test (*TST?)...\")\n    try:\n         result_str = await self._query(\"*TST?\")\n         code = int(result_str.strip())\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=\"*TST?\",\n            message=f\"Unexpected non-integer response: '{result_str}'\",\n        )\n    except InstrumentCommunicationError as e:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=\"*TST?\",\n            message=\"Failed to execute query.\",\n        ) from e\n\n    if code == 0:\n        self._logger.debug(\"Self-test query (*TST?) returned 0 (Passed).\")\n        errors_after_test = await self.get_all_errors()\n        if errors_after_test:\n             details = \"; \".join([f\"{c}: {m}\" for c, m in errors_after_test])\n             warn_msg = f\"Self-test query passed, but errors found in queue afterwards: {details}\"\n             self._logger.debug(warn_msg)\n        return \"Passed\"\n    else:\n        self._logger.debug(f\"Self-test query (*TST?) returned non-zero code: {code} (Failed). Reading error queue...\")\n        errors = await self.get_all_errors()\n        details = \"; \".join([f\"{c}: {m}\" for c, m in errors]) if errors else 'No specific errors reported in queue'\n        fail_msg = f\"Failed: Code {code}. Errors: {details}\"\n        self._logger.debug(fail_msg)\n        return fail_msg\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.set_communication_timeout","title":"<code>set_communication_timeout(timeout_ms)</code>  <code>async</code>","text":"<p>Sets the communication timeout on the backend.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def set_communication_timeout(self, timeout_ms: int) -&gt; None:\n    \"\"\"Sets the communication timeout on the backend.\"\"\"\n    await self._backend.set_timeout(timeout_ms)\n    self._logger.debug(f\"Communication timeout set to {timeout_ms} ms on backend.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Instrument.wait_for_operation_complete","title":"<code>wait_for_operation_complete(query_instrument=True, timeout=10.0)</code>  <code>async</code>","text":"<p>Waits for the instrument to finish all pending overlapping commands. The 'timeout' parameter's effect depends on the backend's query timeout settings.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>async def wait_for_operation_complete(self, query_instrument: bool = True, timeout: float = 10.0) -&gt; Optional[str]:\n    \"\"\"\n    Waits for the instrument to finish all pending overlapping commands.\n    The 'timeout' parameter's effect depends on the backend's query timeout settings.\n    \"\"\"\n    if query_instrument:\n        # The original logic for setting/restoring instrument.timeout has been removed\n        # as the _Backend protocol does not define a timeout attribute.\n        # The 'timeout' argument of this method might influence a timeout if the\n        # _query method or backend implementation uses it, but _query currently\n        # passes 'delay', not 'timeout'. For *OPC?, no delay is typically needed.\n        # The backend's own communication timeout will apply to the query.\n        self._logger.debug(f\"Waiting for operation complete (*OPC?). Effective timeout depends on backend (method timeout hint: {timeout}s).\")\n        try:\n            # The timeout parameter of this method is not directly passed to _query here.\n            # _query's delay parameter is for a different purpose.\n            response = await self._query(\"*OPC?\") # This now uses self._backend.query\n            self._logger.debug(\"Operation complete query (*OPC?) returned.\")\n            if response.strip() != \"1\":\n                self._logger.debug(f\"Warning: *OPC? returned '{response}' instead of expected '1'.\")\n            return response.strip()\n        except InstrumentCommunicationError as e:\n            # The 'timeout' parameter of this method is noted here for context.\n            err_msg = f\"*OPC? query failed. This may be due to backend communication timeout (related to method's timeout param: {timeout}s).\"\n            self._logger.debug(err_msg)\n            raise InstrumentCommunicationError(\n                instrument=self.config.model, command=\"*OPC?\", message=err_msg\n            ) from e\n        # 'finally' block for restoring timeout removed.\n    else:\n        await self._send_command(\"*OPC\") # This now uses self._backend.write\n        self._logger.debug(\"Operation complete command (*OPC) sent (non-blocking). Status polling required.\")\n        return None\n</code></pre>"},{"location":"api/instruments/#supported-instrument-types","title":"Supported Instrument Types","text":""},{"location":"api/instruments/#oscilloscope","title":"Oscilloscope","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope","title":"<code>pytestlab.instruments.Oscilloscope</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope-classes","title":"Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ChannelReadingResult","title":"<code>ChannelReadingResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs)</code>","text":"<p>               Bases: <code>MeasurementResult</code></p> <p>A result class for oscilloscope channel readings (time, voltage, etc).</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __init__(self, values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat],\n             instrument: str,\n             units: str,\n             measurement_type: str,\n             timestamp: Optional[float] = None, # Allow optional timestamp override\n             envelope: Optional[Dict[str, Any]] = None, # Add envelope as an explicit argument\n             sampling_rate: Optional[float] = None, # Add sampling_rate for FFT\n             **kwargs: Any) -&gt; None: # Added **kwargs and type hint\n    self.values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat] = values\n    self.units: str = units\n    self.instrument: str = instrument\n    self.measurement_type: str = measurement_type\n    self.timestamp: float = timestamp if timestamp is not None else time.time()\n    # Envelope logic: always provide an envelope attribute\n    if envelope is not None:\n        self.envelope = envelope\n    else:\n        # Default: minimal valid envelope (empty dict, or customize as needed)\n        self.envelope = {}\n\n    # Store sampling rate for FFT calculations\n    self.sampling_rate = sampling_rate\n\n    # Store any additional kwargs as attributes\n    for key, value in kwargs.items():\n        setattr(self, key, value)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.FFTResult","title":"<code>FFTResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs)</code>","text":"<p>               Bases: <code>MeasurementResult</code></p> <p>A result class for FFT data from the oscilloscope.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __init__(self, values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat],\n             instrument: str,\n             units: str,\n             measurement_type: str,\n             timestamp: Optional[float] = None, # Allow optional timestamp override\n             envelope: Optional[Dict[str, Any]] = None, # Add envelope as an explicit argument\n             sampling_rate: Optional[float] = None, # Add sampling_rate for FFT\n             **kwargs: Any) -&gt; None: # Added **kwargs and type hint\n    self.values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat] = values\n    self.units: str = units\n    self.instrument: str = instrument\n    self.measurement_type: str = measurement_type\n    self.timestamp: float = timestamp if timestamp is not None else time.time()\n    # Envelope logic: always provide an envelope attribute\n    if envelope is not None:\n        self.envelope = envelope\n    else:\n        # Default: minimal valid envelope (empty dict, or customize as needed)\n        self.envelope = {}\n\n    # Store sampling rate for FFT calculations\n    self.sampling_rate = sampling_rate\n\n    # Store any additional kwargs as attributes\n    for key, value in kwargs.items():\n        setattr(self, key, value)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.FRanalysisResult","title":"<code>FRanalysisResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs)</code>","text":"<p>               Bases: <code>MeasurementResult</code></p> <p>A result class for frequency response analysis data.</p> Source code in <code>pytestlab/experiments/results.py</code> <pre><code>def __init__(self, values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat],\n             instrument: str,\n             units: str,\n             measurement_type: str,\n             timestamp: Optional[float] = None, # Allow optional timestamp override\n             envelope: Optional[Dict[str, Any]] = None, # Add envelope as an explicit argument\n             sampling_rate: Optional[float] = None, # Add sampling_rate for FFT\n             **kwargs: Any) -&gt; None: # Added **kwargs and type hint\n    self.values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat] = values\n    self.units: str = units\n    self.instrument: str = instrument\n    self.measurement_type: str = measurement_type\n    self.timestamp: float = timestamp if timestamp is not None else time.time()\n    # Envelope logic: always provide an envelope attribute\n    if envelope is not None:\n        self.envelope = envelope\n    else:\n        # Default: minimal valid envelope (empty dict, or customize as needed)\n        self.envelope = {}\n\n    # Store sampling rate for FFT calculations\n    self.sampling_rate = sampling_rate\n\n    # Store any additional kwargs as attributes\n    for key, value in kwargs.items():\n        setattr(self, key, value)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope","title":"<code>Oscilloscope(config, debug_mode=False, simulate=False, **kwargs)</code>","text":"<p>               Bases: <code>Instrument[OscilloscopeConfig]</code></p> <p>Drives a digital oscilloscope for waveform acquisition and measurement.</p> <p>This class provides a comprehensive, high-level interface for controlling an oscilloscope. It builds upon the base <code>Instrument</code> class and adds extensive functionality specific to oscilloscopes.</p> <p>Key features include: - Facade-based interfaces for channels, trigger, and acquisition for cleaner code. - Methods for reading waveforms, performing automated measurements (e.g., Vpp, Vrms). - Support for advanced features like FFT and Frequency Response Analysis (FRA). - Built-in waveform generator control if the hardware supports it. - Screenshot capability.</p> ATTRIBUTE DESCRIPTION <code>config</code> <p>The Pydantic configuration object (<code>OscilloscopeConfig</code>)     containing settings specific to this oscilloscope.</p> <p> TYPE: <code>OscilloscopeConfig</code> </p> <code>trigger</code> <p>A <code>ScopeTriggerFacade</code> for configuring trigger settings.</p> <p> </p> <code>acquisition</code> <p>A <code>ScopeAcquisitionFacade</code> for acquisition system settings.</p> <p> </p> <p>Initialize the Oscilloscope class with the given VISA resource and profile information.</p> <p>Args: config (OscilloscopeConfig): Configuration object for the oscilloscope. debug_mode (bool): Enable debug mode. (Handled by base or backend) simulate (bool): Enable simulation mode. (Handled by base or backend)</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>def __init__(self, config: OscilloscopeConfig, debug_mode: bool = False, simulate: bool = False, **kwargs: Any) -&gt; None: # config is now non-optional\n    \"\"\"\n    Initialize the Oscilloscope class with the given VISA resource and profile information.\n\n    Args:\n    config (OscilloscopeConfig): Configuration object for the oscilloscope.\n    debug_mode (bool): Enable debug mode. (Handled by base or backend)\n    simulate (bool): Enable simulation mode. (Handled by base or backend)\n    \"\"\"\n    # The config is already validated by the loader to be OscilloscopeConfig V2\n    super().__init__(config=config, debug_mode=debug_mode, simulate=simulate, **kwargs) # Pass kwargs\n    # Initialize facades\n    self.trigger = ScopeTriggerFacade(self)\n    self.acquisition = ScopeAcquisitionFacade(self)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.acquisition","title":"<code>acquisition = ScopeAcquisitionFacade(self)</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.config","title":"<code>config</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.trigger","title":"<code>trigger = ScopeTriggerFacade(self)</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.auto_scale","title":"<code>auto_scale()</code>  <code>async</code>","text":"<p>Auto scale the oscilloscope display.</p> <p>This method sends an SCPI command to the oscilloscope to auto scale the display.</p> <p>Example:</p> <p>auto_scale()</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def auto_scale(self) -&gt; None:\n    \"\"\"\n    Auto scale the oscilloscope display.\n\n    This method sends an SCPI command to the oscilloscope to auto scale the display.\n\n    Example:\n    &gt;&gt;&gt; auto_scale()\n    \"\"\"\n    await self._send_command(\":AUToscale\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.channel","title":"<code>channel(ch_num)</code>","text":"<p>Returns a facade for interacting with a specific channel.</p> <p>This method provides a convenient, chainable interface for controlling a single oscilloscope channel.</p> PARAMETER DESCRIPTION <code>ch_num</code> <p>The channel number (1-based).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>ScopeChannelFacade</code> <p>A <code>ScopeChannelFacade</code> object for the specified channel.</p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If the channel number is invalid.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\ndef channel(self, ch_num: int) -&gt; ScopeChannelFacade:\n    \"\"\"Returns a facade for interacting with a specific channel.\n\n    This method provides a convenient, chainable interface for controlling a\n    single oscilloscope channel.\n\n    Args:\n        ch_num: The channel number (1-based).\n\n    Returns:\n        A `ScopeChannelFacade` object for the specified channel.\n\n    Raises:\n        InstrumentParameterError: If the channel number is invalid.\n    \"\"\"\n    if not self.config.channels or not (1 &lt;= ch_num &lt;= len(self.config.channels)):\n        num_conf_ch = len(self.config.channels) if self.config.channels else 0\n        raise InstrumentParameterError(\n            parameter=\"ch_num\",\n            value=ch_num,\n            valid_range=(1, num_conf_ch),\n            message=\"Channel number is out of range.\",\n        )\n    return ScopeChannelFacade(self, ch_num)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.configure_fft","title":"<code>configure_fft(source_channel, scale=None, offset=None, span=None, window_type='HANNing', units='DECibel', display=True)</code>  <code>async</code>","text":"<p>Configure the oscilloscope to perform an FFT on the specified channel.</p> <p>:param source_channel: The channel number to perform FFT on. :param scale: The vertical scale of the FFT display. Instrument specific. :param offset: The vertical offset of the FFT display. Instrument specific. :param span: The frequency span for the FFT. Instrument specific. :param window_type: The windowing function. Case-insensitive. From config.fft.window_types. :param units: The unit for FFT magnitude. Case-insensitive. From config.fft.units. :param display: True to turn FFT display ON, False for OFF.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"fft\")\nasync def configure_fft(self, source_channel: int, scale: Optional[float] = None, offset: Optional[float] = None, span: Optional[float] = None,  window_type: str = 'HANNing', units: str = 'DECibel', display: bool = True) -&gt; None:\n    \"\"\"\n    Configure the oscilloscope to perform an FFT on the specified channel.\n\n    :param source_channel: The channel number to perform FFT on.\n    :param scale: The vertical scale of the FFT display. Instrument specific.\n    :param offset: The vertical offset of the FFT display. Instrument specific.\n    :param span: The frequency span for the FFT. Instrument specific.\n    :param window_type: The windowing function. Case-insensitive. From config.fft.window_types.\n    :param units: The unit for FFT magnitude. Case-insensitive. From config.fft.units.\n    :param display: True to turn FFT display ON, False for OFF.\n    \"\"\"\n    if self.config.fft is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"FFT not configured for this instrument.\"\n        )\n    if not (1 &lt;= source_channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"source_channel\",\n            value=source_channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Source channel number is out of range.\",\n        )\n\n    # Validate window_type against config.fft.window_types (List[str])\n    # Assuming window_type parameter is the SCPI string itself\n    if window_type.upper() not in [wt.upper() for wt in self.config.fft.window_types]:\n        raise InstrumentParameterError(\n            parameter=\"window_type\",\n            value=window_type,\n            valid_range=self.config.fft.window_types,\n            message=\"Unsupported FFT window type.\",\n        )\n    scpi_window = window_type\n\n    # Validate units against config.fft.units (List[str])\n    if units.upper() not in [u.upper() for u in self.config.fft.units]:\n        raise InstrumentParameterError(\n            parameter=\"units\",\n            value=units,\n            valid_range=self.config.fft.units,\n            message=\"Unsupported FFT units.\",\n        )\n    scpi_units = units\n\n    await self._send_command(f':FFT:SOURce1 CHANnel{source_channel}')\n    await self._send_command(f':FFT:WINDow {scpi_window}')\n\n    if span is not None:\n        await self._send_command(f':FFT:SPAn {span}')\n\n    await self._send_command(f':FFT:VTYPe {scpi_units}')\n\n    if scale is not None:\n        await self._send_command(f':FFT:SCALe {scale}')\n\n    if offset is not None:\n        await self._send_command(f':FFT:OFFSet {offset}')\n\n    scpi_display_state = SCPIOnOff.ON.value if display else SCPIOnOff.OFF.value\n    await self._send_command(f':FFT:DISPlay {scpi_display_state}')\n\n    self._logger.debug(f\"FFT configured for channel {source_channel}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.configure_trigger","title":"<code>configure_trigger(channel, level, source=None, trigger_type='HIGH', slope=TriggerSlope.POSITIVE, mode='EDGE')</code>  <code>async</code>","text":"<p>Sets the trigger for the oscilloscope.</p> <p>:param channel: The channel to set the trigger for (used if source is None or a channel itself) :param level: The trigger level in volts :param source: The source of the trigger. Default behaviour is to use the channel. Valid options CHANnel | EXTernal | LINE | WGEN :param trigger_type: The type of trigger. Default is 'HIGH' (Note: this param seems unused in current logic for level setting) :param slope: The slope of the trigger. Default is TriggerSlope.POSITIVE :param mode: The trigger mode. Default is 'EDGE' Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def configure_trigger(self, channel: int, level: float, source: Optional[str] = None, trigger_type: str = \"HIGH\", slope: TriggerSlope = TriggerSlope.POSITIVE, mode: str = \"EDGE\") -&gt; None:\n    \"\"\"\n    Sets the trigger for the oscilloscope.\n\n    :param channel: The channel to set the trigger for (used if source is None or a channel itself)\n    :param level: The trigger level in volts\n    :param source: The source of the trigger. Default behaviour is to use the channel. Valid options CHANnel&lt;n&gt; | EXTernal | LINE | WGEN\n    :param trigger_type: The type of trigger. Default is 'HIGH' (Note: this param seems unused in current logic for level setting)\n    :param slope: The slope of the trigger. Default is TriggerSlope.POSITIVE\n    :param mode: The trigger mode. Default is 'EDGE'\n    \"\"\"\n\n    if not (1 &lt;= channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"channel\",\n            value=channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Primary channel number is out of range.\",\n        )\n\n    actual_source: str\n    if source is None:\n        actual_source = f\"CHANnel{channel}\"\n    else:\n        actual_source = source.upper()\n        # Check if source is a channel (handle CH1, CHAN1, CHANNEL1 formats)\n        if actual_source.startswith(\"CH\"):\n            try:\n                num_str = \"\".join(filter(str.isdigit, actual_source))\n                if not num_str:\n                    raise ValueError(\"No digits found in channel source string\")\n                source_channel_to_validate = int(num_str)\n                if not (1 &lt;= source_channel_to_validate &lt;= len(self.config.channels)):\n                    raise InstrumentParameterError(\n                        parameter=\"source\",\n                        value=source,\n                        valid_range=(1, len(self.config.channels)),\n                        message=\"Source channel number is out of range.\",\n                    )\n                # Normalize the channel source to CHANNEL format for SCPI command\n                actual_source = f\"CHANnel{source_channel_to_validate}\"\n            except (ValueError, IndexError) as e:\n                raise InstrumentParameterError(\n                    parameter=\"source\",\n                    value=source,\n                    message=\"Invalid channel format in source.\",\n                ) from e\n        elif actual_source not in [\"EXTERNAL\", \"LINE\", \"WGEN\"]:\n            raise InstrumentParameterError(\n                parameter=\"source\",\n                value=source,\n                valid_range=[\"EXTernal\", \"LINE\", \"WGEN\"],\n                message=\"Invalid source.\",\n            )\n\n    await self._send_command(f':TRIG:SOUR {actual_source}')\n    await self._send_command(f':TRIGger:LEVel {level}, CHANnel{channel}')\n\n    if slope.value not in self.config.trigger.slopes:\n        raise InstrumentParameterError(\n            parameter=\"slope\",\n            value=slope.value,\n            valid_range=self.config.trigger.slopes,\n            message=\"Unsupported trigger slope.\",\n        )\n    scpi_slope = slope.value\n\n    if mode.upper() not in [m.upper() for m in self.config.trigger.modes]: # Case-insensitive check\n         self._logger.warning(f\"Trigger mode '{mode}' not in configured supported modes: {self.config.trigger.modes}. Passing directly to instrument.\")\n    scpi_mode = mode\n\n    await self._send_command(f':TRIGger:SLOPe {scpi_slope}')\n    await self._send_command(f':TRIGger:MODE {scpi_mode}')\n    await self._wait()\n\n    self._logger.debug(f\"\"\"Trigger set with the following parameters:\n              Trigger Source: {actual_source}\n              Trigger Level for CHAN{channel}: {level}\n              Trigger Slope: {scpi_slope}\n              Trigger Mode: {scpi_mode}\"\"\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.display_channel","title":"<code>display_channel(channels, state=True)</code>  <code>async</code>","text":"<p>Display or hide the specified channel(s) on the oscilloscope.</p> <p>Args: channels (Union[int, List[int]]): A single channel number or a list of channel numbers. state (bool): True to display (ON), False to hide (OFF). Default is True.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def display_channel(self, channels: Union[int, List[int]], state: bool = True) -&gt; None:\n    \"\"\"\n    Display or hide the specified channel(s) on the oscilloscope.\n\n    Args:\n    channels (Union[int, List[int]]): A single channel number or a list of channel numbers.\n    state (bool): True to display (ON), False to hide (OFF). Default is True.\n    \"\"\"\n    ch_list: List[int]\n    if isinstance(channels, int):\n        ch_list = [channels]\n    elif isinstance(channels, list) and all(isinstance(ch, int) for ch in channels):\n        ch_list = channels\n    else:\n        # validate_call should catch this if type hints are precise enough\n        raise InstrumentParameterError(\n            message=\"channels must be an int or a list of ints\"\n        )\n\n    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value\n    for ch_num in ch_list:\n        if not (1 &lt;= ch_num &lt;= len(self.config.channels)):\n            raise InstrumentParameterError(\n                parameter=\"channels\",\n                value=ch_num,\n                valid_range=(1, len(self.config.channels)),\n                message=\"Channel number is out of range.\",\n            )\n        await self._send_command(f\"CHANnel{ch_num}:DISPlay {scpi_state}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.fft_display","title":"<code>fft_display(state=True)</code>  <code>async</code>","text":"<p>Switches on or off the FFT display.</p> <p>:param state: True to enable FFT display, False to disable.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"fft\")\nasync def fft_display(self, state: bool = True) -&gt; None:\n    \"\"\"\n    Switches on or off the FFT display.\n\n    :param state: True to enable FFT display, False to disable.\n    \"\"\"\n    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value\n    await self._send_command(f\":FFT:DISPlay {scpi_state}\")\n    self._logger.debug(f\"FFT display {'enabled' if state else 'disabled'}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.franalysis_sweep","title":"<code>franalysis_sweep(input_channel, output_channel, start_freq, stop_freq, amplitude, points=10, trace='none', load='onemeg', disable_on_complete=True)</code>  <code>async</code>","text":"<p>Perform a frequency response analysis sweep.</p> RETURNS DESCRIPTION <code>FRanalysisResult</code> <p>Containing the frequency response analysis data.</p> <p> TYPE: <code>FRanalysisResult</code> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"franalysis\")\n#@ConfigRequires(\"function_generator\")\nasync def franalysis_sweep(self, input_channel: int, output_channel: int, start_freq: float, stop_freq: float, amplitude: float, points: int = 10, trace: str = \"none\", load: str = \"onemeg\", disable_on_complete: bool = True) -&gt; FRanalysisResult:\n    \"\"\"\n    Perform a frequency response analysis sweep.\n\n    Returns:\n        FRanalysisResult: Containing the frequency response analysis data.\n    \"\"\"\n    if self.config.function_generator is None or self.config.franalysis is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator or FRANalysis not configured.\"\n        )\n\n    if not (1 &lt;= input_channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"input_channel\",\n            value=input_channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Input channel is out of range.\",\n        )\n    if not (1 &lt;= output_channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"output_channel\",\n            value=output_channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Output channel is out of range.\",\n        )\n\n    # Ensure points is at least 2 for a valid sweep\n    if points &lt; 2:\n        raise InstrumentParameterError(\n            parameter=\"points\",\n            value=points,\n            valid_range=(2, \"inf\"),\n            message=\"Points for sweep must be at least 2.\",\n        )\n\n    # SCPI commands for frequency response analysis sweep\n    await self._send_command(f\":FUNCtion:FRANalysis\")\n    await self._send_command(f\":FREQuency:START {start_freq}\")\n    await self._send_command(f\":FREQuency:STOP {stop_freq}\")\n    await self._send_command(f\":AMPLitude {amplitude}\")\n    await self._send_command(f\":POINTS {points}\")\n    await self._send_command(f\":TRACe:FEED {trace}\")\n    await self._send_command(f\":LOAD {load}\")\n\n    if disable_on_complete:\n        await self._send_command(\":DISABLE\")\n\n    # Optionally wait for completion or check status\n    await self._wait()  # Ensure to wait for the command to complete\n\n    # Assuming the result can be fetched with a common query, adjust as necessary\n    result_data = await self._query(\":FETCH:FRANalysis?\")\n\n    # Parse the result data into a structured format if needed\n    # For now, let's assume it's a simple comma-separated value string\n    parsed_results = [float(val) for val in result_data.split(',')]\n\n    # Create a DataFrame or structured result object\n    # Assuming two columns: Frequency and Magnitude\n    freq_values = parsed_results[0::2]  # Extracting frequency values\n    mag_values = parsed_results[1::2]   # Extracting magnitude values\n\n    return FRanalysisResult(\n        instrument=self.config.model,\n        units=\"\",\n        measurement_type=\"FrequencyResponse\",\n        values=pl.DataFrame({\n            \"Frequency (Hz)\": freq_values,\n            \"Magnitude\": mag_values\n        })\n    )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.from_config","title":"<code>from_config(config, debug_mode=False, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@classmethod\ndef from_config(cls: Type['Oscilloscope'], config: OscilloscopeConfig, debug_mode: bool = False, **kwargs: Any) -&gt; 'Oscilloscope':\n    # This method aligns with the new __init__ signature.\n    return cls(config=config, debug_mode=debug_mode, **kwargs)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.function_display","title":"<code>function_display(state=True)</code>  <code>async</code>","text":"<p>Switches on or off the function display (e.g. Math or WGEN waveform).</p> <p>:param state: True to enable display, False to disable.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def function_display(self, state: bool = True) -&gt; None:\n    \"\"\"\n    Switches on or off the function display (e.g. Math or WGEN waveform).\n\n    :param state: True to enable display, False to disable.\n    \"\"\"\n    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value\n    await self._send_command(f\":FUNCtion:DISPlay {scpi_state}\")\n    self._logger.debug(f\"Function display {'enabled' if state else 'disabled'}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.get_channel_axis","title":"<code>get_channel_axis(channel)</code>  <code>async</code>","text":"<p>Gets the channel axis of the oscilloscope. (y-axis)</p> <p>:param channel: The channel to get the axis for :return: A list containing the channel axis scale and offset</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_channel_axis(self, channel: int) -&gt; List[float]:\n    \"\"\"\n    Gets the channel axis of the oscilloscope. (y-axis)\n\n    :param channel: The channel to get the axis for\n    :return: A list containing the channel axis scale and offset\n    \"\"\"\n    if not (1 &lt;= channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"channel\",\n            value=channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Channel number is out of range.\",\n        )\n\n    scale_str: str = await self._query(f\":CHANnel{channel}:SCALe?\")\n    offset_str: str = await self._query(f\":CHANnel{channel}:OFFSet?\")\n    return [np.float64(scale_str), np.float64(offset_str)]\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.get_probe_attenuation","title":"<code>get_probe_attenuation(channel)</code>  <code>async</code>","text":"<p>Gets the probe attenuation for a given channel.</p> PARAMETER DESCRIPTION <code>channel</code> <p>The oscilloscope channel to get the probe attenuation for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The probe attenuation value (e.g., '10:1', '1:1').</p> <p> TYPE: <code>str</code> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_probe_attenuation(self, channel: int) -&gt; str: # Returns string like \"10:1\"\n    \"\"\"\n    Gets the probe attenuation for a given channel.\n\n    Parameters:\n        channel (int): The oscilloscope channel to get the probe attenuation for.\n\n    Returns:\n        str: The probe attenuation value (e.g., '10:1', '1:1').\n    \"\"\"\n    if not (1 &lt;= channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"channel\",\n            value=channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Channel number is out of range.\",\n        )\n    response_str: str = (await self._query(f\"CHANnel{channel}:PROBe?\")).strip()\n    # Assuming response is the numeric factor (e.g., \"10\", \"1\")\n    try:\n        # Ensure it's a number before formatting\n        num_factor = float(response_str)\n        if num_factor.is_integer():\n            return f\"{int(num_factor)}:1\"\n        return f\"{num_factor}:1\"\n    except ValueError:\n        self._logger.warning(f\"Could not parse probe attenuation factor '{response_str}' as number. Returning raw.\")\n        return response_str # Or raise error\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.get_sampling_rate","title":"<code>get_sampling_rate()</code>  <code>async</code>","text":"<p>Get the current sampling rate of the oscilloscope. Returns:     float: The sampling rate in Hz.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_sampling_rate(self) -&gt; float:\n    \"\"\"\n    Get the current sampling rate of the oscilloscope.\n    Returns:\n        float: The sampling rate in Hz.\n    \"\"\"\n    response_str: str = await self._query(\":ACQuire:SRATe?\")\n    sampling_rate_float: float = np.float64(response_str)\n    return sampling_rate_float\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.get_time_axis","title":"<code>get_time_axis()</code>  <code>async</code>","text":"<p>Gets the time axis of the oscilloscope. (x-axis)</p> <p>:return: A list containing the time axis scale and position</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_time_axis(self) -&gt; List[float]:\n    \"\"\"\n    Gets the time axis of the oscilloscope. (x-axis)\n\n    :return: A list containing the time axis scale and position\n    \"\"\"\n    scale_str: str = await self._query(\":TIMebase:SCALe?\")\n    position_str: str = await self._query(\":TIMebase:POSition?\")\n    return [np.float64(scale_str), np.float64(position_str)]\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.health_check","title":"<code>health_check()</code>  <code>async</code>","text":"<p>Performs a basic health check of the oscilloscope instrument.</p> RETURNS DESCRIPTION <code>HealthReport</code> <p>A report containing the instrument's health status,           errors, warnings, and supported features.</p> <p> TYPE: <code>HealthReport</code> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>async def health_check(self) -&gt; HealthReport:\n    \"\"\"\n    Performs a basic health check of the oscilloscope instrument.\n\n    Returns:\n        HealthReport: A report containing the instrument's health status,\n                      errors, warnings, and supported features.\n    \"\"\"\n    report = HealthReport()\n\n    try:\n        # Get instrument identification\n        report.instrument_idn = await self.id()\n\n        # Check for stored errors\n        instrument_errors = await self.get_all_errors()\n        if instrument_errors:\n            report.warnings.extend([f\"Stored Error: {code} - {msg}\" for code, msg in instrument_errors])\n\n        # Set initial status based on errors\n        if not report.errors and not report.warnings:\n            report.status = HealthStatus.OK\n        elif report.warnings and not report.errors:\n            report.status = HealthStatus.WARNING\n        else:\n            report.status = HealthStatus.ERROR\n\n    except Exception as e:\n        report.status = HealthStatus.ERROR\n        report.errors.append(f\"Health check failed during IDN/Error Query: {str(e)}\")\n\n    try:\n        # Test basic oscilloscope functionality\n        _ = await self.get_time_axis()\n\n        # Check supported features based on configuration\n        if hasattr(self.config, 'fft') and self.config.fft:\n            report.supported_features[\"fft\"] = True\n        else:\n            report.supported_features[\"fft\"] = False\n\n        if hasattr(self.config, 'franalysis') and self.config.franalysis:\n            report.supported_features[\"franalysis\"] = True\n        else:\n            report.supported_features[\"franalysis\"] = False\n\n        if hasattr(self.config, 'function_generator') and self.config.function_generator:\n            report.supported_features[\"function_generator\"] = True\n        else:\n            report.supported_features[\"function_generator\"] = False\n\n    except Exception as e:\n        report.errors.append(f\"Oscilloscope-specific check failed: {str(e)}\")\n\n    # Determine backend status\n    if hasattr(self, '_backend') and hasattr(self._backend, '__class__'):\n        backend_name = self._backend.__class__.__name__\n        if \"SimBackend\" in backend_name:\n            report.backend_status = \"Simulated\"\n        elif \"VisaBackend\" in backend_name:\n            report.backend_status = \"VISA Connection\"\n        elif \"LambInstrument\" in backend_name or \"LambBackend\" in backend_name:\n            report.backend_status = \"Lamb Connection\"\n        else:\n            report.backend_status = f\"Unknown backend: {backend_name}\"\n    else:\n        report.backend_status = \"Backend information unavailable\"\n\n    # Final status evaluation\n    if report.errors and report.status != HealthStatus.ERROR:\n        report.status = HealthStatus.ERROR\n    elif report.warnings and report.status == HealthStatus.OK:\n        report.status = HealthStatus.WARNING\n\n    # If no errors or warnings after all checks, and status is still UNKNOWN, set to OK\n    if report.status == HealthStatus.UNKNOWN and not report.errors and not report.warnings:\n        report.status = HealthStatus.OK\n\n    return report\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.lock_panel","title":"<code>lock_panel(lock=True)</code>  <code>async</code>","text":"<p>Locks the panel of the instrument</p> PARAMETER DESCRIPTION <code>lock</code> <p>True to lock the panel, False to unlock it</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def lock_panel(self, lock: bool = True) -&gt; None:\n    \"\"\"\n    Locks the panel of the instrument\n\n    Args:\n        lock (bool): True to lock the panel, False to unlock it\n    \"\"\"\n    scpi_state = SCPIOnOff.ON.value if lock else SCPIOnOff.OFF.value\n    await self._send_command(f\":SYSTem:LOCK {scpi_state}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.measure_rms_voltage","title":"<code>measure_rms_voltage(channel)</code>  <code>async</code>","text":"<p>Measure the root-mean-square (RMS) voltage for a specified channel.</p> <p>Args: channel (int): The channel identifier.</p> <p>Returns: MeasurementResult: An object containing the RMS voltage measurement.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def measure_rms_voltage(self, channel: int) -&gt; MeasurementResult:\n    \"\"\"\n    Measure the root-mean-square (RMS) voltage for a specified channel.\n\n    Args:\n    channel (int): The channel identifier.\n\n    Returns:\n    MeasurementResult: An object containing the RMS voltage measurement.\n    \"\"\"\n    if not (1 &lt;= channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"channel\",\n            value=channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Channel number is out of range.\",\n        )\n\n    response_str: str = await self._query(f\"MEAS:VRMS? CHAN{channel}\")\n    reading: float = float(response_str)\n\n    value_to_return: float | UFloat = reading\n\n    if self.config.measurement_accuracy:\n        mode_key = f\"vrms_ch{channel}\"\n        self._logger.debug(f\"Attempting to find accuracy spec for Vrms on channel {channel} with key: '{mode_key}'\")\n        spec = self.config.measurement_accuracy.get(mode_key)\n        if spec:\n            sigma = spec.calculate_std_dev(reading, range_value=None)\n            if sigma &gt; 0:\n                value_to_return = ufloat(reading, sigma)\n                self._logger.debug(f\"Applied accuracy spec '{mode_key}', value: {value_to_return}\")\n            else:\n                self._logger.debug(f\"Accuracy spec '{mode_key}' resulted in sigma=0. Returning float.\")\n        else:\n            self._logger.debug(f\"No accuracy spec found for Vrms on channel {channel} with key '{mode_key}'. Returning float.\")\n    else:\n        self._logger.debug(f\"No measurement_accuracy configuration in instrument for Vrms on channel {channel}. Returning float.\")\n\n    self._logger.debug(f\"RMS Voltage (Channel {channel}): {value_to_return}\")\n\n    measurement_result = MeasurementResult(\n        values=value_to_return,\n        instrument=self.config.model,\n        units=\"V\",\n        measurement_type=\"rms_voltage\"\n    )\n    return measurement_result\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.measure_voltage_peak_to_peak","title":"<code>measure_voltage_peak_to_peak(channel)</code>  <code>async</code>","text":"<p>Measure the peak-to-peak voltage for a specified channel.</p> <p>Args: channel (int): The channel identifier.</p> <p>Returns: MeasurementResult: An object containing the peak-to-peak voltage measurement.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def measure_voltage_peak_to_peak(self, channel: int) -&gt; MeasurementResult:\n    \"\"\"\n    Measure the peak-to-peak voltage for a specified channel.\n\n    Args:\n    channel (int): The channel identifier.\n\n    Returns:\n    MeasurementResult: An object containing the peak-to-peak voltage measurement.\n    \"\"\"\n    if not (1 &lt;= channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"channel\",\n            value=channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Channel number is out of range.\",\n        )\n\n    response_str: str = await self._query(f\"MEAS:VPP? CHAN{channel}\")\n    reading: float = float(response_str)\n\n    value_to_return: float | UFloat = reading\n\n    if self.config.measurement_accuracy:\n        mode_key = f\"vpp_ch{channel}\"\n        self._logger.debug(f\"Attempting to find accuracy spec for Vpp on channel {channel} with key: '{mode_key}'\")\n        spec = self.config.measurement_accuracy.get(mode_key)\n        if spec:\n            sigma = spec.calculate_std_dev(reading, range_value=None)\n            if sigma &gt; 0:\n                value_to_return = ufloat(reading, sigma)\n                self._logger.debug(f\"Applied accuracy spec '{mode_key}', value: {value_to_return}\")\n            else:\n                self._logger.debug(f\"Accuracy spec '{mode_key}' resulted in sigma=0. Returning float.\")\n        else:\n            self._logger.debug(f\"No accuracy spec found for Vpp on channel {channel} with key '{mode_key}'. Returning float.\")\n    else:\n        self._logger.debug(f\"No measurement_accuracy configuration in instrument for Vpp on channel {channel}. Returning float.\")\n\n    measurement_result = MeasurementResult(\n        values=value_to_return,\n        units=\"V\",\n        instrument=self.config.model,\n        measurement_type=\"P2PV\"\n    )\n\n    self._logger.debug(f\"Peak to Peak Voltage (Channel {channel}): {value_to_return}\")\n\n    return measurement_result\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.read_channels","title":"<code>read_channels(*channels, points=None, run_after=True, timebase=None, **kwargs)</code>  <code>async</code>","text":"<p>Reads and processes waveform data from one or more channels.</p> <p>This is a primary data acquisition method. It triggers an acquisition, reads the raw data for the specified channels, and uses the preamble to convert the data into a <code>ChannelReadingResult</code> containing properly scaled time and voltage values in a Polars DataFrame.</p> PARAMETER DESCRIPTION <code>*channels</code> <p>A variable number of channel numbers (e.g., <code>read_channels(1, 2)</code>)        or a single list/tuple of channels (e.g., <code>read_channels([1, 2])</code>).</p> <p> TYPE: <code>Union[int, List[int], Tuple[int, ...]]</code> DEFAULT: <code>()</code> </p> <code>points</code> <p>Deprecated. The number of points is determined by the timebase     and instrument settings.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>run_after</code> <p>This parameter is currently unused.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>timebase</code> <p>If provided, sets the time-per-division for this acquisition.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ChannelReadingResult</code> <p>A <code>ChannelReadingResult</code> containing the waveform data.</p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If channel numbers are invalid or not provided.</p> <code>InstrumentDataError</code> <p>If time values cannot be generated.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def read_channels(self, *channels: Union[int, List[int], Tuple[int, ...]], points: Optional[int] = None, run_after: bool = True, timebase: Optional[float] = None, **kwargs) -&gt; ChannelReadingResult:\n    \"\"\"Reads and processes waveform data from one or more channels.\n\n    This is a primary data acquisition method. It triggers an acquisition,\n    reads the raw data for the specified channels, and uses the preamble\n    to convert the data into a `ChannelReadingResult` containing properly\n    scaled time and voltage values in a Polars DataFrame.\n\n    Args:\n        *channels: A variable number of channel numbers (e.g., `read_channels(1, 2)`)\n                   or a single list/tuple of channels (e.g., `read_channels([1, 2])`).\n        points: Deprecated. The number of points is determined by the timebase\n                and instrument settings.\n        run_after: This parameter is currently unused.\n        timebase: If provided, sets the time-per-division for this acquisition.\n\n    Returns:\n        A `ChannelReadingResult` containing the waveform data.\n\n    Raises:\n        InstrumentParameterError: If channel numbers are invalid or not provided.\n        InstrumentDataError: If time values cannot be generated.\n    \"\"\"\n    if 'runAfter' in kwargs:\n        warnings.warn(\n            \"'runAfter' is deprecated, use 'run_after' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        run_after = kwargs['runAfter']\n\n    processed_channels: List[int]\n    if not channels:\n        raise InstrumentParameterError(message=\"No channels specified.\")\n\n    first_arg = channels[0]\n    if isinstance(first_arg, (list, tuple)) and len(channels) == 1:\n        if not all(isinstance(ch_num, int) for ch_num in first_arg):\n            raise InstrumentParameterError(\n                message=\"All elements in channel list/tuple must be integers.\"\n            )\n        processed_channels = list(first_arg)\n    elif all(isinstance(ch_num, int) for ch_num in channels): # type: ignore [arg-type]\n        processed_channels = list(channels) # type: ignore [assignment]\n    else:\n        raise InstrumentParameterError(\n            message=\"Invalid channel arguments. Must be integers or a single list/tuple of integers.\"\n        )\n\n    if not processed_channels:\n        raise InstrumentParameterError(\n            message=\"No channels specified in the list/tuple.\"\n        )\n\n    if timebase is not None:\n        current_time_axis = await self.get_time_axis()\n        await self.set_time_axis(scale=timebase, position=current_time_axis[1])\n\n    if points is not None:\n        self._logger.debug(f\"Points argument is deprecated (value: {points}). Use set_time_axis instead.\")\n\n\n    self._logger.debug(\"starting channel read\")\n\n    for ch_num_val in processed_channels:\n        if not (1 &lt;= ch_num_val &lt;= len(self.config.channels)):\n            raise InstrumentParameterError(\n                parameter=\"channels\",\n                value=ch_num_val,\n                valid_range=(1, len(self.config.channels)),\n                message=\"Channel number is out of range.\",\n            )\n\n\n    sampling_rate_float: float = float(await self.get_sampling_rate())\n    channel_commands_str: str = ', '.join(f\"CHANnel{ch}\" for ch in processed_channels)\n\n    acq_type_enum_or_str = await self.acquisition.get_acquisition_type()\n\n    is_average_mode = False\n    if isinstance(acq_type_enum_or_str, AcquisitionType):\n        is_average_mode = acq_type_enum_or_str == AcquisitionType.AVERAGE\n    elif isinstance(acq_type_enum_or_str, str):\n        is_average_mode = acq_type_enum_or_str.upper() == \"AVERAGE\"\n\n    # Handle different acquisition modes. Averaging mode often requires a\n    # special command sequence to ensure the requested number of averages\n    # are acquired before the data is read.\n    if is_average_mode:\n        self._logger.debug(\"AVERAGE acquisition type detected - using special sequence\")\n        avg_count_int: int = await self.acquisition.get_acquisition_average_count()\n        self._logger.debug(f\"Current average count: {avg_count_int}\")\n        await self._send_command(\":ACQuire:COMPlete 100\") # Ensure all averages are processed\n        await self._send_command(\":STOP\")\n        await self._wait()\n\n        # Force a new acquisition sequence for averaging\n        sweep_orig_str: str = (await self._query(\":TRIGger:SWEep?\")).strip()\n        await self._send_command(\":TRIGger:SWEep AUTO\")\n        await self._send_command(f\"DIGitize {channel_commands_str}\", skip_check=True)\n        await self._send_command(\":TRIGger:FORCe\", skip_check=True)\n        await self._send_command(\"*OPC\")\n        self._logger.debug(\"Waiting for acquisition to complete \u2026\")\n        await self._wait()\n        await self._send_command(\":TRIGger:FORCe\", skip_check=True)\n        self._logger.debug(\"Waiting for acquisition to complete \u2026\")\n        await self._wait()\n        await self._send_command(f\":TRIGger:SWEep {sweep_orig_str}\", skip_check=True)\n        await self.clear_status()\n    else:\n        # For other modes, a simple DIGitize command is sufficient.\n        await self._send_command(f\"DIGitize {channel_commands_str}\")\n\n    await self._send_command(f':WAVeform:SOURce CHANnel{processed_channels[0]}')\n    await self._send_command(':WAVeform:FORMat BYTE')\n    await self._send_command(':WAVeform:POINts:MODE RAW')\n\n    pream: Preamble = await self._read_preamble()\n\n    time_values_np: Optional[np.ndarray] = None\n    measurement_results_dict: Dict[str, np.ndarray] = {}\n\n    # Loop through each requested channel to read its data\n    for ch_num_loop in processed_channels:\n        raw_wave_data = await self._read_wave_data(f\"CHANnel{ch_num_loop}\")\n        # Convert raw ADC values to volts using the preamble data\n        voltages_np: np.ndarray = (raw_wave_data - pream.yref) * pream.yinc + pream.yorg\n\n        # Generate the corresponding time axis array, but only once.\n        if time_values_np is None:\n            n_pts_int: int = len(voltages_np)\n            time_values_np = (np.arange(n_pts_int) - pream.xref) * pream.xinc + pream.xorg\n\n        measurement_results_dict[f\"Channel {ch_num_loop} (V)\"] = voltages_np\n\n    if time_values_np is None:\n        raise InstrumentDataError(\n            self.config.model, \"Time values were not generated during channel read.\"\n        )\n\n    return ChannelReadingResult(\n       instrument=self.config.model,\n       units=\"V\",\n       measurement_type=\"ChannelVoltageTime\",\n       sampling_rate=sampling_rate_float,\n       values=pl.DataFrame({\n            \"Time (s)\": time_values_np,\n            **measurement_results_dict\n       })\n    )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.read_fft_data","title":"<code>read_fft_data(channel, window='hann')</code>  <code>async</code>","text":"<p>Acquires time-domain data for the specified channel and computes the FFT using the analysis submodule.</p> PARAMETER DESCRIPTION <code>channel</code> <p>The channel number to perform FFT on.</p> <p> TYPE: <code>int</code> </p> <code>window</code> <p>The windowing function to apply before FFT                      (e.g., 'hann', 'hamming', None).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'hann'</code> </p> RETURNS DESCRIPTION <code>FFTResult</code> <p>An object containing the computed FFT data (frequency and linear magnitude).</p> <p> TYPE: <code>FFTResult</code> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def read_fft_data(self, channel: int, window: Optional[str] = 'hann') -&gt; FFTResult:\n    \"\"\"\n    Acquires time-domain data for the specified channel and computes the FFT using\n    the analysis submodule.\n\n    Args:\n        channel (int): The channel number to perform FFT on.\n        window (Optional[str]): The windowing function to apply before FFT\n                                 (e.g., 'hann', 'hamming', None).\n\n    Returns:\n        FFTResult: An object containing the computed FFT data (frequency and linear magnitude).\n    \"\"\"\n    self._logger.debug(f\"Initiating FFT computation for channel {channel} using analysis module.\")\n\n    if not (1 &lt;= channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"channel\",\n            value=channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Channel number is out of range.\",\n        )\n\n    # 1. Acquire raw time-domain waveform data\n    waveform_data: ChannelReadingResult = await self.read_channels(channel)\n\n    if waveform_data.values is None or waveform_data.values.is_empty():\n        self._logger.warning(f\"No waveform data acquired for channel {channel}. Cannot compute FFT.\")\n        # Return an empty FFTResult or raise an error\n        return FFTResult(\n            instrument=self.config.model,\n            units=\"Linear\",\n            measurement_type=\"FFT_computed_python\",\n            values=pl.DataFrame({\n                \"Frequency (Hz)\": np.array([]),\n                \"Magnitude (Linear)\": np.array([])\n            })\n        )\n\n    time_array = waveform_data.values[\"Time (s)\"].to_numpy()\n    voltage_column_name = f\"Channel {channel} (V)\"\n    if voltage_column_name not in waveform_data.values.columns:\n        raise InstrumentDataError(\n            self.config.model,\n            f\"Could not find voltage data for channel {channel} in waveform results.\",\n        )\n    voltage_array = waveform_data.values[voltage_column_name].to_numpy()\n\n    # 2. Call the appropriate function from pytestlab.analysis.fft\n    frequency_array, magnitude_array = analysis_fft.compute_fft(\n        time_array=time_array,\n        voltage_array=voltage_array,\n        window=window\n    )\n\n    # 3. Return or further process the results\n    return FFTResult(\n        instrument=self.config.model,\n        units=\"Linear\", # compute_fft returns linear magnitude\n        measurement_type=\"FFT_computed_python\",\n        values=pl.DataFrame({\n            \"Frequency (Hz)\": frequency_array,\n            \"Magnitude (Linear)\": magnitude_array\n        })\n    )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.screenshot","title":"<code>screenshot()</code>  <code>async</code>","text":"<p>Capture a screenshot of the oscilloscope display.</p> <p>:return Image: A PIL Image object containing the screenshot.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def screenshot(self) -&gt; Image.Image:\n    \"\"\"\n    Capture a screenshot of the oscilloscope display.\n\n    :return Image: A PIL Image object containing the screenshot.\n    \"\"\"\n    binary_data_response: bytes = await self._query_raw(\":DISPlay:DATA? PNG, COLor\")\n\n    if not binary_data_response.startswith(b'#'):\n        raise InstrumentDataError(\n            self.config.model, \"Invalid screenshot data format: does not start with #\"\n        )\n\n    length_of_length_field: int = int(chr(binary_data_response[1]))\n    png_data_length_str: str = binary_data_response[2 : 2 + length_of_length_field].decode('ascii')\n    png_data_length: int = int(png_data_length_str)\n    png_data_start_index: int = 2 + length_of_length_field\n    image_data_bytes: bytes = binary_data_response[png_data_start_index : png_data_start_index + png_data_length]\n\n    return Image.open(BytesIO(image_data_bytes))\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_acquisition_time","title":"<code>set_acquisition_time(time)</code>  <code>async</code>","text":"<p>Set the total acquisition time for the oscilloscope.</p> PARAMETER DESCRIPTION <code>time</code> <p>The total acquisition time in seconds.</p> <p> TYPE: <code>float</code> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_acquisition_time(self, time: float) -&gt; None:\n    \"\"\"\n    Set the total acquisition time for the oscilloscope.\n\n    Args:\n        time (float): The total acquisition time in seconds.\n    \"\"\"\n    await self._send_command(f\":TIMebase:MAIN:RANGe {time}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_bandwidth_limit","title":"<code>set_bandwidth_limit(channel, bandwidth)</code>  <code>async</code>","text":"<p>Sets the bandwidth limit for a specified channel. Args:     channel (int): The channel number.     bandwidth (Union[str, float]): The bandwidth limit (e.g., \"20M\", 20e6, or \"FULL\").</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_bandwidth_limit(self, channel: int, bandwidth: Union[str, float]) -&gt; None:\n    \"\"\"\n    Sets the bandwidth limit for a specified channel.\n    Args:\n        channel (int): The channel number.\n        bandwidth (Union[str, float]): The bandwidth limit (e.g., \"20M\", 20e6, or \"FULL\").\n    \"\"\"\n    if not (1 &lt;= channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"channel\",\n            value=channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Channel number is out of range.\",\n        )\n    await self._send_command(f\"CHANnel{channel}:BANDwidth {bandwidth}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_channel_axis","title":"<code>set_channel_axis(channel, scale, offset)</code>  <code>async</code>","text":"<p>Sets the channel axis of the oscilloscope. (y-axis)</p> <p>:param channel: The channel to set :param scale: The scale of the channel axis in volts :param offset: The offset of the channel in volts</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_channel_axis(self, channel: int, scale: float, offset: float) -&gt; None:\n    \"\"\"\n    Sets the channel axis of the oscilloscope. (y-axis)\n\n    :param channel: The channel to set\n    :param scale: The scale of the channel axis in volts\n    :param offset: The offset of the channel in volts\n    \"\"\"\n    if not (1 &lt;= channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"channel\",\n            value=channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Channel number is out of range.\",\n        )\n\n    await self._send_command(f':CHANnel{channel}:SCALe {scale}')\n    await self._send_command(f':CHANnel{channel}:OFFSet {offset}')\n    await self._wait()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_probe_attenuation","title":"<code>set_probe_attenuation(channel, scale)</code>  <code>async</code>","text":"<p>Sets the probe scale for a given channel.</p> PARAMETER DESCRIPTION <code>channel</code> <p>The oscilloscope channel to set the scale for.</p> <p> TYPE: <code>int</code> </p> <code>scale</code> <p>The probe scale value (e.g., 10 for 10:1, 1 for 1:1).</p> <p> TYPE: <code>int</code> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_probe_attenuation(self, channel: int, scale: int) -&gt; None:\n    \"\"\"\n    Sets the probe scale for a given channel.\n\n    Parameters:\n        channel (int): The oscilloscope channel to set the scale for.\n        scale (int): The probe scale value (e.g., 10 for 10:1, 1 for 1:1).\n    \"\"\"\n    if not (1 &lt;= channel &lt;= len(self.config.channels)):\n        raise InstrumentParameterError(\n            parameter=\"channel\",\n            value=channel,\n            valid_range=(1, len(self.config.channels)),\n            message=\"Channel number is out of range.\",\n        )\n\n    channel_model_config = self.config.channels[channel - 1]\n    if scale not in channel_model_config.probe_attenuation: # probe_attenuation is List[int]\n        raise InstrumentParameterError(\n            parameter=\"scale\",\n            value=scale,\n            valid_range=channel_model_config.probe_attenuation,\n            message=f\"Scale not in supported probe_attenuation list for channel {channel}.\",\n        )\n\n    # SCPI command usually takes the numeric factor directly\n    await self._send_command(f\":CHANnel{channel}:PROBe {scale}\")\n    self._logger.debug(f\"Set probe scale to {scale}:1 for channel {channel}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_sample_rate","title":"<code>set_sample_rate(rate)</code>  <code>async</code>","text":"<p>Sets the sample rate for the oscilloscope.</p> <p>Args: rate (str): The desired sample rate. Valid values are 'MAX' and 'AUTO'. Case-insensitive.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_sample_rate(self, rate: str) -&gt; None:\n    \"\"\"\n    Sets the sample rate for the oscilloscope.\n\n    Args:\n    rate (str): The desired sample rate. Valid values are 'MAX' and 'AUTO'. Case-insensitive.\n    \"\"\"\n    rate_upper: str = rate.upper()\n    valid_values: List[str] = [\"MAX\", \"AUTO\"] # These are common SCPI values\n    if rate_upper not in valid_values:\n        raise InstrumentParameterError(\n            parameter=\"rate\",\n            value=rate,\n            valid_range=valid_values,\n            message=\"Invalid rate.\",\n        )\n    await self._send_command(f\"ACQuire:SRATe {rate_upper}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_time_axis","title":"<code>set_time_axis(scale, position)</code>  <code>async</code>","text":"<p>Sets the time axis of the Oscilloscope. (x-axis)</p> <p>:param scale: scale The scale of the axis in seconds :param position: The position of the time axis from the trigger in seconds</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_time_axis(self, scale: float, position: float) -&gt; None:\n    \"\"\"\n    Sets the time axis of the Oscilloscope. (x-axis)\n\n    :param scale: scale The scale of the axis in seconds\n    :param position: The position of the time axis from the trigger in seconds\n    \"\"\"\n\n    await self._send_command(f':TIMebase:SCALe {scale}')\n    await self._send_command(f':TIMebase:POSition {position}')\n    await self._wait()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wave_gen_amp","title":"<code>set_wave_gen_amp(amp)</code>  <code>async</code>","text":"<p>Set the amplitude for the waveform generator.</p> <p>Args: amp (float): The desired amplitude for the waveform generator in volts.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def set_wave_gen_amp(self, amp: float) -&gt; None:\n    \"\"\"\n    Set the amplitude for the waveform generator.\n\n    Args:\n    amp (float): The desired amplitude for the waveform generator in volts.\n    \"\"\"\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n    self.config.function_generator.amplitude.assert_in_range(amp, name=\"Waveform generator amplitude\")\n    await self._send_command(f\"WGEN:VOLT {amp}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wave_gen_freq","title":"<code>set_wave_gen_freq(freq)</code>  <code>async</code>","text":"<p>Set the frequency for the waveform generator.</p> <p>Args: freq (float): The desired frequency for the waveform generator in Hz.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n##@ConfigRequires(\"function_generator\")\nasync def set_wave_gen_freq(self, freq: float) -&gt; None:\n    \"\"\"\n    Set the frequency for the waveform generator.\n\n    Args:\n    freq (float): The desired frequency for the waveform generator in Hz.\n    \"\"\"\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n    # Assuming RangeMixin's assert_in_range is preferred for validation\n    self.config.function_generator.frequency.assert_in_range(freq, name=\"Waveform generator frequency\")\n    await self._send_command(f\"WGEN:FREQ {freq}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wave_gen_func","title":"<code>set_wave_gen_func(func_type)</code>  <code>async</code>","text":"<p>Set the waveform function for the oscilloscope's waveform generator.</p> <p>Args: func_type (WaveformType): The desired function enum member.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def set_wave_gen_func(self, func_type: WaveformType) -&gt; None:\n    \"\"\"\n    Set the waveform function for the oscilloscope's waveform generator.\n\n    Args:\n    func_type (WaveformType): The desired function enum member.\n    \"\"\"\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n\n    # Check if the SCPI value of the enum is in the list of supported waveform types from config\n    if func_type.value not in self.config.function_generator.waveform_types:\n        raise InstrumentParameterError(\n            parameter=\"func_type\",\n            value=func_type.value,\n            valid_range=self.config.function_generator.waveform_types,\n            message=\"Unsupported waveform type.\",\n        )\n\n    await self._send_command(f\"WGEN:FUNC {func_type.value}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wave_gen_offset","title":"<code>set_wave_gen_offset(offset)</code>  <code>async</code>","text":"<p>Set the voltage offset for the waveform generator.</p> <p>Args: offset (float): The desired voltage offset for the waveform generator in volts.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def set_wave_gen_offset(self, offset: float) -&gt; None:\n    \"\"\"\n    Set the voltage offset for the waveform generator.\n\n    Args:\n    offset (float): The desired voltage offset for the waveform generator in volts.\n    \"\"\"\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n    self.config.function_generator.offset.assert_in_range(offset, name=\"Waveform generator offset\")\n    await self._send_command(f\"WGEN:VOLT:OFFSet {offset}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_dc","title":"<code>set_wgen_dc(offset)</code>  <code>async</code>","text":"<p>Sets the waveform generator to a DC wave.</p> <p>:param offset: The offset of the DC wave in volts</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def set_wgen_dc(self, offset: float) -&gt; None:\n    \"\"\"Sets the waveform generator to a DC wave.\n\n    :param offset: The offset of the DC wave in volts\n    \"\"\"\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n    await self.set_wave_gen_func(WaveformType.DC)\n    await self.set_wave_gen_offset(offset)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_noise","title":"<code>set_wgen_noise(v0, v1, offset)</code>  <code>async</code>","text":"<p>Sets the waveform generator to a noise wave.</p> <p>:param v0: The 'low' amplitude component or similar parameter for noise. :param v1: The 'high' amplitude component or similar parameter for noise. :param offset: The offset of the noise wave in volts.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def set_wgen_noise(self, v0: float, v1: float, offset: float) -&gt; None:\n    \"\"\"Sets the waveform generator to a noise wave.\n\n    :param v0: The 'low' amplitude component or similar parameter for noise.\n    :param v1: The 'high' amplitude component or similar parameter for noise.\n    :param offset: The offset of the noise wave in volts.\n    \"\"\"\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n    await self.set_wave_gen_func(WaveformType.NOISE)\n    await self._send_command(f':WGEN:VOLTage:LOW {v0}')\n    await self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n    await self.set_wave_gen_offset(offset)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_pulse","title":"<code>set_wgen_pulse(v0, v1, period, pulse_width=None, **kwargs)</code>  <code>async</code>","text":"<p>Sets the waveform generator to a pulse wave.</p> <p>:param v0: The voltage of the low state in volts :param v1: The voltage of the high state in volts :param period: The period of the pulse wave in seconds. :param pulse_width: The pulse width in seconds.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def set_wgen_pulse(self, v0: float, v1: float, period: float, pulse_width: Optional[float] = None, **kwargs) -&gt; None:\n    \"\"\"Sets the waveform generator to a pulse wave.\n\n    :param v0: The voltage of the low state in volts\n    :param v1: The voltage of the high state in volts\n    :param period: The period of the pulse wave in seconds.\n    :param pulse_width: The pulse width in seconds.\n    \"\"\"\n    if 'pulseWidth' in kwargs:\n        warnings.warn(\n            \"'pulseWidth' is deprecated, use 'pulse_width' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        pulse_width = kwargs['pulseWidth']\n\n    if pulse_width is None:\n        raise InstrumentParameterError(message=\"pulse_width is required.\")\n\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n    await self.set_wave_gen_func(WaveformType.PULSE)\n\n    await self._send_command(f':WGEN:VOLTage:LOW {v0}')\n    await self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n    await self._send_command(f':WGEN:PERiod {period}')\n    await self._send_command(f':WGEN:FUNCtion:PULSe:WIDTh {pulse_width}')\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_ramp","title":"<code>set_wgen_ramp(v0, v1, freq, symmetry)</code>  <code>async</code>","text":"<p>Sets the waveform generator to a ramp wave.</p> <p>:param v0: The voltage of the low state in volts :param v1: The voltage of the high state in volts :param freq: The frequency of the ramp wave in Hz. :param symmetry: Symmetry (0% to 100%).</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def set_wgen_ramp(self, v0: float, v1: float, freq: float, symmetry: int) -&gt; None:\n    \"\"\"Sets the waveform generator to a ramp wave.\n\n    :param v0: The voltage of the low state in volts\n    :param v1: The voltage of the high state in volts\n    :param freq: The frequency of the ramp wave in Hz.\n    :param symmetry: Symmetry (0% to 100%).\n    \"\"\"\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n    await self.set_wave_gen_func(WaveformType.RAMP)\n    def clamp_symmetry(number: int) -&gt; int:\n        return max(0, min(number, 100))\n\n    await self._send_command(f':WGEN:VOLTage:LOW {v0}')\n    await self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n    await self._send_command(f':WGEN:FREQuency {freq}')\n    await self._send_command(f':WGEN:FUNCtion:RAMP:SYMMetry {clamp_symmetry(symmetry)}')\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_sin","title":"<code>set_wgen_sin(amp, offset, freq)</code>  <code>async</code>","text":"<p>Sets the waveform generator to a sine wave.</p> <p>:param amp: The amplitude of the sine wave in volts :param offset: The offset of the sine wave in volts :param freq: The frequency of the sine wave in Hz.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def set_wgen_sin(self, amp: float, offset: float, freq: float) -&gt; None:\n    \"\"\"Sets the waveform generator to a sine wave.\n\n    :param amp: The amplitude of the sine wave in volts\n    :param offset: The offset of the sine wave in volts\n    :param freq: The frequency of the sine wave in Hz.\n    \"\"\"\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n    await self.set_wave_gen_func(WaveformType.SINE)\n    await self.set_wave_gen_amp(amp)\n    await self.set_wave_gen_offset(offset)\n    await self.set_wave_gen_freq(freq)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_square","title":"<code>set_wgen_square(v0, v1, freq, duty_cycle=None, **kwargs)</code>  <code>async</code>","text":"<p>Sets the waveform generator to a square wave.</p> <p>:param v0: The voltage of the low state in volts :param v1: The voltage of the high state in volts :param freq: The frequency of the square wave in Hz. :param duty_cycle: The duty cycle (1% to 99%).</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def set_wgen_square(self, v0: float, v1: float, freq: float, duty_cycle: Optional[int] = None, **kwargs) -&gt; None:\n    \"\"\"Sets the waveform generator to a square wave.\n\n    :param v0: The voltage of the low state in volts\n    :param v1: The voltage of the high state in volts\n    :param freq: The frequency of the square wave in Hz.\n    :param duty_cycle: The duty cycle (1% to 99%).\n    \"\"\"\n    if 'dutyCycle' in kwargs:\n        warnings.warn(\n            \"'dutyCycle' is deprecated, use 'duty_cycle' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        duty_cycle = kwargs['dutyCycle']\n\n    if duty_cycle is None:\n        duty_cycle = 50\n\n    if self.config.function_generator is None:\n        raise InstrumentConfigurationError(\n            self.config.model, \"Function generator not configured.\"\n        )\n\n    await self.set_wave_gen_func(WaveformType.SQUARE)\n\n    def clamp_duty(number: int) -&gt; int:\n        return max(1, min(number, 99))\n\n    await self._send_command(f':WGEN:VOLTage:LOW {v0}')\n    await self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n    await self._send_command(f':WGEN:FREQuency {freq}')\n    await self._send_command(f':WGEN:FUNCtion:SQUare:DCYCle {clamp_duty(duty_cycle)}')\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Oscilloscope.wave_gen","title":"<code>wave_gen(state)</code>  <code>async</code>","text":"<p>Enable or disable the waveform generator of the oscilloscope.</p> <p>Args: state (bool): True to enable ('ON'), False to disable ('OFF').</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\n#@ConfigRequires(\"function_generator\")\nasync def wave_gen(self, state: bool) -&gt; None:\n    \"\"\"\n    Enable or disable the waveform generator of the oscilloscope.\n\n    Args:\n    state (bool): True to enable ('ON'), False to disable ('OFF').\n    \"\"\"\n    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value\n    await self._send_command(f\"WGEN:OUTP {scpi_state}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble","title":"<code>Preamble(format, type, points, xinc, xorg, xref, yinc, yorg, yref)</code>  <code>dataclass</code>","text":"<p>Holds the waveform preamble data from the oscilloscope.</p> <p>The preamble contains all the necessary metadata to convert the raw, digitized ADC values from the oscilloscope into meaningful time and voltage arrays. It describes the scaling and offset factors for both the X (time) and Y (voltage) axes.</p> ATTRIBUTE DESCRIPTION <code>format</code> <p>Data format (e.g., 'BYTE', 'WORD').</p> <p> TYPE: <code>str</code> </p> <code>type</code> <p>Acquisition type (e.g., 'NORMal', 'AVERage').</p> <p> TYPE: <code>str</code> </p> <code>points</code> <p>The number of data points in the waveform.</p> <p> TYPE: <code>int</code> </p> <code>xinc</code> <p>The time difference between adjacent data points (sampling interval).</p> <p> TYPE: <code>float</code> </p> <code>xorg</code> <p>The time value of the first data point.</p> <p> TYPE: <code>float</code> </p> <code>xref</code> <p>The reference time point (usually the trigger point).</p> <p> TYPE: <code>float</code> </p> <code>yinc</code> <p>The voltage difference for each ADC level (voltage resolution).</p> <p> TYPE: <code>float</code> </p> <code>yorg</code> <p>The voltage value at the vertical center of the screen.</p> <p> TYPE: <code>float</code> </p> <code>yref</code> <p>The ADC level corresponding to the vertical center.</p> <p> TYPE: <code>float</code> </p>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble.format","title":"<code>format</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble.points","title":"<code>points</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble.type","title":"<code>type</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble.xinc","title":"<code>xinc</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble.xorg","title":"<code>xorg</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble.xref","title":"<code>xref</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble.yinc","title":"<code>yinc</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble.yorg","title":"<code>yorg</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble.yref","title":"<code>yref</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.Preamble-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade","title":"<code>ScopeAcquisitionFacade(scope)</code>","text":"<p>Provides a simplified interface for the oscilloscope's acquisition system.</p> <p>This facade manages settings related to how the oscilloscope digitizes signals, including acquisition type (e.g., Normal, Averaging), memory mode (Real-time vs. Segmented), and sample rates.</p> ATTRIBUTE DESCRIPTION <code>_scope</code> <p>The parent <code>Oscilloscope</code> instance.</p> <p> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>def __init__(self, scope: 'Oscilloscope'):\n    self._scope = scope\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.analyze_all_segments","title":"<code>analyze_all_segments()</code>  <code>async</code>","text":"<p>Execute the scope's Analyze Segments soft-key. Requires scope to be stopped and in SEGMENTED mode.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def analyze_all_segments(self) -&gt; None:\n    \"\"\"\n    Execute the scope's *Analyze Segments* soft-key.\n    Requires scope to be stopped and in SEGMENTED mode.\n    \"\"\"\n    if await self.get_acquisition_mode() != \"SEGMENTED\":\n        raise InstrumentParameterError(\n            message=\"Segment analysis requires SEGMENTED mode.\"\n        )\n    await self._scope._send_command(\":ACQuire:SEGMented:ANALyze\")\n    await self._scope._wait()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquire_points","title":"<code>get_acquire_points()</code>  <code>async</code>","text":"<p>Hardware points actually acquired for the next waveform transfer.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_acquire_points(self) -&gt; int:\n    \"\"\"\n    Hardware points actually *acquired* for the next waveform transfer.\n    \"\"\"\n    return int(await self._scope._query(\":ACQuire:POINts?\"))\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquire_setup","title":"<code>get_acquire_setup()</code>  <code>async</code>","text":"<p>Return a parsed dictionary of the scope's :ACQuire? status string.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_acquire_setup(self) -&gt; Dict[str, str]:\n    \"\"\"\n    Return a parsed dictionary of the scope's :ACQuire? status string.\n    \"\"\"\n    raw_str: str = (await self._scope._query(\":ACQuire?\")).strip()\n    parts: List[str] = [p.strip() for p in raw_str.split(';')]\n    setup_dict: Dict[str, str] = {}\n    for part in parts:\n        kv = part.split(maxsplit=1)\n        if len(kv) == 2:\n            setup_dict[kv[0]] = kv[1]\n    return setup_dict\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquisition_average_count","title":"<code>get_acquisition_average_count()</code>  <code>async</code>","text":"<p>Integer average count (valid only when acquisition type == AVERAGE).</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_acquisition_average_count(self) -&gt; int:\n    \"\"\"Integer average count (valid only when acquisition type == AVERAGE).\"\"\"\n    return int(await self._scope._query(\":ACQuire:COUNt?\"))\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquisition_mode","title":"<code>get_acquisition_mode()</code>  <code>async</code>","text":"<p>Return \"REAL_TIME\" or \"SEGMENTED\".</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_acquisition_mode(self) -&gt; str:\n    \"\"\"Return \"REAL_TIME\" or \"SEGMENTED\".\"\"\"\n    resp_str_raw: str = (await self._scope._query(\":ACQuire:MODE?\")).strip()\n    for friendly_name, scpi_command_str in _ACQ_MODE_MAP.items():\n        if resp_str_raw.upper().startswith(scpi_command_str.upper()[:4]):\n            return friendly_name\n    self._scope._logger.warning(f\"Could not map SCPI response '{resp_str_raw}' to a known AcquisitionMode. Returning raw response.\")\n    return resp_str_raw\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquisition_sample_rate","title":"<code>get_acquisition_sample_rate()</code>  <code>async</code>","text":"<p>Current sample rate of acquisition. Equivalent to get_sampling_rate().</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_acquisition_sample_rate(self) -&gt; float:\n    \"\"\"\n    Current sample rate of acquisition. Equivalent to get_sampling_rate().\n    \"\"\"\n    return float(await self._scope._query(\":ACQuire:SRATe?\"))\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquisition_type","title":"<code>get_acquisition_type()</code>  <code>async</code>","text":"<p>Returns current acquisition type (e.g., \"NORMAL\", \"AVERAGE\").</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_acquisition_type(self) -&gt; str:\n    \"\"\"\n    Returns current acquisition type (e.g., \"NORMAL\", \"AVERAGE\").\n    \"\"\"\n    # Invert _ACQ_TYPE_MAP for lookup: SCPI response -&gt; Enum member name\n    # SCPI responses can be short forms (e.g., \"NORM\" for \"NORMal\")\n    # We need to match based on how the instrument actually responds.\n    # A common way is that instrument responds with the short form.\n    # Let's assume the instrument responds with a value that can be mapped back.\n    resp_str_raw: str = (await self._scope._query(\":ACQuire:TYPE?\")).strip()\n\n    for enum_member, scpi_command_str in _ACQ_TYPE_MAP.items():\n        # Check if the response starts with the typical short SCPI command part\n        # e.g. \"NORM\" from \"NORMal\"\n        # This matching logic might need to be more robust based on actual instrument behavior\n        if resp_str_raw.upper().startswith(scpi_command_str.upper()[:4]): # Compare first 4 chars\n            return enum_member.name # Return the string name of the enum member\n\n    self._scope._logger.warning(f\"Could not map SCPI response '{resp_str_raw}' to a known AcquisitionType. Returning raw response.\")\n    return resp_str_raw # Fallback to raw response if no match\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_segment_index","title":"<code>get_segment_index()</code>  <code>async</code>","text":"<p>Index (1-based) of the currently selected memory segment.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_segment_index(self) -&gt; int:\n    \"\"\"Index (1-based) of the currently selected memory segment.\"\"\"\n    return int(await self._scope._query(\":ACQuire:SEGMented:INDex?\"))\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_segmented_count","title":"<code>get_segmented_count()</code>  <code>async</code>","text":"<p>Number of segments currently configured (SEGMENTED mode only).</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def get_segmented_count(self) -&gt; int:\n    \"\"\"Number of segments currently configured (SEGMENTED mode only).\"\"\"\n    return int(await self._scope._query(\":ACQuire:SEGMented:COUNt?\"))\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_acquisition_average_count","title":"<code>set_acquisition_average_count(count)</code>  <code>async</code>","text":"<p>Set the running-average length for AVERAGE mode. 2 &lt;= count &lt;= 65536 (Keysight limit).</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_acquisition_average_count(self, count: int) -&gt; None:\n    \"\"\"\n    Set the running-average length for AVERAGE mode.\n    2 &lt;= count &lt;= 65536 (Keysight limit).\n    \"\"\"\n    await _validate_range(count, 2, 65_536, \"Average count\") # Sync\n\n    current_acq_type_str = await self.get_acquisition_type()\n    if current_acq_type_str != AcquisitionType.AVERAGE.name:\n        raise InstrumentParameterError(\n            parameter=\"count\",\n            message=f\"Average count can only be set when acquisition type is AVERAGE, not {current_acq_type_str}.\",\n        )\n    await self._scope._send_command(f\":ACQuire:COUNt {count}\")\n    await self._scope._wait()\n    self._scope._logger.debug(f\"AVERAGE count set \u2192 {count}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_acquisition_mode","title":"<code>set_acquisition_mode(mode)</code>  <code>async</code>","text":"<p>Select real-time or segmented memory acquisition. (Case-insensitive for mode).</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_acquisition_mode(self, mode: str) -&gt; None:\n    \"\"\"\n    Select real-time or segmented memory acquisition.\n    (Case-insensitive for mode).\n    \"\"\"\n    mode_upper: str = mode.upper()\n    scpi_mode_val = _ACQ_MODE_MAP.get(mode_upper)\n    if not scpi_mode_val:\n        raise InstrumentParameterError(\n            parameter=\"mode\",\n            value=mode,\n            valid_range=list(_ACQ_MODE_MAP.keys()),\n            message=\"Unknown acquisition mode.\",\n        )\n\n    await self._scope._send_command(f\":ACQuire:MODE {scpi_mode_val}\")\n    await self._scope._wait()\n    self._scope._logger.debug(f\"Acquisition MODE set \u2192 {mode_upper}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_acquisition_type","title":"<code>set_acquisition_type(acq_type)</code>  <code>async</code>","text":"<p>Select the oscilloscope acquisition algorithm.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_acquisition_type(self, acq_type: AcquisitionType) -&gt; None:\n    \"\"\"\n    Select the oscilloscope acquisition algorithm.\n    \"\"\"\n    scpi_val = _ACQ_TYPE_MAP.get(acq_type)\n    if not scpi_val:\n        raise InstrumentParameterError(\n            parameter=\"acq_type\",\n            value=acq_type,\n            message=\"Unsupported acquisition type enum member.\",\n        )\n\n    current_mode_query: str = (await self._scope._query(\":ACQuire:MODE?\")).strip().upper()\n    if acq_type == AcquisitionType.AVERAGE and current_mode_query == _ACQ_MODE_MAP[\"SEGMENTED\"].upper()[:4]:\n        raise InstrumentParameterError(\n            parameter=\"acq_type\",\n            value=\"AVERAGE\",\n            message=\"AVERAGE mode is unavailable in SEGMENTED acquisition.\",\n        )\n\n    await self._scope._send_command(f\":ACQuire:TYPE {scpi_val}\")\n    await self._scope._wait()\n    self._scope._logger.debug(f\"Acquisition TYPE set \u2192 {acq_type.name}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_segment_index","title":"<code>set_segment_index(index)</code>  <code>async</code>","text":"<p>Select which memory segment is active for readback. 1 &lt;= index &lt;= get_segmented_count()</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_segment_index(self, index: int) -&gt; None:\n    \"\"\"\n    Select which memory segment is active for readback.\n    1 &lt;= index &lt;= get_segmented_count()\n    \"\"\"\n    total_segments: int = await self.get_segmented_count()\n    await _validate_range(index, 1, total_segments, \"Segment index\") # Sync\n    await self._scope._send_command(f\":ACQuire:SEGMented:INDex {index}\")\n    await self._scope._wait()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_segmented_count","title":"<code>set_segmented_count(count)</code>  <code>async</code>","text":"<p>Configure number of memory segments for SEGMENTED acquisitions. Default Keysight limit: 2 &lt;= count &lt;= 500 (check instrument specs)</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def set_segmented_count(self, count: int) -&gt; None:\n    \"\"\"\n    Configure number of memory segments for SEGMENTED acquisitions.\n    Default Keysight limit: 2 &lt;= count &lt;= 500 (check instrument specs)\n    \"\"\"\n    if await self.get_acquisition_mode() != \"SEGMENTED\":\n        raise InstrumentParameterError(\n            parameter=\"count\",\n            message=\"Segmented count can only be set while in SEGMENTED acquisition mode.\",\n        )\n    await _validate_range(count, 2, 500, \"Segmented count\") # Sync\n    await self._scope._send_command(f\":ACQuire:SEGMented:COUNt {count}\")\n    await self._scope._wait()\n    self._scope._logger.debug(f\"Segmented COUNT set \u2192 {count}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeChannelFacade","title":"<code>ScopeChannelFacade(scope, channel_num)</code>","text":"<p>Provides a simplified, chainable interface for a single oscilloscope channel.</p> <p>This facade abstracts the underlying SCPI commands for common channel operations, allowing for more readable and fluent test scripts. For example: <code>await scope.channel(1).setup(scale=0.5, offset=0).enable()</code></p> ATTRIBUTE DESCRIPTION <code>_scope</code> <p>The parent <code>Oscilloscope</code> instance.</p> <p> </p> <code>_channel</code> <p>The channel number this facade controls.</p> <p> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>def __init__(self, scope: 'Oscilloscope', channel_num: int):\n    self._scope = scope\n    self._channel = channel_num\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeChannelFacade-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeChannelFacade.disable","title":"<code>disable()</code>  <code>async</code>","text":"<p>Disables the channel display.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>async def disable(self) -&gt; Self:\n    \"\"\"Disables the channel display.\"\"\"\n    await self._scope.display_channel(self._channel, False)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeChannelFacade.enable","title":"<code>enable()</code>  <code>async</code>","text":"<p>Enables the channel display.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>async def enable(self) -&gt; Self:\n    \"\"\"Enables the channel display.\"\"\"\n    await self._scope.display_channel(self._channel, True)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeChannelFacade.measure_peak_to_peak","title":"<code>measure_peak_to_peak()</code>  <code>async</code>","text":"<p>Performs a peak-to-peak voltage measurement on this channel.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>async def measure_peak_to_peak(self) -&gt; MeasurementResult:\n    \"\"\"Performs a peak-to-peak voltage measurement on this channel.\"\"\"\n    return await self._scope.measure_voltage_peak_to_peak(self._channel)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeChannelFacade.measure_rms","title":"<code>measure_rms()</code>  <code>async</code>","text":"<p>Performs an RMS voltage measurement on this channel.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>async def measure_rms(self) -&gt; MeasurementResult:\n    \"\"\"Performs an RMS voltage measurement on this channel.\"\"\"\n    return await self._scope.measure_rms_voltage(self._channel)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeChannelFacade.setup","title":"<code>setup(scale=None, position=None, offset=None, coupling=None, probe_attenuation=None, bandwidth_limit=None)</code>  <code>async</code>","text":"<p>Configures multiple settings for the channel in a single call.</p> <p>This method allows setting the vertical scale, position/offset, coupling, probe attenuation, and bandwidth limit. Any parameter left as <code>None</code> will not be changed.</p> PARAMETER DESCRIPTION <code>scale</code> <p>The vertical scale in volts per division.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>position</code> <p>The vertical position in divisions from the center.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>offset</code> <p>The vertical offset in volts. 'offset' is often preferred     over 'position' as it's independent of the scale.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>coupling</code> <p>The input coupling (\"AC\" or \"DC\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>probe_attenuation</code> <p>The attenuation factor of the probe (e.g., 10 for 10:1).</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>bandwidth_limit</code> <p>The bandwidth limit to apply (e.g., \"20M\" or 20e6).</p> <p> TYPE: <code>Optional[Union[str, float]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The <code>ScopeChannelFacade</code> instance for method chaining.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def setup(self, scale: Optional[float] = None, position: Optional[float] = None, offset: Optional[float] = None, coupling: Optional[str] = None, probe_attenuation: Optional[int] = None, bandwidth_limit: Optional[Union[str, float]] = None) -&gt; Self:\n    \"\"\"Configures multiple settings for the channel in a single call.\n\n    This method allows setting the vertical scale, position/offset, coupling,\n    probe attenuation, and bandwidth limit. Any parameter left as `None` will\n    not be changed.\n\n    Args:\n        scale: The vertical scale in volts per division.\n        position: The vertical position in divisions from the center.\n        offset: The vertical offset in volts. 'offset' is often preferred\n                over 'position' as it's independent of the scale.\n        coupling: The input coupling (\"AC\" or \"DC\").\n        probe_attenuation: The attenuation factor of the probe (e.g., 10 for 10:1).\n        bandwidth_limit: The bandwidth limit to apply (e.g., \"20M\" or 20e6).\n\n    Returns:\n        The `ScopeChannelFacade` instance for method chaining.\n    \"\"\"\n    if scale is not None:\n        current_offset_val = (await self._scope.get_channel_axis(self._channel))[1] if offset is None and position is None else (offset or position or 0.0)\n        await self._scope.set_channel_axis(self._channel, scale, current_offset_val)\n    elif position is not None or offset is not None: # only position/offset is set\n        val_to_set = position if position is not None else offset\n        current_scale_val = (await self._scope.get_channel_axis(self._channel))[0]\n        await self._scope.set_channel_axis(self._channel, current_scale_val, val_to_set)\n\n    if coupling is not None:\n        await self._scope._send_command(f\":CHANnel{self._channel}:COUPling {coupling.upper()}\")\n        self._scope._logger.debug(f\"Channel {self._channel} coupling set to {coupling.upper()}\")\n\n    if probe_attenuation is not None:\n        await self._scope.set_probe_attenuation(self._channel, probe_attenuation)\n\n    if bandwidth_limit is not None:\n        await self._scope.set_bandwidth_limit(self._channel, bandwidth_limit)\n\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeTriggerFacade","title":"<code>ScopeTriggerFacade(scope)</code>","text":"<p>Provides a simplified, chainable interface for the oscilloscope's trigger system.</p> <p>This facade abstracts the underlying SCPI commands for trigger operations, focusing on common use cases like setting up an edge trigger.</p> ATTRIBUTE DESCRIPTION <code>_scope</code> <p>The parent <code>Oscilloscope</code> instance.</p> <p> </p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>def __init__(self, scope: 'Oscilloscope'):\n    self._scope = scope\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeTriggerFacade-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.Oscilloscope.ScopeTriggerFacade.setup_edge","title":"<code>setup_edge(source, level, slope=TriggerSlope.POSITIVE, coupling=None, mode='EDGE')</code>  <code>async</code>","text":"<p>Configures a standard edge trigger.</p> PARAMETER DESCRIPTION <code>source</code> <p>The trigger source (e.g., \"CH1\", \"CH2\", \"EXT\", \"LINE\").</p> <p> TYPE: <code>str</code> </p> <code>level</code> <p>The trigger level in volts.</p> <p> TYPE: <code>float</code> </p> <code>slope</code> <p>The trigger slope (<code>TriggerSlope.POSITIVE</code>, <code>NEGATIVE</code>, or <code>EITHER</code>).</p> <p> TYPE: <code>TriggerSlope</code> DEFAULT: <code>POSITIVE</code> </p> <code>coupling</code> <p>The trigger coupling (e.g., \"AC\", \"DC\"). Can be instrument-specific.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>mode</code> <p>The trigger mode, defaults to \"EDGE\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'EDGE'</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The <code>ScopeTriggerFacade</code> instance for method chaining.</p> Source code in <code>pytestlab/instruments/Oscilloscope.py</code> <pre><code>@validate_call\nasync def setup_edge(self, source: str, level: float, slope: TriggerSlope = TriggerSlope.POSITIVE, coupling: Optional[str] = None, mode: str = \"EDGE\") -&gt; Self:\n    \"\"\"Configures a standard edge trigger.\n\n    Args:\n        source: The trigger source (e.g., \"CH1\", \"CH2\", \"EXT\", \"LINE\").\n        level: The trigger level in volts.\n        slope: The trigger slope (`TriggerSlope.POSITIVE`, `NEGATIVE`, or `EITHER`).\n        coupling: The trigger coupling (e.g., \"AC\", \"DC\"). Can be instrument-specific.\n        mode: The trigger mode, defaults to \"EDGE\".\n\n    Returns:\n        The `ScopeTriggerFacade` instance for method chaining.\n    \"\"\"\n    # Determine channel number if source is like 'CH1' for the level command\n    trigger_channel_for_level = 1 # Default or fallback\n    if source.upper().startswith(\"CHAN\"):\n        try:\n            trigger_channel_for_level = int(source[len(\"CHAN\"):])\n        except ValueError:\n            raise InstrumentParameterError(\n                parameter=\"source\",\n                value=source,\n                message=\"Invalid trigger source format for channel.\",\n            )\n    elif source.upper().startswith(\"CH\"):\n        try:\n            trigger_channel_for_level = int(source[len(\"CH\"):])\n        except ValueError:\n            raise InstrumentParameterError(\n                parameter=\"source\",\n                value=source,\n                message=\"Invalid trigger source format for channel.\",\n            )\n\n    # The main configure_trigger method handles source validation and mapping.\n    await self._scope.configure_trigger(\n        channel=trigger_channel_for_level, # This is for the :TRIGger:LEVel CHANnel&lt;n&gt; part\n        level=level,\n        source=source, # This is for :TRIGger:SOURce part\n        slope=slope,\n        mode=mode\n    )\n    # Coupling for trigger is often separate, e.g., :TRIGger:COUPling\n    if coupling is not None:\n        await self._scope._send_command(f\":TRIGger:{mode.upper()}:COUPling {coupling.upper()}\") # Assuming edge trigger coupling\n        self._scope._logger.debug(f\"Trigger coupling set to {coupling.upper()}\")\n    return self\n</code></pre>"},{"location":"api/instruments/#power-supply","title":"Power Supply","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply","title":"<code>pytestlab.instruments.PowerSupply</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply-classes","title":"Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelConfig","title":"<code>PSUChannelConfig(voltage, current, state)</code>","text":"<p>A data class to hold the measured configuration of a single PSU channel.</p> <p>This class is used to structure the data returned by <code>get_configuration</code>, providing a snapshot of a channel's state. It is not a Pydantic model for loading configurations from files.</p> ATTRIBUTE DESCRIPTION <code>voltage</code> <p>The measured voltage of the channel.</p> <p> TYPE: <code>float | UFloat</code> </p> <code>current</code> <p>The measured current of the channel.</p> <p> TYPE: <code>float | UFloat</code> </p> <code>state</code> <p>The output state of the channel (\"ON\" or \"OFF\").</p> <p> TYPE: <code>str</code> </p> <p>Initializes the PSUChannelConfig.</p> PARAMETER DESCRIPTION <code>voltage</code> <p>The voltage value for the channel.</p> <p> TYPE: <code>float | UFloat</code> </p> <code>current</code> <p>The current value for the channel.</p> <p> TYPE: <code>float | UFloat</code> </p> <code>state</code> <p>The state of the channel (e.g., 0, 1, \"ON\", \"OFF\").</p> <p> TYPE: <code>Union[int, str]</code> </p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>def __init__(self, voltage: float | UFloat, current: float | UFloat, state: Union[int, str]) -&gt; None:\n    \"\"\"Initializes the PSUChannelConfig.\n\n    Args:\n        voltage: The voltage value for the channel.\n        current: The current value for the channel.\n        state: The state of the channel (e.g., 0, 1, \"ON\", \"OFF\").\n    \"\"\"\n    self.voltage: float | UFloat = voltage\n    self.current: float | UFloat = current\n    self.state: str # Store state as string \"ON\" or \"OFF\" for consistency\n    if isinstance(state, str):\n        # Normalize state from various string inputs like \"1\", \"0\", \"ON\", \"OFF\"\n        state_upper = state.upper().strip()\n        if state_upper == SCPIOnOff.ON.value or state_upper == \"1\":\n            self.state = SCPIOnOff.ON.value\n        elif state_upper == SCPIOnOff.OFF.value or state_upper == \"0\":\n            self.state = SCPIOnOff.OFF.value\n        else:\n            raise ValueError(f\"Invalid string state value: {state}\")\n    elif isinstance(state, (int, float)): # float for query results that might be like 1.0\n         self.state = SCPIOnOff.ON.value if int(state) == 1 else SCPIOnOff.OFF.value\n    else:\n        raise ValueError(f\"Invalid state value type: {type(state)}, value: {state}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelConfig-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelConfig.current","title":"<code>current = current</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelConfig.state","title":"<code>state</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelConfig.voltage","title":"<code>voltage = voltage</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelConfig-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelConfig.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"PSUChannelConfig(voltage={self.voltage!r}, current={self.current!r}, state='{self.state}')\"\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelFacade","title":"<code>PSUChannelFacade(psu, channel_num)</code>","text":"<p>Provides a simplified, chainable interface for a single PSU channel.</p> <p>This facade abstracts the underlying SCPI commands for common channel operations, allowing for more readable and fluent test scripts. For example: <code>await psu.channel(1).set(voltage=5.0, current_limit=0.1).on()</code></p> ATTRIBUTE DESCRIPTION <code>_psu</code> <p>The parent <code>PowerSupply</code> instance.</p> <p> </p> <code>_channel</code> <p>The channel number (1-based) this facade controls.</p> <p> </p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>def __init__(self, psu: 'PowerSupply', channel_num: int):\n    self._psu = psu\n    self._channel = channel_num\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelFacade-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelFacade.get_current","title":"<code>get_current()</code>  <code>async</code>","text":"<p>Reads the measured current from this channel.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>async def get_current(self) -&gt; float | UFloat:\n    \"\"\"Reads the measured current from this channel.\"\"\"\n    return await self._psu.read_current(self._channel)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelFacade.get_output_state","title":"<code>get_output_state()</code>  <code>async</code>","text":"<p>Checks if the channel output is enabled (ON).</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the output is on, False otherwise.</p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If the instrument returns an unexpected state.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>async def get_output_state(self) -&gt; bool:\n    \"\"\"Checks if the channel output is enabled (ON).\n\n    Returns:\n        True if the output is on, False otherwise.\n\n    Raises:\n        InstrumentParameterError: If the instrument returns an unexpected state.\n    \"\"\"\n    command = f\"{self._psu.SCPI_MAP.OUTPUT_STATE_QUERY_BASE} (@{self._channel})\"\n    state_str = (await self._psu._query(command)).strip().upper()\n    if state_str in (\"1\", \"ON\"):\n        return True\n    elif state_str in (\"0\", \"OFF\"):\n        return False\n    raise InstrumentParameterError(f\"Unexpected output state '{state_str}' for channel {self._channel}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelFacade.get_voltage","title":"<code>get_voltage()</code>  <code>async</code>","text":"<p>Reads the measured voltage from this channel.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>async def get_voltage(self) -&gt; float | UFloat:\n    \"\"\"Reads the measured voltage from this channel.\"\"\"\n    return await self._psu.read_voltage(self._channel)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelFacade.off","title":"<code>off()</code>  <code>async</code>","text":"<p>Disables the output of this channel.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>async def off(self) -&gt; Self:\n    \"\"\"Disables the output of this channel.\"\"\"\n    await self._psu.output(self._channel, False)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelFacade.on","title":"<code>on()</code>  <code>async</code>","text":"<p>Enables the output of this channel.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>async def on(self) -&gt; Self:\n    \"\"\"Enables the output of this channel.\"\"\"\n    await self._psu.output(self._channel, True)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PSUChannelFacade.set","title":"<code>set(voltage=None, current_limit=None)</code>  <code>async</code>","text":"<p>Sets the voltage and/or current limit for this channel.</p> PARAMETER DESCRIPTION <code>voltage</code> <p>The target voltage in Volts.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>current_limit</code> <p>The current limit in Amperes.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The <code>PSUChannelFacade</code> instance for method chaining.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@validate_call\nasync def set(self, voltage: Optional[float] = None, current_limit: Optional[float] = None) -&gt; Self:\n    \"\"\"Sets the voltage and/or current limit for this channel.\n\n    Args:\n        voltage: The target voltage in Volts.\n        current_limit: The current limit in Amperes.\n\n    Returns:\n        The `PSUChannelFacade` instance for method chaining.\n    \"\"\"\n    if voltage is not None:\n        await self._psu.set_voltage(self._channel, voltage)\n    if current_limit is not None:\n        await self._psu.set_current(self._channel, current_limit)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply","title":"<code>PowerSupply(config, backend, **kwargs)</code>","text":"<p>               Bases: <code>Instrument[PowerSupplyConfig]</code></p> <p>Drives a multi-channel Power Supply Unit (PSU).</p> <p>This class provides a high-level interface for controlling a programmable power supply. It builds upon the base <code>Instrument</code> class and adds methods for setting and reading voltage and current on a per-channel basis. It also supports incorporating measurement uncertainty if configured.</p> <p>A key feature is the <code>channel()</code> method, which returns a <code>PSUChannelFacade</code> for a simplified, chainable programming experience.</p> ATTRIBUTE DESCRIPTION <code>config</code> <p>The Pydantic configuration object (<code>PowerSupplyConfig</code>)     containing settings specific to this PSU.</p> <p> TYPE: <code>PowerSupplyConfig</code> </p> <code>SCPI_MAP</code> <p>An object that maps generic functions to model-specific SCPI commands.</p> <p> </p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO\n    \"\"\"\n    Initialize the Instrument class.\n\n    Args:\n        config (ConfigType): Configuration for the instrument.\n        backend (AsyncInstrumentIO): The communication backend instance.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    if not isinstance(config, InstrumentConfig): # Check against the bound base\n        raise InstrumentConfigurationError(\n            self.__class__.__name__,\n            f\"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.\",\n        )\n\n    self.config = config\n    self._backend = backend # This will be an AsyncInstrumentIO instance\n    self._command_log = []\n\n    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__\n    self._logger = get_logger(logger_name)\n\n    self._logger.info(f\"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.SCPI_MAP","title":"<code>SCPI_MAP = KeysightEDU36311APSU_SCPI()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.config","title":"<code>config</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.model_config","title":"<code>model_config = {'arbitrary_types_allowed': True}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.channel","title":"<code>channel(ch_num)</code>","text":"<p>Returns a facade for interacting with a specific channel.</p> PARAMETER DESCRIPTION <code>ch_num</code> <p>The channel number (1-based).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>PSUChannelFacade</code> <p>A facade object for the specified channel.</p> <p> TYPE: <code>PSUChannelFacade</code> </p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If channel number is invalid.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@validate_call\ndef channel(self, ch_num: int) -&gt; PSUChannelFacade:\n    \"\"\"\n    Returns a facade for interacting with a specific channel.\n\n    Args:\n        ch_num (int): The channel number (1-based).\n\n    Returns:\n        PSUChannelFacade: A facade object for the specified channel.\n\n    Raises:\n        InstrumentParameterError: If channel number is invalid.\n    \"\"\"\n    if not self.config.channels or not (1 &lt;= ch_num &lt;= len(self.config.channels)):\n        num_ch = len(self.config.channels) if self.config.channels else 0\n        raise InstrumentParameterError(f\"Channel number {ch_num} is out of range (1-{num_ch}).\")\n    return PSUChannelFacade(self, ch_num)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.display","title":"<code>display(state)</code>  <code>async</code>","text":"<p>Enables or disables the instrument's front panel display.</p> PARAMETER DESCRIPTION <code>state</code> <p>True to turn the display on, False to turn it off.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@validate_call\nasync def display(self, state: bool) -&gt; None:\n    \"\"\"Enables or disables the instrument's front panel display.\n\n    Args:\n        state: True to turn the display on, False to turn it off.\n    \"\"\"\n    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value\n    await self._send_command(f\"DISP {scpi_state}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.from_config","title":"<code>from_config(config, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@classmethod\ndef from_config(cls: Type['PowerSupply'], config: PowerSupplyConfig, **kwargs: Any) -&gt; 'PowerSupply':\n    return cls(config=config, **kwargs)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.get_configuration","title":"<code>get_configuration()</code>  <code>async</code>","text":"<p>Reads the live state of all configured PSU channels.</p> <p>This method iterates through all channels defined in the configuration, queries their current voltage, current, and output state, and returns the collected data.</p> RETURNS DESCRIPTION <code>Dict[int, PSUChannelConfig]</code> <p>A dictionary where keys are channel numbers (1-based) and values are</p> <code>Dict[int, PSUChannelConfig]</code> <p><code>PSUChannelConfig</code> objects representing the state of each channel.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@validate_call\nasync def get_configuration(self) -&gt; Dict[int, PSUChannelConfig]:\n    \"\"\"Reads the live state of all configured PSU channels.\n\n    This method iterates through all channels defined in the configuration,\n    queries their current voltage, current, and output state, and returns\n    the collected data.\n\n    Returns:\n        A dictionary where keys are channel numbers (1-based) and values are\n        `PSUChannelConfig` objects representing the state of each channel.\n    \"\"\"\n    results: Dict[int, PSUChannelConfig] = {}\n    if not self.config.channels:\n        self._logger.warning(\"No channels defined in the PowerSupplyConfig. Cannot get configuration.\")\n        return results\n\n    num_channels = len(self.config.channels)\n\n    for channel_num in range(1, num_channels + 1): # Iterate 1-indexed channel numbers\n        voltage_val: float | UFloat = await self.read_voltage(channel_num) # Already uses @validate_call\n        current_val: float | UFloat = await self.read_current(channel_num) # Already uses @validate_call\n        # Query output state using SCPI_MAP\n        output_state_command = f\"{self.SCPI_MAP.OUTPUT_STATE_QUERY_BASE} (@{channel_num})\"\n        state_str: str = await self._query(output_state_command)\n\n        results[channel_num] = PSUChannelConfig(\n            voltage=voltage_val,\n            current=current_val,\n            state=state_str.strip()\n        )\n    return results\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.id","title":"<code>id()</code>  <code>async</code>","text":"<p>Queries the instrument identification string.</p> RETURNS DESCRIPTION <code>str</code> <p>The instrument identification string.</p> <p> TYPE: <code>str</code> </p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>async def id(self) -&gt; str:\n    \"\"\"\n    Queries the instrument identification string.\n\n    Returns:\n        str: The instrument identification string.\n    \"\"\"\n    return await self._query(self.SCPI_MAP.IDN)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.output","title":"<code>output(channel, state=True)</code>  <code>async</code>","text":"<p>Enables or disables the output for one or more channels.</p> PARAMETER DESCRIPTION <code>channel</code> <p>A single channel number (1-based) or a list of channel numbers.</p> <p> TYPE: <code>Union[int, List[int]]</code> </p> <code>state</code> <p>True to enable the output (ON), False to disable (OFF).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If any channel number is invalid.</p> <code>ValueError</code> <p>If the <code>channel</code> argument is not an int or a list of ints.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@validate_call\nasync def output(self, channel: Union[int, List[int]], state: bool = True) -&gt; None:\n    \"\"\"Enables or disables the output for one or more channels.\n\n    Args:\n        channel: A single channel number (1-based) or a list of channel numbers.\n        state: True to enable the output (ON), False to disable (OFF).\n\n    Raises:\n        InstrumentParameterError: If any channel number is invalid.\n        ValueError: If the `channel` argument is not an int or a list of ints.\n    \"\"\"\n    channels_to_process: List[int]\n    if isinstance(channel, int):\n        channels_to_process = [channel]\n    elif isinstance(channel, list):\n        # Ensure all elements in the list are integers\n        if not all(isinstance(ch, int) for ch in channel):\n            raise ValueError(\"All elements in channel list must be integers.\")\n        channels_to_process = channel\n    else:\n        # This case should ideally be caught by validate_call if type hints are precise enough,\n        # but an explicit check remains good practice.\n        raise ValueError(f\"Invalid channel type: {type(channel)}. Expected int or List[int].\")\n\n    num_configured_channels = len(self.config.channels) if self.config.channels else 0\n    for ch_num in channels_to_process:\n        if not (1 &lt;= ch_num &lt;= num_configured_channels):\n            raise InstrumentParameterError(f\"Channel number {ch_num} is out of range (1-{num_configured_channels}).\")\n\n    argument = \",\".join(map(str, channels_to_process))\n    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value\n    command = f\"{self.SCPI_MAP.OUTPUT_STATE_SET_BASE} {scpi_state}, (@{argument})\"\n    await self._send_command(command)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.read_current","title":"<code>read_current(channel)</code>  <code>async</code>","text":"<p>Reads the measured output current from a specific channel.</p> <p>If measurement accuracy is defined in the configuration, this method will return a <code>UFloat</code> object containing the value and its uncertainty. Otherwise, it returns a standard float.</p> PARAMETER DESCRIPTION <code>channel</code> <p>The channel number to measure (1-based).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>float | UFloat</code> <p>The measured current as a float or <code>UFloat</code>.</p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If the channel number is invalid.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@validate_call\nasync def read_current(self, channel: int) -&gt; float | UFloat:\n    \"\"\"Reads the measured output current from a specific channel.\n\n    If measurement accuracy is defined in the configuration, this method\n    will return a `UFloat` object containing the value and its uncertainty.\n    Otherwise, it returns a standard float.\n\n    Args:\n        channel: The channel number to measure (1-based).\n\n    Returns:\n        The measured current as a float or `UFloat`.\n\n    Raises:\n        InstrumentParameterError: If the channel number is invalid.\n    \"\"\"\n    if not self.config.channels or not (1 &lt;= channel &lt;= len(self.config.channels)):\n        num_ch = len(self.config.channels) if self.config.channels else 0\n        raise InstrumentParameterError(f\"Channel number {channel} is out of range (1-{num_ch}).\")\n    command = f\"{self.SCPI_MAP.MEAS_CURRENT_QUERY_BASE} (@{channel})\"\n    response_str: str = await self._query(command)\n    reading: float = float(response_str)\n\n    value_to_return: float | UFloat = reading\n\n    if self.config.measurement_accuracy:\n        mode_key = f\"read_current_ch{channel}\"\n        self._logger.debug(f\"Attempting to find accuracy spec for read_current on channel {channel} with key: '{mode_key}'\")\n        spec = self.config.measurement_accuracy.get(mode_key)\n\n        if spec:\n            sigma = spec.calculate_std_dev(reading, range_value=None)\n            if sigma &gt; 0:\n                value_to_return = ufloat(reading, sigma)\n                self._logger.debug(f\"Applied accuracy spec '{mode_key}', value: {value_to_return}\")\n            else:\n                self._logger.debug(f\"Accuracy spec '{mode_key}' resulted in sigma=0. Returning float.\")\n        else:\n            self._logger.debug(f\"No accuracy spec found for read_current on channel {channel} with key '{mode_key}'. Returning float.\")\n    else:\n        self._logger.debug(f\"No measurement_accuracy configuration in instrument for read_current on channel {channel}. Returning float.\")\n\n    return value_to_return\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.read_voltage","title":"<code>read_voltage(channel)</code>  <code>async</code>","text":"<p>Reads the measured output voltage from a specific channel.</p> <p>If measurement accuracy is defined in the configuration, this method will return a <code>UFloat</code> object containing the value and its uncertainty. Otherwise, it returns a standard float.</p> PARAMETER DESCRIPTION <code>channel</code> <p>The channel number to measure (1-based).</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>float | UFloat</code> <p>The measured voltage as a float or <code>UFloat</code>.</p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If the channel number is invalid.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@validate_call\nasync def read_voltage(self, channel: int) -&gt; float | UFloat:\n    \"\"\"Reads the measured output voltage from a specific channel.\n\n    If measurement accuracy is defined in the configuration, this method\n    will return a `UFloat` object containing the value and its uncertainty.\n    Otherwise, it returns a standard float.\n\n    Args:\n        channel: The channel number to measure (1-based).\n\n    Returns:\n        The measured voltage as a float or `UFloat`.\n\n    Raises:\n        InstrumentParameterError: If the channel number is invalid.\n    \"\"\"\n    if not self.config.channels or not (1 &lt;= channel &lt;= len(self.config.channels)):\n        num_ch = len(self.config.channels) if self.config.channels else 0\n        raise InstrumentParameterError(f\"Channel number {channel} is out of range (1-{num_ch}).\")\n    command = f\"{self.SCPI_MAP.MEAS_VOLTAGE_QUERY_BASE} (@{channel})\"\n    response_str: str = await self._query(command)\n    reading: float = float(response_str)\n\n    value_to_return: float | UFloat = reading\n\n    if self.config.measurement_accuracy:\n        mode_key = f\"read_voltage_ch{channel}\"\n        self._logger.debug(f\"Attempting to find accuracy spec for read_voltage on channel {channel} with key: '{mode_key}'\")\n        spec = self.config.measurement_accuracy.get(mode_key)\n\n        if spec:\n            sigma = spec.calculate_std_dev(reading, range_value=None)\n            if sigma &gt; 0:\n                value_to_return = ufloat(reading, sigma)\n                self._logger.debug(f\"Applied accuracy spec '{mode_key}', value: {value_to_return}\")\n            else:\n                self._logger.debug(f\"Accuracy spec '{mode_key}' resulted in sigma=0. Returning float.\")\n        else:\n            self._logger.debug(f\"No accuracy spec found for read_voltage on channel {channel} with key '{mode_key}'. Returning float.\")\n    else:\n        self._logger.debug(f\"No measurement_accuracy configuration in instrument for read_voltage on channel {channel}. Returning float.\")\n\n    return value_to_return\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.reset","title":"<code>reset()</code>  <code>async</code>","text":"<p>Resets the instrument to its factory default settings.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>async def reset(self) -&gt; None:\n    \"\"\"\n    Resets the instrument to its factory default settings.\n    \"\"\"\n    await self._send_command(self.SCPI_MAP.RESET)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.set_current","title":"<code>set_current(channel, current)</code>  <code>async</code>","text":"<p>Sets the current limit for a specific channel.</p> PARAMETER DESCRIPTION <code>channel</code> <p>The channel number (1-based).</p> <p> TYPE: <code>int</code> </p> <code>current</code> <p>The current limit in Amperes.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If the channel number is invalid or the                       current is outside the configured range for                       that channel.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@validate_call\nasync def set_current(self, channel: int, current: float) -&gt; None:\n    \"\"\"Sets the current limit for a specific channel.\n\n    Args:\n        channel: The channel number (1-based).\n        current: The current limit in Amperes.\n\n    Raises:\n        InstrumentParameterError: If the channel number is invalid or the\n                                  current is outside the configured range for\n                                  that channel.\n    \"\"\"\n    if not self.config.channels or not (1 &lt;= channel &lt;= len(self.config.channels)):\n        num_ch = len(self.config.channels) if self.config.channels else 0\n        raise InstrumentParameterError(f\"Channel number {channel} is out of range (1-{num_ch}).\")\n\n    channel_config = self.config.channels[channel - 1] # channel is 1-based\n    channel_config.current_limit_range.assert_in_range(current, name=f\"Current for channel {channel}\") # Assuming current_limit_range from example\n    command = f\"{self.SCPI_MAP.CURRENT_SET_BASE} {current}, (@{channel})\"\n    await self._send_command(command)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerSupply.PowerSupply.set_voltage","title":"<code>set_voltage(channel, voltage)</code>  <code>async</code>","text":"<p>Sets the output voltage for a specific channel.</p> PARAMETER DESCRIPTION <code>channel</code> <p>The channel number (1-based).</p> <p> TYPE: <code>int</code> </p> <code>voltage</code> <p>The target voltage in Volts.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If the channel number is invalid or the                       voltage is outside the configured range for                       that channel.</p> Source code in <code>pytestlab/instruments/PowerSupply.py</code> <pre><code>@validate_call\nasync def set_voltage(self, channel: int, voltage: float) -&gt; None:\n    \"\"\"Sets the output voltage for a specific channel.\n\n    Args:\n        channel: The channel number (1-based).\n        voltage: The target voltage in Volts.\n\n    Raises:\n        InstrumentParameterError: If the channel number is invalid or the\n                                  voltage is outside the configured range for\n                                  that channel.\n    \"\"\"\n    # Validate that the channel number is within the configured range\n    if not self.config.channels or not (1 &lt;= channel &lt;= len(self.config.channels)):\n        num_ch = len(self.config.channels) if self.config.channels else 0\n        raise InstrumentParameterError(f\"Channel number {channel} is out of range (1-{num_ch}).\")\n\n    # Validate the voltage against the limits defined in the configuration\n    channel_config = self.config.channels[channel - 1]\n    channel_config.voltage_range.assert_in_range(voltage, name=f\"Voltage for channel {channel}\")\n\n    # Construct and send the SCPI command\n    command = f\"{self.SCPI_MAP.VOLTAGE_SET_BASE} {voltage}, (@{channel})\"\n    await self._send_command(command)\n</code></pre>"},{"location":"api/instruments/#waveform-generator","title":"Waveform Generator","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator","title":"<code>pytestlab.instruments.WaveformGenerator</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WAVEFORM_PARAM_COMMANDS","title":"<code>WAVEFORM_PARAM_COMMANDS = {WaveformType.PULSE: {'duty_cycle': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:DCYCle {v_float}', 'period': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:PERiod {v_float}', 'width': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:WIDTh {v_float}', 'transition_both': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:TRANsition:BOTH {v_float}', 'transition_leading': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:TRANsition:LEADing {v_float}', 'transition_trailing': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:TRANsition:TRAiling {v_float}', 'hold_mode': lambda ch, v_str_hold: f'SOUR{ch}:FUNC:PULS:HOLD {v_str_hold.upper()}'}, WaveformType.SQUARE: {'duty_cycle': lambda ch, v_float: f'SOUR{ch}:FUNC:SQUare:DCYCle {v_float}', 'period': lambda ch, v_float: f'SOUR{ch}:FUNC:SQUare:PERiod {v_float}'}, WaveformType.RAMP: {'symmetry': lambda ch, v_float: f'SOUR{ch}:FUNC:RAMP:SYMMetry {v_float}'}, WaveformType.SINE: {}, WaveformType.NOISE: {'bandwidth': lambda ch, v_float: f'SOUR{ch}:FUNC:NOISe:BANDwidth {v_float}'}, WaveformType.ARB: {'sample_rate': lambda ch, v_float: f'SOUR{ch}:FUNC:ARB:SRATe {v_float}', 'filter': lambda ch, arb_filter_enum_val: f'SOUR{ch}:FUNC:ARB:FILTer {arb_filter_enum_val}', 'advance_mode': lambda ch, arb_adv_enum_val: f'SOUR{ch}:FUNC:ARB:ADVance {arb_adv_enum_val}', 'frequency': lambda ch, v_float: f'SOUR{ch}:FUNC:ARB:FREQ {v_float}', 'period': lambda ch, v_float: f'SOUR{ch}:FUNC:ARB:PER {v_float}', 'ptpeak_voltage': lambda ch, v_float: f'SOUR{ch}:FUNC:ARB:PTP {v_float}'}, WaveformType.DC: {}}</code>  <code>module-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator-classes","title":"Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.FileSystemInfo","title":"<code>FileSystemInfo(bytes_used, bytes_free, files=list())</code>  <code>dataclass</code>","text":"<p>Data class representing the results of a directory listing query (<code>list_directory</code>).</p> <p>Contains information about memory usage and the files/folders found in the queried path.</p> ATTRIBUTE DESCRIPTION <code>bytes_used</code> <p>Total bytes used on the specified memory volume (INT or USB).</p> <p> TYPE: <code>int</code> </p> <code>bytes_free</code> <p>Total bytes free on the specified memory volume.</p> <p> TYPE: <code>int</code> </p> <code>files</code> <p>A list of dictionaries, each representing a file or folder.                           Example entry: <code>{'name': 'f.txt', 'type': 'FILE', 'size': 1024}</code>.                           Type might be 'FILE', 'FOLDER', 'ARB', 'STAT', etc., depending on the file                           extension and instrument response. Size is in bytes.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.FileSystemInfo-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.FileSystemInfo.bytes_free","title":"<code>bytes_free</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.FileSystemInfo.bytes_used","title":"<code>bytes_used</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.FileSystemInfo.files","title":"<code>files = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.FileSystemInfo-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade","title":"<code>WGChannelFacade(wg, channel_num)</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>def __init__(self, wg: 'WaveformGenerator', channel_num: int):\n    self._wg = wg\n    self._channel = channel_num\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.disable","title":"<code>disable()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def disable(self) -&gt; Self:\n    await self._wg.set_output_state(self._channel, SCPIOnOff.OFF)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.enable","title":"<code>enable()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def enable(self) -&gt; Self:\n    await self._wg.set_output_state(self._channel, SCPIOnOff.ON)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.set_load_impedance","title":"<code>set_load_impedance(impedance)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_load_impedance(self, impedance: Union[float, OutputLoadImpedance, str]) -&gt; Self:\n    await self._wg.set_output_load_impedance(self._channel, impedance)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.set_voltage_unit","title":"<code>set_voltage_unit(unit)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_voltage_unit(self, unit: VoltageUnit) -&gt; Self:\n    await self._wg.set_voltage_unit(self._channel, unit)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_arbitrary","title":"<code>setup_arbitrary(arb_name, sample_rate, amplitude, offset=0.0, phase=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def setup_arbitrary(self, arb_name: str, sample_rate: float, amplitude: float, offset: float = 0.0, phase: Optional[float] = None) -&gt; Self:\n    await self._wg.set_function(self._channel, WaveformType.ARB)\n    await self._wg.select_arbitrary_waveform(self._channel, arb_name)\n    await self._wg.set_arbitrary_waveform_sample_rate(self._channel, sample_rate)\n    await self._wg.set_amplitude(self._channel, amplitude)\n    await self._wg.set_offset(self._channel, offset)\n    if phase is not None:\n        await self._wg.set_phase(self._channel, phase)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_dc","title":"<code>setup_dc(offset)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def setup_dc(self, offset: float) -&gt; Self:\n    await self._wg.set_function(self._channel, WaveformType.DC)\n    await self._wg.set_offset(self._channel, offset)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_pulse","title":"<code>setup_pulse(frequency, amplitude, offset=0.0, width=None, duty_cycle=None, transition_both=None, phase=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def setup_pulse(self, frequency: float, amplitude: float, offset: float = 0.0, width: Optional[float] = None, duty_cycle: Optional[float] = None, transition_both: Optional[float] = None, phase: Optional[float] = None) -&gt; Self:\n    period = 1.0 / frequency if frequency &gt; 0 else OutputLoadImpedance.MAXIMUM\n\n    pulse_params = {\"period\": period}\n    if width is not None:\n        pulse_params[\"width\"] = width\n    elif duty_cycle is not None:\n        pulse_params[\"duty_cycle\"] = duty_cycle\n    else:\n        pulse_params[\"duty_cycle\"] = 50.0\n\n    if transition_both is not None:\n        pulse_params[\"transition_both\"] = transition_both\n\n    await self._wg.set_function(self._channel, WaveformType.PULSE, **pulse_params)\n    await self._wg.set_amplitude(self._channel, amplitude)\n    await self._wg.set_offset(self._channel, offset)\n    if phase is not None:\n        await self._wg.set_phase(self._channel, phase)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_ramp","title":"<code>setup_ramp(frequency, amplitude, offset=0.0, symmetry=50.0, phase=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def setup_ramp(self, frequency: float, amplitude: float, offset: float = 0.0, symmetry: float = 50.0, phase: Optional[float] = None) -&gt; Self:\n    await self._wg.set_function(self._channel, WaveformType.RAMP, symmetry=symmetry)\n    await self._wg.set_frequency(self._channel, frequency)\n    await self._wg.set_amplitude(self._channel, amplitude)\n    await self._wg.set_offset(self._channel, offset)\n    if phase is not None:\n        await self._wg.set_phase(self._channel, phase)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_sine","title":"<code>setup_sine(frequency, amplitude, offset=0.0, phase=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def setup_sine(self, frequency: float, amplitude: float, offset: float = 0.0, phase: Optional[float] = None) -&gt; Self:\n    await self._wg.set_function(self._channel, WaveformType.SINE)\n    await self._wg.set_frequency(self._channel, frequency)\n    await self._wg.set_amplitude(self._channel, amplitude)\n    await self._wg.set_offset(self._channel, offset)\n    if phase is not None:\n        await self._wg.set_phase(self._channel, phase)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_square","title":"<code>setup_square(frequency, amplitude, offset=0.0, duty_cycle=50.0, phase=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def setup_square(self, frequency: float, amplitude: float, offset: float = 0.0, duty_cycle: float = 50.0, phase: Optional[float] = None) -&gt; Self:\n    await self._wg.set_function(self._channel, WaveformType.SQUARE, duty_cycle=duty_cycle)\n    await self._wg.set_frequency(self._channel, frequency)\n    await self._wg.set_amplitude(self._channel, amplitude)\n    await self._wg.set_offset(self._channel, offset)\n    if phase is not None:\n        await self._wg.set_phase(self._channel, phase)\n    return self\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult","title":"<code>WaveformConfigResult(channel, function, frequency, amplitude, offset, phase=None, symmetry=None, duty_cycle=None, output_state=None, load_impedance=None, voltage_unit=None)</code>  <code>dataclass</code>","text":"<p>Data class storing the retrieved waveform configuration of a channel.</p> <p>Provides a structured way to access key parameters of the channel's current state, obtained by querying multiple SCPI commands.</p> ATTRIBUTE DESCRIPTION <code>channel</code> <p>The channel number (1 or 2).</p> <p> TYPE: <code>int</code> </p> <code>function</code> <p>The short SCPI name of the active waveform function (e.g., \"SIN\", \"RAMP\").</p> <p> TYPE: <code>str</code> </p> <code>frequency</code> <p>The current frequency in Hz (or sample rate in Sa/s for ARB).</p> <p> TYPE: <code>float</code> </p> <code>amplitude</code> <p>The current amplitude in the configured voltage units.</p> <p> TYPE: <code>float</code> </p> <code>offset</code> <p>The current DC offset voltage in Volts.</p> <p> TYPE: <code>float</code> </p> <code>phase</code> <p>The current phase offset in the configured angle units (None if not applicable).</p> <p> TYPE: <code>Optional[float]</code> </p> <code>symmetry</code> <p>The current symmetry percentage for RAMP/TRIANGLE (None otherwise).</p> <p> TYPE: <code>Optional[float]</code> </p> <code>duty_cycle</code> <p>The current duty cycle percentage for SQUARE/PULSE (None otherwise).</p> <p> TYPE: <code>Optional[float]</code> </p> <code>output_state</code> <p>The current state of the main output (True=ON, False=OFF).</p> <p> TYPE: <code>Optional[bool]</code> </p> <code>load_impedance</code> <p>The configured load impedance (Ohms or \"INFinity\").</p> <p> TYPE: <code>Optional[Union[float, str]]</code> </p> <code>voltage_unit</code> <p>The currently configured voltage unit (\"VPP\", \"VRMS\", \"DBM\").</p> <p> TYPE: <code>Optional[str]</code> </p>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.amplitude","title":"<code>amplitude</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.channel","title":"<code>channel</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.duty_cycle","title":"<code>duty_cycle = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.frequency","title":"<code>frequency</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.function","title":"<code>function</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.load_impedance","title":"<code>load_impedance = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.offset","title":"<code>offset</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.output_state","title":"<code>output_state = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.phase","title":"<code>phase = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.symmetry","title":"<code>symmetry = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.voltage_unit","title":"<code>voltage_unit = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformConfigResult-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator","title":"<code>WaveformGenerator(config, debug_mode=False, **kwargs)</code>","text":"<p>               Bases: <code>Instrument[WaveformGeneratorConfig]</code></p> <p>Provides a high-level Python interface for controlling Keysight EDU33210 Series Trueform Arbitrary Waveform Generators via SCPI commands.</p> <p>Initializes the WaveformGenerator instance.</p> Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>def __init__(self, config: WaveformGeneratorConfig, debug_mode: bool = False, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Initializes the WaveformGenerator instance.\n    \"\"\"\n    super().__init__(config=config, debug_mode=debug_mode, **kwargs) # Pass kwargs to base\n    # self.config is already set by base Instrument's __init__ due to Generic type\n\n    # Determine channel count from the length of the channels list in the config\n    if hasattr(self.config, 'channels') and isinstance(self.config.channels, list):\n        self._channel_count = len(self.config.channels)\n    else:\n        # This case should ideally be caught by Pydantic validation of WaveformGeneratorConfig\n        self._logger.warning(\"config.channels is not a list. Defaulting channel count to 0.\")\n        self._channel_count = 0\n\n    if self._channel_count &lt;= 0:\n        self._logger.warning(f\"Channel count determined as {self._channel_count}. Check instrument configuration.\")\n        # Consider if raising an error is more appropriate if channel_count is essential and expected to be &gt; 0\n        # For now, logging a warning to allow flexibility if some AWGs might be configured with 0 channels initially.\n\n    self._logger.debug(f\"Detected {self._channel_count} channels from configuration.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.channel_count","title":"<code>channel_count</code>  <code>property</code>","text":"<p>Returns the number of output channels supported by this instrument, based on configuration.</p>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.config","title":"<code>config</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.model_config","title":"<code>model_config = {'arbitrary_types_allowed': True}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.apply_waveform_settings","title":"<code>apply_waveform_settings(channel, function_type, frequency=OutputLoadImpedance.DEFAULT, amplitude=OutputLoadImpedance.DEFAULT, offset=OutputLoadImpedance.DEFAULT)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def apply_waveform_settings(self, channel: Union[int, str], function_type: Union[WaveformType, str], frequency: Union[float, OutputLoadImpedance, str] = OutputLoadImpedance.DEFAULT, amplitude: Union[float, OutputLoadImpedance, str] = OutputLoadImpedance.DEFAULT, offset: Union[float, OutputLoadImpedance, str] = OutputLoadImpedance.DEFAULT) -&gt; None:\n    ch = self._validate_channel(channel)\n    scpi_short_name = self._get_scpi_function_name(function_type)\n    apply_suffix_map: Dict[str, str] = { WaveformType.SINE.value: \"SINusoid\", WaveformType.SQUARE.value: \"SQUare\", WaveformType.RAMP.value: \"RAMP\", WaveformType.PULSE.value: \"PULSe\", WaveformType.NOISE.value: \"NOISe\", WaveformType.ARB.value: \"ARBitrary\", WaveformType.DC.value: \"DC\",}\n    if scpi_short_name == \"TRI\" and \"TRI\" not in apply_suffix_map: apply_suffix_map[\"TRI\"] = \"TRIangle\"\n    apply_suffix = apply_suffix_map.get(scpi_short_name)\n    if not apply_suffix:\n        if scpi_short_name in apply_suffix_map:\n            apply_suffix = apply_suffix_map[scpi_short_name]\n        else:\n            raise InstrumentParameterError(\n                parameter=\"function_type\",\n                value=function_type,\n                message=f\"Waveform function (SCPI: {scpi_short_name}) not supported by APPLy.\",\n            )\n    params: List[str] = [self._format_value_min_max_def(frequency), self._format_value_min_max_def(amplitude), self._format_value_min_max_def(offset)]\n    param_str = \",\".join(params)\n    cmd = f\"SOUR{ch}:APPLy:{apply_suffix} {param_str}\"\n    await self._send_command(cmd)\n    self._logger.debug(f\"Channel {ch}: Applied {apply_suffix} with params: Freq/SR={frequency}, Ampl={amplitude}, Offs={offset}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.channel","title":"<code>channel(ch_num)</code>","text":"<p>Returns a facade for interacting with a specific channel.</p> PARAMETER DESCRIPTION <code>ch_num</code> <p>The channel number (1-based) or string identifier (e.g. \"CH1\").</p> <p> TYPE: <code>Union[int, str]</code> </p> RETURNS DESCRIPTION <code>WGChannelFacade</code> <p>A facade object for the specified channel.</p> <p> TYPE: <code>WGChannelFacade</code> </p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If channel number is invalid.</p> Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\ndef channel(self, ch_num: Union[int,str]) -&gt; WGChannelFacade:\n    \"\"\"\n    Returns a facade for interacting with a specific channel.\n\n    Args:\n        ch_num (Union[int,str]): The channel number (1-based) or string identifier (e.g. \"CH1\").\n\n    Returns:\n        WGChannelFacade: A facade object for the specified channel.\n\n    Raises:\n        InstrumentParameterError: If channel number is invalid.\n    \"\"\"\n    validated_ch_num = self._validate_channel(ch_num) # _validate_channel returns int\n    return WGChannelFacade(self, validated_ch_num)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.clear_volatile_arbitrary_waveforms","title":"<code>clear_volatile_arbitrary_waveforms(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def clear_volatile_arbitrary_waveforms(self, channel: Union[int, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"SOUR{ch}:DATA:VOLatile:CLEar\")\n    self._logger.debug(f\"Channel {ch}: Cleared volatile arbitrary waveform memory.\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.delete_file_or_folder","title":"<code>delete_file_or_folder(path)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def delete_file_or_folder(self, path: str) -&gt; None:\n    if not path:\n        raise InstrumentParameterError(\n            parameter=\"path\", message=\"Path cannot be empty for deletion.\"\n        )\n    path_scpi = f'\"{path}\"'\n    cmd = f\"MMEMory:DELete {path_scpi}\"\n    try:\n        await self._send_command(cmd)\n        self._logger.log(f\"Attempted to delete file/folder: '{path}' using MMEM:DELete\")\n        await self._error_check()\n    except InstrumentCommunicationError as e:\n        code, msg = await self.get_error()\n        if code != 0:\n            if \"Directory not empty\" in msg or \"folder\" in msg.lower():\n                raise InstrumentCommunicationError(\n                    instrument=self.config.model,\n                    command=cmd,\n                    message=f\"Failed to delete '{path}'. Non-empty folder? Inst Err {code}: {msg}\",\n                ) from e\n            else:\n                raise InstrumentCommunicationError(\n                    instrument=self.config.model,\n                    command=cmd,\n                    message=f\"Failed to delete '{path}'. Inst Err {code}: {msg}\",\n                ) from e\n        else:\n            raise e\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.download_arbitrary_waveform_data","title":"<code>download_arbitrary_waveform_data(channel, arb_name, data_points, data_type='DAC', use_binary=True, is_dual_channel_data=False, dual_data_format=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def download_arbitrary_waveform_data(self, channel: Union[int, str], arb_name: str, data_points: Union[List[int], List[float], np.ndarray], data_type: str = \"DAC\", use_binary: bool = True, is_dual_channel_data: bool = False, dual_data_format: Optional[str] = None) -&gt; None:\n    if use_binary:\n        await self.download_arbitrary_waveform_data_binary(channel, arb_name, data_points, data_type, is_dual_channel_data=is_dual_channel_data, dual_data_format=dual_data_format)\n    else:\n        await self.download_arbitrary_waveform_data_csv(channel, arb_name, data_points, data_type)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.download_arbitrary_waveform_data_binary","title":"<code>download_arbitrary_waveform_data_binary(channel, arb_name, data_points, data_type='DAC', is_dual_channel_data=False, dual_data_format=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def download_arbitrary_waveform_data_binary(self, channel: Union[int, str], arb_name: str, data_points: Union[List[int], List[float], np.ndarray], data_type: str = \"DAC\", is_dual_channel_data: bool = False, dual_data_format: Optional[str] = None) -&gt; None:\n    ch = self._validate_channel(channel)\n    if not re.match(r\"^[a-zA-Z0-9_]{1,12}$\", arb_name):\n        raise InstrumentParameterError(\n            parameter=\"arb_name\",\n            value=arb_name,\n            message=\"Arbitrary waveform name is invalid.\",\n        )\n    data_type_upper = data_type.upper().strip()\n    if data_type_upper not in [\"DAC\", \"NORM\"]:\n        raise InstrumentParameterError(\n            parameter=\"data_type\",\n            value=data_type,\n            valid_range=[\"DAC\", \"NORM\"],\n            message=\"Invalid data_type.\",\n        )\n    np_data = np.asarray(data_points)\n    if np_data.ndim != 1 or np_data.size == 0:\n        raise InstrumentParameterError(\n            parameter=\"data_points\", message=\"data_points must be a non-empty 1D sequence.\"\n        )\n    num_points_total = np_data.size\n    num_points_per_channel = num_points_total\n    arb_cmd_node = \"ARBitrary\"\n    if is_dual_channel_data:\n        if self.channel_count &lt; 2:\n            raise InstrumentConfigurationError(\n                self.config.model,\n                \"Dual channel download requires 2-channel instrument.\",\n            )\n        arb_cmd_node = \"ARBitrary2\"\n        if num_points_total % 2 != 0:\n            raise InstrumentParameterError(\n                parameter=\"data_points\",\n                message=\"Total data_points must be even for dual channel.\",\n            )\n        num_points_per_channel = num_points_total // 2\n        if dual_data_format:\n            fmt_upper = dual_data_format.upper().strip()\n            if fmt_upper not in [\"AABB\", \"ABAB\"]:\n                raise InstrumentParameterError(\n                    parameter=\"dual_data_format\",\n                    value=dual_data_format,\n                    valid_range=[\"AABB\", \"ABAB\"],\n                    message=\"Invalid dual_data_format.\",\n                )\n            await self._send_command(f\"SOUR{ch}:DATA:{arb_cmd_node}:FORMat {fmt_upper}\")\n            await self._error_check()\n            self._logger.debug(f\"Channel {ch}: Dual arb data format set to {fmt_upper}\")\n    binary_data: bytes\n    scpi_suffix: str\n    transfer_type_log_msg: str = \"Binary Block\"\n    if data_type_upper == \"DAC\":\n        scpi_suffix = \":DAC\"\n        if not np.issubdtype(np_data.dtype, np.integer):\n            self._logger.warning(\"Warning: DAC data not integer, converting to int16.\")\n            try:\n                np_data = np_data.astype(np.int16)\n            except ValueError as e:\n                raise InstrumentParameterError(\n                    parameter=\"data_points\",\n                    message=\"Cannot convert DAC data to int16.\",\n                ) from e\n        dac_min, dac_max = getattr(self.config.waveforms, 'arbitrary_dac_range', (-32768, 32767))\n        if np.any(np_data &lt; dac_min) or np.any(np_data &gt; dac_max):\n            raise InstrumentParameterError(\n                parameter=\"data_points\",\n                message=f\"DAC data out of range [{dac_min}, {dac_max}].\",\n            )\n        binary_data = np_data.astype('&lt;h').tobytes()\n    else: # NORM\n        scpi_suffix = \"\"\n        if not np.issubdtype(np_data.dtype, np.floating):\n            self._logger.warning(\"Warning: Normalized data not float, converting to float32.\")\n            try:\n                np_data = np_data.astype(np.float32)\n            except ValueError as e:\n                raise InstrumentParameterError(\n                    parameter=\"data_points\",\n                    message=\"Cannot convert Normalized data to float32.\",\n                ) from e\n        norm_min, norm_max = -1.0, 1.0\n        tolerance = 1e-6\n        if np.any(np_data &lt; norm_min - tolerance) or np.any(\n            np_data &gt; norm_max + tolerance\n        ):\n            raise InstrumentParameterError(\n                parameter=\"data_points\",\n                message=f\"Normalized data out of range [{norm_min}, {norm_max}].\",\n            )\n        np_data = np.clip(np_data, norm_min, norm_max)\n        binary_data = np_data.astype('&lt;f').tobytes()\n    cmd_prefix = f\"SOUR{ch}:DATA:{arb_cmd_node}{scpi_suffix} {arb_name},\"\n    try:\n        await self._write_binary(cmd_prefix, binary_data) # Assumed async\n        transfer_type_log_msg = \"IEEE 488.2 Binary Block via _write_binary\"\n        self._logger.debug(f\"Channel {ch}: Downloaded arb '{arb_name}' via {transfer_type_log_msg} ({num_points_per_channel} pts/ch, {len(binary_data)} bytes, type: {data_type_upper})\")\n        await self._error_check()\n    except InstrumentCommunicationError as e:\n        self._logger.error(f\"Error during {transfer_type_log_msg} arb download for '{arb_name}'.\")\n        code, msg = await self.get_error()\n        if code == 786:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd_prefix,\n                message=f\"Arb Name Conflict (786) for '{arb_name}'.\",\n            ) from e\n        elif code == 781:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd_prefix,\n                message=f\"Out of Memory (781) for '{arb_name}'.\",\n            ) from e\n        elif code == -113:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd_prefix,\n                message=f\"SCPI Syntax Error (-113) for '{arb_name}'.\",\n            ) from e\n        elif code != 0:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd_prefix,\n                message=f\"Arb download for '{arb_name}' failed. Inst Err {code}: {msg}\",\n            ) from e\n        else:\n            raise e\n    except Exception as e:\n        self._logger.error(f\"Unexpected error during binary arb download for '{arb_name}': {e}\")\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd_prefix,\n            message=f\"Unexpected failure downloading arb '{arb_name}'\",\n        ) from e\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.download_arbitrary_waveform_data_csv","title":"<code>download_arbitrary_waveform_data_csv(channel, arb_name, data_points, data_type='DAC')</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def download_arbitrary_waveform_data_csv(self, channel: Union[int, str], arb_name: str, data_points: Union[List[int], List[float], np.ndarray], data_type: str = \"DAC\") -&gt; None:\n    ch = self._validate_channel(channel)\n    if not re.match(r\"^[a-zA-Z0-9_]{1,12}$\", arb_name):\n        raise InstrumentParameterError(\n            parameter=\"arb_name\",\n            value=arb_name,\n            message=\"Arbitrary waveform name is invalid.\",\n        )\n    data_type_upper = data_type.upper().strip()\n    if data_type_upper not in [\"DAC\", \"NORM\"]:\n        raise InstrumentParameterError(\n            parameter=\"data_type\",\n            value=data_type,\n            valid_range=[\"DAC\", \"NORM\"],\n            message=\"Invalid data_type.\",\n        )\n    np_data = np.asarray(data_points)\n    if np_data.ndim != 1 or np_data.size == 0:\n        raise InstrumentParameterError(\n            parameter=\"data_points\", message=\"data_points must be a non-empty 1D sequence.\"\n        )\n    if 0 &lt;= (ch - 1) &lt; len(self.config.channels):\n        channel_conf = self.config.channels[ch-1]\n        if hasattr(channel_conf, 'arbitrary') and hasattr(channel_conf.arbitrary, 'max_points') and np_data.size &gt; channel_conf.arbitrary.max_points:\n            self._logger.warning(f\"Number of data points ({np_data.size}) exceeds configured max_points ({channel_conf.arbitrary.max_points}) for CH{ch}.\")\n    formatted_data: str\n    scpi_suffix: str\n    if data_type_upper == \"DAC\":\n        if not np.issubdtype(np_data.dtype, np.integer):\n            self._logger.warning(\"DAC data not integer, converting to int16.\")\n            try:\n                np_data = np_data.astype(np.int16)\n            except ValueError as e:\n                raise InstrumentParameterError(\n                    parameter=\"data_points\",\n                    message=\"Cannot convert DAC data to int16.\",\n                ) from e\n        dac_min, dac_max = getattr(self.config.waveforms, 'arbitrary_dac_range', (-32768, 32767))\n        if np.any(np_data &lt; dac_min) or np.any(np_data &gt; dac_max):\n            raise InstrumentParameterError(\n                parameter=\"data_points\",\n                message=f\"DAC data out of range [{dac_min}, {dac_max}].\",\n            )\n        formatted_data = ','.join(map(str, np_data))\n        scpi_suffix = \":DAC\"\n    else: # NORM\n        if not np.issubdtype(np_data.dtype, np.floating):\n            self._logger.warning(\"Normalized data not float, converting to float32.\")\n            try:\n                np_data = np_data.astype(np.float32)\n            except ValueError as e:\n                raise InstrumentParameterError(\n                    parameter=\"data_points\",\n                    message=\"Cannot convert Normalized data to floats.\",\n                ) from e\n        norm_min, norm_max = -1.0, 1.0\n        tolerance = 1e-9\n        if np.any(np_data &lt; norm_min - tolerance) or np.any(\n            np_data &gt; norm_max + tolerance\n        ):\n            raise InstrumentParameterError(\n                parameter=\"data_points\",\n                message=f\"Normalized data out of range [{norm_min}, {norm_max}].\",\n            )\n        np_data = np.clip(np_data, norm_min, norm_max)\n        formatted_data = ','.join(map(lambda x: f\"{x:.8G}\", np_data))\n        scpi_suffix = \"\"\n    cmd = f\"SOUR{ch}:DATA:ARBitrary{scpi_suffix} {arb_name},{formatted_data}\"\n    max_cmd_len = getattr(self.config, 'max_scpi_command_length', 10000)\n    if len(cmd) &gt; max_cmd_len: self._logger.warning(f\"SCPI command length ({len(cmd)}) large. Consider binary transfer.\")\n    try:\n        await self._send_command(cmd)\n        self._logger.debug(f\"Channel {ch}: Downloaded arb '{arb_name}' via CSV ({np_data.size} points, type: {data_type_upper})\")\n        await self._error_check()\n    except InstrumentCommunicationError as e:\n        self._logger.error(f\"Error during CSV arb download for '{arb_name}'.\")\n        code, msg = await self.get_error()\n        if code == -113:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd,\n                message=f\"SCPI Syntax Error (-113) for '{arb_name}'.\",\n            ) from e\n        elif code == 786:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd,\n                message=f\"Arb Name Conflict (786) for '{arb_name}'.\",\n            ) from e\n        elif code == 781:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd,\n                message=f\"Out of Memory (781) for '{arb_name}'.\",\n            ) from e\n        elif code == -102:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd,\n                message=f\"SCPI Syntax Error (-102) for '{arb_name}'.\",\n            ) from e\n        elif code != 0:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd,\n                message=f\"Arb download for '{arb_name}' failed. Inst Err {code}: {msg}\",\n            ) from e\n        else:\n            raise e\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.enable_burst","title":"<code>enable_burst(channel, state)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def enable_burst(self, channel: Union[int, str], state: bool) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value\n    await self._send_command(f\"SOUR{ch}:BURSt:STATe {cmd_state}\")\n    self._logger.log(f\"Channel {ch}: Burst state set to {cmd_state}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.enable_modulation","title":"<code>enable_modulation(channel, mod_type, state)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def enable_modulation(self, channel: Union[int, str], mod_type: str, state: bool) -&gt; None:\n    ch = self._validate_channel(channel)\n    mod_upper = mod_type.upper().strip()\n    valid_mods = {\"AM\", \"FM\", \"PM\", \"PWM\", \"FSK\", \"BPSK\", \"SUM\"}\n    if mod_upper not in valid_mods:\n        raise InstrumentParameterError(\n            parameter=\"mod_type\",\n            value=mod_type,\n            valid_range=valid_mods,\n            message=\"Invalid modulation type.\",\n        )\n    cmd_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value\n    await self._send_command(f\"SOUR{ch}:{mod_upper}:STATe {cmd_state}\")\n    self._logger.log(f\"Channel {ch}: {mod_upper} modulation state set to {cmd_state}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.enable_sweep","title":"<code>enable_sweep(channel, state)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def enable_sweep(self, channel: Union[int, str], state: bool) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value\n    await self._send_command(f\"SOUR{ch}:SWEep:STATe {cmd_state}\")\n    self._logger.log(f\"Channel {ch}: Sweep state set to {cmd_state}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.from_config","title":"<code>from_config(config, debug_mode=False, **kwargs)</code>  <code>classmethod</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@classmethod\n@validate_call\ndef from_config(cls: Type['WaveformGenerator'], config: WaveformGeneratorConfig, debug_mode: bool = False, **kwargs: Any) -&gt; 'WaveformGenerator':\n    return cls(config=config, debug_mode=debug_mode, **kwargs)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_amplitude","title":"<code>get_amplitude(channel, query_type=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_amplitude(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:\n    ch = self._validate_channel(channel)\n    cmd = f\"SOUR{ch}:VOLTage?\"\n    type_str = \"\"\n    if query_type: cmd += f\" {query_type.value}\"; type_str = f\" ({query_type.name} limit)\"\n    response = (await self._query(cmd)).strip()\n    try:\n        amp = float(response)\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd,\n            message=f\"Failed to parse amplitude float from response: '{response}'\",\n        )\n    unit = await self.get_voltage_unit(ch)\n    self._logger.debug(f\"Channel {ch}: Amplitude{type_str} is {amp} {unit.value}\")\n    return amp\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_angle_unit","title":"<code>get_angle_unit()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_angle_unit(self) -&gt; str:\n    response = (await self._query(\"UNIT:ANGLe?\")).strip().upper()\n    if response not in [\"DEG\", \"RAD\", \"SEC\"]: self._logger.warning(f\"Warning: Unexpected angle unit response '{response}'.\")\n    self._logger.debug(f\"Current global angle unit is {response}\")\n    return response\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_arbitrary_waveform_points","title":"<code>get_arbitrary_waveform_points(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_arbitrary_waveform_points(self, channel: Union[int, str]) -&gt; int:\n    ch = self._validate_channel(channel)\n    try:\n        response = (await self._query(f\"SOUR{ch}:FUNC:ARB:POINts?\")).strip()\n        points = int(response)\n        self._logger.debug(f\"Channel {ch}: Currently selected arbitrary waveform has {points} points\")\n        return points\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=f\"SOUR{ch}:FUNC:ARB:POINts?\",\n            message=f\"Failed to parse integer points from response: '{response}'\",\n        )\n    except InstrumentCommunicationError as e:\n        code, msg = await self.get_error()\n        if code != 0:\n            self._logger.warning(f\"Query SOUR{ch}:FUNC:ARB:POINts? failed. Inst Err {code}: {msg}. Returning 0.\")\n            return 0\n        else:\n            raise e\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_arbitrary_waveform_sample_rate","title":"<code>get_arbitrary_waveform_sample_rate(channel, query_type=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_arbitrary_waveform_sample_rate(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:\n    ch = self._validate_channel(channel)\n    cmd = f\"SOUR{ch}:FUNC:ARB:SRATe?\"\n    type_str = \"\"\n    if query_type: cmd += f\" {query_type.value}\"; type_str = f\" ({query_type.name} limit)\"\n    response = (await self._query(cmd)).strip()\n    try:\n        sr = float(response)\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd,\n            message=f\"Failed to parse sample rate float from response: '{response}'\",\n        )\n    self._logger.debug(f\"Channel {ch}: Arbitrary waveform sample rate{type_str} is {sr} Sa/s\")\n    return sr\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_channel_configuration_summary","title":"<code>get_channel_configuration_summary(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_channel_configuration_summary(self, channel: Union[int, str]) -&gt; str:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:APPLy?\")).strip()\n    self._logger.debug(f\"Channel {ch}: Configuration summary (APPLy?) returned: {response}\")\n    if response.startswith('\"') and response.endswith('\"') and response.count('\"') == 2 : return response[1:-1]\n    return response\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_complete_config","title":"<code>get_complete_config(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_complete_config(self, channel: Union[int, str]) -&gt; WaveformConfigResult:\n    ch_num = self._validate_channel(channel)\n    self._logger.debug(f\"Getting complete configuration snapshot for channel {ch_num}...\")\n    func_scpi_str = await self.get_function(ch_num)\n    freq = await self.get_frequency(ch_num)\n    ampl = await self.get_amplitude(ch_num)\n    offs = await self.get_offset(ch_num)\n    output_state_enum = await self.get_output_state(ch_num)\n    output_state_bool = True if output_state_enum == SCPIOnOff.ON else False\n    load_impedance_val = await self.get_output_load_impedance(ch_num)\n    load_impedance_str: Union[str, float]\n    if isinstance(load_impedance_val, OutputLoadImpedance) and load_impedance_val == OutputLoadImpedance.INFINITY:\n        load_impedance_str = \"INFinity\"\n    else:\n        load_impedance_str = float(load_impedance_val)\n    voltage_unit_enum = await self.get_voltage_unit(ch_num)\n    voltage_unit_str = voltage_unit_enum.value\n    phase: Optional[float] = None\n    if func_scpi_str not in [WaveformType.DC.value, WaveformType.NOISE.value]:\n        try:\n            phase = await self.get_phase(ch_num)\n        except InstrumentCommunicationError as e:\n            self._log(f\"Note: Phase query failed for CH{ch_num} (function: {func_scpi_str}): {e}\", level=\"info\")\n    symmetry: Optional[float] = None\n    duty_cycle: Optional[float] = None\n    try:\n        if func_scpi_str == WaveformType.RAMP.value:\n            symmetry = await self.get_ramp_symmetry(ch_num)\n        elif func_scpi_str == WaveformType.SQUARE.value:\n            duty_cycle = await self.get_square_duty_cycle(ch_num)\n        elif func_scpi_str == WaveformType.PULSE.value:\n            duty_cycle = await self.get_pulse_duty_cycle(ch_num)\n    except InstrumentCommunicationError as e:\n        self._log(f\"Note: Query failed for function-specific parameter for CH{ch_num} func {func_scpi_str}: {e}\", level=\"info\")\n    return WaveformConfigResult(channel=ch_num, function=func_scpi_str, frequency=freq, amplitude=ampl, offset=offs, phase=phase, symmetry=symmetry, duty_cycle=duty_cycle, output_state=output_state_bool, load_impedance=load_impedance_str, voltage_unit=voltage_unit_str)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_free_volatile_arbitrary_memory","title":"<code>get_free_volatile_arbitrary_memory(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_free_volatile_arbitrary_memory(self, channel: Union[int, str]) -&gt; int:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:DATA:VOLatile:FREE?\")).strip()\n    try:\n        free_points = int(response)\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=f\"SOUR{ch}:DATA:VOLatile:FREE?\",\n            message=f\"Unexpected non-integer response: {response}\",\n        )\n    self._logger.debug(f\"Channel {ch}: Free volatile arbitrary memory: {free_points} points\")\n    return free_points\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_frequency","title":"<code>get_frequency(channel, query_type=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_frequency(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:\n    ch = self._validate_channel(channel)\n    cmd = f\"SOUR{ch}:FREQ?\"\n    type_str = \"\"\n    if query_type: cmd += f\" {query_type.value}\"; type_str = f\" ({query_type.name} limit)\"\n    response = (await self._query(cmd)).strip()\n    try:\n        freq = float(response)\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd,\n            message=f\"Failed to parse frequency float from response: '{response}'\",\n        )\n    self._logger.debug(f\"Channel {ch}: Frequency{type_str} is {freq} Hz\")\n    return freq\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_function","title":"<code>get_function(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def get_function(self, channel: Union[int, str]) -&gt; str:\n    ch = self._validate_channel(channel)\n    scpi_func = (await self._query(f\"SOUR{ch}:FUNC?\")).strip()\n    self._logger.debug(f\"Channel {ch}: Current function is {scpi_func}\")\n    return scpi_func\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_offset","title":"<code>get_offset(channel, query_type=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_offset(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:\n    ch = self._validate_channel(channel)\n    cmd = f\"SOUR{ch}:VOLTage:OFFSet?\"\n    type_str = \"\"\n    if query_type: cmd += f\" {query_type.value}\"; type_str = f\" ({query_type.name} limit)\"\n    response = (await self._query(cmd)).strip()\n    try:\n        offs = float(response)\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd,\n            message=f\"Failed to parse offset float from response: '{response}'\",\n        )\n    self._logger.debug(f\"Channel {ch}: Offset{type_str} is {offs} V\")\n    return offs\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_output_load_impedance","title":"<code>get_output_load_impedance(channel, query_type=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_output_load_impedance(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; Union[float, OutputLoadImpedance]:\n    ch = self._validate_channel(channel)\n    cmd = f\"OUTPut{ch}:LOAD?\"\n    type_str = \"\"\n    if query_type: cmd += f\" {query_type.value}\"; type_str = f\" ({query_type.name} limit)\"\n    response = (await self._query(cmd)).strip()\n    self._logger.debug(f\"Channel {ch}: Raw impedance response{type_str} is '{response}'\")\n    try:\n        numeric_response = float(response)\n        if abs(numeric_response - 9.9e37) &lt; 1e30: return OutputLoadImpedance.INFINITY\n        else: return numeric_response\n    except ValueError:\n        if response.upper() == OutputLoadImpedance.INFINITY.value.upper(): return OutputLoadImpedance.INFINITY\n        for enum_member in OutputLoadImpedance:\n            if response.upper() == enum_member.value.upper(): return enum_member\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd,\n            message=f\"Could not parse impedance response: '{response}'\",\n        )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_output_polarity","title":"<code>get_output_polarity(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_output_polarity(self, channel: Union[int, str]) -&gt; OutputPolarity:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"OUTPut{ch}:POLarity?\")).strip().upper()\n    try:\n        return OutputPolarity(response)\n    except ValueError:\n        if response == \"NORM\": return OutputPolarity.NORMAL\n        if response == \"INV\": return OutputPolarity.INVERTED\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=f\"OUTPut{ch}:POLarity?\",\n            message=f\"Unexpected polarity response from instrument: {response}\",\n        )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_output_state","title":"<code>get_output_state(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_output_state(self, channel: Union[int, str]) -&gt; SCPIOnOff:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"OUTPut{ch}:STATe?\")).strip()\n    state = SCPIOnOff.ON if response == \"1\" else SCPIOnOff.OFF\n    self._logger.debug(f\"Channel {ch}: Output state is {state.value}\")\n    return state\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_phase","title":"<code>get_phase(channel, query_type=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_phase(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:\n    ch = self._validate_channel(channel)\n    cmd = f\"SOUR{ch}:PHASe?\"\n    type_str = \"\"\n    if query_type: cmd += f\" {query_type.value}\"; type_str = f\" ({query_type.name} limit)\"\n    response = (await self._query(cmd)).strip()\n    try:\n        ph = float(response)\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd,\n            message=f\"Failed to parse phase float from response: '{response}'\",\n        )\n    unit = await self.get_angle_unit()\n    self._logger.debug(f\"Channel {ch}: Phase{type_str} is {ph} {unit}\")\n    return ph\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_phase_unlock_error_state","title":"<code>get_phase_unlock_error_state()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_phase_unlock_error_state(self) -&gt; SCPIOnOff:\n    response = (await self._query(\"SOUR1:PHASe:UNLock:ERRor:STATe?\")).strip()\n    state = SCPIOnOff.ON if response == \"1\" else SCPIOnOff.OFF\n    self._logger.debug(f\"Phase unlock error state is {state.value}\")\n    return state\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_duty_cycle","title":"<code>get_pulse_duty_cycle(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_pulse_duty_cycle(self, channel: Union[int, str]) -&gt; float:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:PULS:DCYCle?\")).strip()\n    return float(response)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_hold_mode","title":"<code>get_pulse_hold_mode(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_pulse_hold_mode(self, channel: Union[int, str]) -&gt; str:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:PULS:HOLD?\")).strip().upper()\n    return response\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_period","title":"<code>get_pulse_period(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_pulse_period(self, channel: Union[int, str]) -&gt; float:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:PULS:PERiod?\")).strip()\n    return float(response)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_transition_both","title":"<code>get_pulse_transition_both(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_pulse_transition_both(self, channel: Union[int, str]) -&gt; float:\n    warnings.warn(\"Querying PULS:TRAN:BOTH; specific query may not exist or might return leading edge time.\", UserWarning, stacklevel=2)\n    return await self.get_pulse_transition_leading(channel)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_transition_leading","title":"<code>get_pulse_transition_leading(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_pulse_transition_leading(self, channel: Union[int, str]) -&gt; float:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:PULS:TRANsition:LEADing?\")).strip()\n    return float(response)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_transition_trailing","title":"<code>get_pulse_transition_trailing(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_pulse_transition_trailing(self, channel: Union[int, str]) -&gt; float:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:PULS:TRANsition:TRAiling?\")).strip()\n    return float(response)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_width","title":"<code>get_pulse_width(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_pulse_width(self, channel: Union[int, str]) -&gt; float:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:PULS:WIDTh?\")).strip()\n    return float(response)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_ramp_symmetry","title":"<code>get_ramp_symmetry(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_ramp_symmetry(self, channel: Union[int, str]) -&gt; float:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:RAMP:SYMMetry?\")).strip()\n    return float(response)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_selected_arbitrary_waveform_name","title":"<code>get_selected_arbitrary_waveform_name(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_selected_arbitrary_waveform_name(self, channel: Union[int, str]) -&gt; str:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:ARBitrary?\")).strip()\n    if response.startswith('\"') and response.endswith('\"'): response = response[1:-1]\n    self._logger.debug(f\"Channel {ch}: Currently selected arbitrary waveform is '{response}'\")\n    return response\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_square_duty_cycle","title":"<code>get_square_duty_cycle(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_square_duty_cycle(self, channel: Union[int, str]) -&gt; float:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:SQUare:DCYCle?\")).strip()\n    return float(response)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_square_period","title":"<code>get_square_period(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_square_period(self, channel: Union[int, str]) -&gt; float:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:FUNC:SQUare:PERiod?\")).strip()\n    return float(response)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_sync_output_mode","title":"<code>get_sync_output_mode(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_sync_output_mode(self, channel: Union[int, str]) -&gt; SyncMode:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"OUTPut{ch}:SYNC:MODE?\")).strip().upper()\n    try:\n        return SyncMode(response)\n    except ValueError:\n        if response == \"NORM\": return SyncMode.NORMAL\n        if response == \"CARR\": return SyncMode.CARRIER\n        if response == \"MARK\": return SyncMode.MARKER\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=f\"OUTPut{ch}:SYNC:MODE?\",\n            message=f\"Unexpected sync mode response from instrument: {response}\",\n        )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_sync_output_polarity","title":"<code>get_sync_output_polarity(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_sync_output_polarity(self, channel: Union[int, str]) -&gt; OutputPolarity:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"OUTPut{ch}:SYNC:POLarity?\")).strip().upper()\n    try:\n        return OutputPolarity(response)\n    except ValueError:\n        if response == \"NORM\": return OutputPolarity.NORMAL\n        if response == \"INV\": return OutputPolarity.INVERTED\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=f\"OUTPut{ch}:SYNC:POLarity?\",\n            message=f\"Unexpected sync polarity response from instrument: {response}\",\n        )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_sync_output_source","title":"<code>get_sync_output_source()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_sync_output_source(self) -&gt; int:\n    response = (await self._query(\"OUTPut:SYNC:SOURce?\")).strip().upper()\n    match = re.match(r\"CH(\\d+)\", response)\n    if match:\n        src_ch = int(match.group(1))\n        self._logger.debug(f\"Sync output source is CH{src_ch}\")\n        return src_ch\n    else:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=\"OUTPut:SYNC:SOURce?\",\n            message=f\"Unexpected response querying Sync source: '{response}'\",\n        )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_sync_output_state","title":"<code>get_sync_output_state()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_sync_output_state(self) -&gt; SCPIOnOff:\n    response = (await self._query(\"OUTPut:SYNC:STATe?\")).strip()\n    state = SCPIOnOff.ON if response == \"1\" else SCPIOnOff.OFF\n    self._logger.debug(f\"Sync output state is {state.value}\")\n    return state\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_autorange_state","title":"<code>get_voltage_autorange_state(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_voltage_autorange_state(self, channel: Union[int, str]) -&gt; SCPIOnOff:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:VOLTage:RANGe:AUTO?\")).strip()\n    state = SCPIOnOff.ON if response == \"1\" else SCPIOnOff.OFF\n    self._logger.debug(f\"Channel {ch}: Voltage autorange state is {state.value} (Query response: {response})\")\n    return state\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_limit_high","title":"<code>get_voltage_limit_high(channel, query_type=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_voltage_limit_high(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:\n    ch = self._validate_channel(channel)\n    cmd = f\"SOUR{ch}:VOLTage:LIMit:HIGH?\"\n    type_str = \"\"\n    if query_type: cmd += f\" {query_type.value}\"; type_str = f\" ({query_type.name} possible)\"\n    response = (await self._query(cmd)).strip()\n    try:\n        val = float(response)\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd,\n            message=f\"Failed to parse high limit float from response: '{response}'\",\n        )\n    self._logger.debug(f\"Channel {ch}: Voltage high limit{type_str} is {val} V\")\n    return val\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_limit_low","title":"<code>get_voltage_limit_low(channel, query_type=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_voltage_limit_low(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:\n    ch = self._validate_channel(channel)\n    cmd = f\"SOUR{ch}:VOLTage:LIMit:LOW?\"\n    type_str = \"\"\n    if query_type: cmd += f\" {query_type.value}\"; type_str = f\" ({query_type.name} possible)\"\n    response = (await self._query(cmd)).strip()\n    try:\n        val = float(response)\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd,\n            message=f\"Failed to parse low limit float from response: '{response}'\",\n        )\n    self._logger.debug(f\"Channel {ch}: Voltage low limit{type_str} is {val} V\")\n    return val\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_limits_state","title":"<code>get_voltage_limits_state(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_voltage_limits_state(self, channel: Union[int, str]) -&gt; SCPIOnOff:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:VOLTage:LIMit:STATe?\")).strip()\n    state = SCPIOnOff.ON if response == \"1\" else SCPIOnOff.OFF\n    self._logger.debug(f\"Channel {ch}: Voltage limits state is {state.value}\")\n    return state\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_unit","title":"<code>get_voltage_unit(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def get_voltage_unit(self, channel: Union[int, str]) -&gt; VoltageUnit:\n    ch = self._validate_channel(channel)\n    response = (await self._query(f\"SOUR{ch}:VOLTage:UNIT?\")).strip().upper()\n    try:\n        return VoltageUnit(response)\n    except ValueError:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=f\"SOUR{ch}:VOLTage:UNIT?\",\n            message=f\"Unexpected voltage unit response from instrument: {response}\",\n        )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.list_directory","title":"<code>list_directory(path='')</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def list_directory(self, path: str = \"\") -&gt; FileSystemInfo:\n    path_scpi = f' \"{path}\"' if path else \"\"\n    cmd = f\"MMEMory:CATalog:ALL?{path_scpi}\"\n    response = (await self._query(cmd)).strip()\n    try:\n        parts = response.split(',', 2)\n        if len(parts) &lt; 2:\n            raise InstrumentCommunicationError(\n                instrument=self.config.model,\n                command=cmd,\n                message=f\"Unexpected response format from MMEM:CAT?: {response}\",\n            )\n        bytes_used = int(parts[0])\n        bytes_free = int(parts[1])\n        info = FileSystemInfo(bytes_used=bytes_used, bytes_free=bytes_free)\n        if len(parts) &gt; 2 and parts[2]:\n            file_pattern = r'\"([^\"]+),([^\"]*),(\\d+)\"'\n            listings = re.findall(file_pattern, parts[2])\n            for name, ftype, size_str in listings:\n                file_type = ftype if ftype else 'FILE'\n                try:\n                    size = int(size_str)\n                except ValueError:\n                    self._log(f\"Warning: Could not parse size '{size_str}' for file '{name}'.\", level=\"warning\")\n                    continue\n                info.files.append({'name': name, 'type': file_type.upper(), 'size': size})\n        self._logger.log(f\"Directory listing for '{path or 'current dir'}': Used={info.bytes_used}, Free={info.bytes_free}, Items={len(info.files)}\")\n        return info\n    except (ValueError, IndexError) as e:\n        raise InstrumentCommunicationError(\n            instrument=self.config.model,\n            command=cmd,\n            message=f\"Failed to parse MMEM:CAT? response: '{response}'. Error: {e}\",\n        ) from e\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.select_arbitrary_waveform","title":"<code>select_arbitrary_waveform(channel, arb_name)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def select_arbitrary_waveform(self, channel: Union[int, str], arb_name: str) -&gt; None:\n    ch = self._validate_channel(channel)\n    if not arb_name:\n        raise InstrumentParameterError(\n            parameter=\"arb_name\", message=\"Arbitrary waveform name cannot be empty.\"\n        )\n    if '\"' in arb_name or \"'\" in arb_name:\n        raise InstrumentParameterError(\n            parameter=\"arb_name\",\n            value=arb_name,\n            message=\"Arbitrary waveform name cannot contain quotes.\",\n        )\n    quoted_arb_name = f'\"{arb_name}\"'\n    await self._send_command(f\"SOUR{ch}:FUNC:ARBitrary {quoted_arb_name}\")\n    self._logger.debug(f\"Channel {ch}: Active arbitrary waveform selection set to '{arb_name}'\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_am_depth","title":"<code>set_am_depth(channel, depth_percent)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_am_depth(self, channel: Union[int, str], depth_percent: Union[float, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val = self._format_value_min_max_def(depth_percent)\n    if isinstance(depth_percent, (int, float)) and not (0 &lt;= float(depth_percent) &lt;= 120):\n        self._log(f\"Warning: AM depth {depth_percent}% is outside typical 0-120 range.\", level=\"warning\")\n    await self._send_command(f\"SOUR{ch}:AM:DEPTh {cmd_val}\")\n    self._logger.log(f\"Channel {ch}: AM depth set to {depth_percent}%\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_am_source","title":"<code>set_am_source(channel, source)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_am_source(self, channel: Union[int, str], source: ModulationSource) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_src = source.value\n    if cmd_src == f\"CH{ch}\":\n        raise InstrumentParameterError(\n            parameter=\"source\",\n            value=source,\n            message=f\"Channel {ch} cannot be its own AM source.\",\n        )\n    if cmd_src == ModulationSource.CH2.value and self.channel_count &lt; 2:\n        raise InstrumentParameterError(\n            parameter=\"source\",\n            value=source,\n            message=\"CH2 source invalid for 1-channel instrument.\",\n        )\n    await self._send_command(f\"SOUR{ch}:AM:SOURce {cmd_src}\")\n    self._logger.log(f\"Channel {ch}: AM source set to {cmd_src}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_amplitude","title":"<code>set_amplitude(channel, amplitude)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_amplitude(self, channel: Union[int, str], amplitude: Union[float, OutputLoadImpedance, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    amp_cmd_val = self._format_value_min_max_def(amplitude)\n    if isinstance(amplitude, (int, float)):\n        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):\n            channel_config_model = self.config.channels[ch-1]\n            channel_config_model.amplitude.assert_in_range(float(amplitude), name=f\"Amplitude for CH{ch}\")\n    await self._send_command(f\"SOUR{ch}:VOLTage {amp_cmd_val}\")\n    unit = await self.get_voltage_unit(ch)\n    self._logger.debug(f\"Channel {ch}: Amplitude set to {amplitude} (in current unit: {unit.value}, using SCPI value: {amp_cmd_val})\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_angle_unit","title":"<code>set_angle_unit(unit)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_angle_unit(self, unit: str) -&gt; None:\n    unit_upper = unit.upper().strip()\n    valid_scpi_units = {\"DEGREE\", \"RADIAN\", \"SECOND\", \"DEG\", \"RAD\", \"SEC\"}\n    map_to_scpi_preferred = {\"DEG\": \"DEGREE\", \"DEGREES\": \"DEGREE\", \"RAD\": \"RADIAN\", \"RADIANS\": \"RADIAN\", \"SEC\": \"SECOND\", \"SECONDS\": \"SECOND\"}\n    scpi_to_send = map_to_scpi_preferred.get(unit_upper, unit_upper)\n    if scpi_to_send not in valid_scpi_units and unit_upper not in valid_scpi_units :\n        raise InstrumentParameterError(\n            parameter=\"unit\",\n            value=unit,\n            valid_range=[\"DEGREE\", \"RADIAN\", \"SECONd\"],\n            message=\"Invalid angle unit.\",\n        )\n    await self._send_command(f\"UNIT:ANGLe {scpi_to_send}\")\n    self._logger.debug(f\"Global angle unit set to {scpi_to_send}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_arbitrary_waveform_sample_rate","title":"<code>set_arbitrary_waveform_sample_rate(channel, sample_rate)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_arbitrary_waveform_sample_rate(self, channel: Union[int, str], sample_rate: Union[float, OutputLoadImpedance, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val = self._format_value_min_max_def(sample_rate)\n    if isinstance(sample_rate, (int, float)):\n        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):\n            channel_config_model = self.config.channels[ch-1]\n            if hasattr(channel_config_model, 'arbitrary') and hasattr(channel_config_model.arbitrary, 'sampling_rate'):\n                channel_config_model.arbitrary.sampling_rate.assert_in_range(float(sample_rate), name=f\"Arbitrary sample rate for CH{ch}\")\n    await self._send_command(f\"SOUR{ch}:FUNC:ARB:SRATe {cmd_val}\")\n    self._logger.debug(f\"Channel {ch}: Arbitrary waveform sample rate set to {sample_rate} Sa/s (using SCPI value: {cmd_val})\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_burst_cycles","title":"<code>set_burst_cycles(channel, n_cycles)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_burst_cycles(self, channel: Union[int, str], n_cycles: Union[int, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val: str\n    log_val: Union[int, str] = n_cycles\n    if isinstance(n_cycles, str):\n        nc_upper = n_cycles.upper().strip()\n        if nc_upper in {\"MIN\", \"MINIMUM\"}:\n            cmd_val = OutputLoadImpedance.MINIMUM.value\n        elif nc_upper in {\"MAX\", \"MAXIMUM\"}:\n            cmd_val = OutputLoadImpedance.MAXIMUM.value\n        elif nc_upper in {\"INF\", \"INFINITY\"}:\n            cmd_val = \"INFinity\"\n        else:\n            raise InstrumentParameterError(\n                parameter=\"n_cycles\",\n                value=n_cycles,\n                message=\"Invalid string for burst cycles.\",\n            )\n    elif isinstance(n_cycles, int):\n        if n_cycles &lt; 1:\n            raise InstrumentParameterError(\n                parameter=\"n_cycles\",\n                value=n_cycles,\n                message=\"Burst cycle count must be positive.\",\n            )\n        inst_max_cycles = 100_000_000\n        if n_cycles &gt; inst_max_cycles:\n            self._log(f\"Warning: Burst cycles {n_cycles} &gt; typical max ({inst_max_cycles}).\", level=\"warning\")\n        cmd_val = str(n_cycles)\n    else:\n        raise InstrumentParameterError(\n            parameter=\"n_cycles\",\n            value=n_cycles,\n            message=f\"Invalid type '{type(n_cycles)}' for burst cycles.\",\n        )\n    await self._send_command(f\"SOUR{ch}:BURSt:NCYCles {cmd_val}\")\n    self._logger.log(f\"Channel {ch}: Burst cycles set to {log_val}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_burst_mode","title":"<code>set_burst_mode(channel, mode)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_burst_mode(self, channel: Union[int, str], mode: BurstMode) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"SOUR{ch}:BURSt:MODE {mode.value}\")\n    self._logger.log(f\"Channel {ch}: Burst mode set to {mode.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_burst_period","title":"<code>set_burst_period(channel, period_sec)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_burst_period(self, channel: Union[int, str], period_sec: Union[float, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val = self._format_value_min_max_def(period_sec)\n    await self._send_command(f\"SOUR{ch}:BURSt:INTernal:PERiod {cmd_val}\")\n    self._logger.log(f\"Channel {ch}: Internal burst period set to {period_sec} s\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_fm_deviation","title":"<code>set_fm_deviation(channel, deviation_hz)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_fm_deviation(self, channel: Union[int, str], deviation_hz: Union[float, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val = self._format_value_min_max_def(deviation_hz)\n    await self._send_command(f\"SOUR{ch}:FM:DEViation {cmd_val}\")\n    self._logger.log(f\"Channel {ch}: FM deviation set to {deviation_hz} Hz\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_frequency","title":"<code>set_frequency(channel, frequency)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_frequency(self, channel: Union[int, str], frequency: Union[float, OutputLoadImpedance, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    freq_cmd_val = self._format_value_min_max_def(frequency)\n    if isinstance(frequency, (int, float)):\n        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):\n            channel_config_model = self.config.channels[ch - 1]\n            channel_config_model.frequency.assert_in_range(float(frequency), name=f\"Frequency for CH{ch}\")\n    await self._send_command(f\"SOUR{ch}:FREQ {freq_cmd_val}\")\n    self._logger.debug(f\"Channel {ch}: Frequency set to {frequency} Hz (using SCPI value: {freq_cmd_val})\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_function","title":"<code>set_function(channel, function_type, **kwargs)</code>  <code>async</code>","text":"<p>Sets the primary waveform function and associated parameters for a channel.</p> Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_function(self, channel: Union[int, str], function_type: Union[WaveformType, str], **kwargs: Any) -&gt; None:\n    \"\"\"\n    Sets the primary waveform function and associated parameters for a channel.\n    \"\"\"\n    ch = self._validate_channel(channel)\n    scpi_func_short = self._get_scpi_function_name(function_type)\n\n    standard_params_set: Dict[str, bool] = {}\n    # Assuming FUNC_ARB should be WaveformType.ARB.value\n    if 'frequency' in kwargs and scpi_func_short != WaveformType.ARB.value:\n        await self.set_frequency(ch, kwargs.pop('frequency'))\n        standard_params_set['frequency'] = True\n    if 'amplitude' in kwargs:\n        await self.set_amplitude(ch, kwargs.pop('amplitude'))\n        standard_params_set['amplitude'] = True\n    if 'offset' in kwargs:\n        await self.set_offset(ch, kwargs.pop('offset'))\n        standard_params_set['offset'] = True\n\n    await self._send_command(f\"SOUR{ch}:FUNC {scpi_func_short}\")\n    self._logger.debug(f\"Channel {ch}: Function set to {function_type} (SCPI: {scpi_func_short})\")\n    await self._error_check()\n\n    if kwargs:\n        # Ensure WAVEFORM_PARAM_COMMANDS keys are WaveformType enum members\n        # And scpi_func_short is mapped to its corresponding WaveformType enum member if it's a string\n        func_enum_key: Optional[WaveformType] = None\n        if isinstance(function_type, WaveformType):\n            func_enum_key = function_type\n        elif isinstance(function_type, str):\n            try:\n                # First try to convert SCPI string directly to enum member\n                func_enum_key = WaveformType(scpi_func_short)\n            except ValueError:\n                # If that fails, try to map profile config values to enum members\n                scpi_to_enum_map = {\n                    \"SINUSOID\": WaveformType.SINE,\n                    \"SQUARE\": WaveformType.SQUARE,\n                    \"RAMP\": WaveformType.RAMP,\n                    \"PULSE\": WaveformType.PULSE,\n                    \"NOISE\": WaveformType.NOISE,\n                    \"DC\": WaveformType.DC,\n                    \"ARB\": WaveformType.ARB,\n                    \"ARBITRARY\": WaveformType.ARB,\n                    # Add enum values as fallback\n                    \"SIN\": WaveformType.SINE,\n                    \"SQU\": WaveformType.SQUARE,\n                    \"PULS\": WaveformType.PULSE,\n                    \"NOIS\": WaveformType.NOISE,\n                }\n                func_enum_key = scpi_to_enum_map.get(scpi_func_short.upper())\n                if func_enum_key is None:\n                    self._logger.warning(f\"SCPI function '{scpi_func_short}' not mappable to WaveformType enum for parameter lookup.\")\n\n        param_cmds_for_func = WAVEFORM_PARAM_COMMANDS.get(func_enum_key) if func_enum_key else None\n\n        if not param_cmds_for_func:\n            self._logger.warning(f\"No specific parameters defined for function '{function_type}' (SCPI: {scpi_func_short}). \"\n                      f\"Ignoring remaining kwargs: {kwargs}\")\n            if any(k not in standard_params_set for k in kwargs):\n                raise InstrumentParameterError(\n                    message=f\"Unknown parameters {list(kwargs.keys())} passed for function {function_type}.\"\n                )\n            return\n\n        for param_name, value in kwargs.items():\n            if param_name in param_cmds_for_func:\n                try:\n                    if param_name in [\"duty_cycle\", \"symmetry\"] and isinstance(value, (int, float)):\n                        if not (0 &lt;= float(value) &lt;= 100):\n                            self._logger.warning(f\"Parameter '{param_name}' value {value}% is outside the \"\n                                      f\"typical 0-100 range. Instrument validation will apply.\")\n\n                    value_to_format = value\n                    if isinstance(value, (ArbFilterType, ArbAdvanceMode)): # Pass enum value for formatting\n                        value_to_format = value.value\n\n                    formatted_value = self._format_value_min_max_def(value_to_format)\n                    cmd_lambda = param_cmds_for_func[param_name]\n                    cmd = cmd_lambda(ch, formatted_value)\n\n                    await self._send_command(cmd)\n                    self._logger.debug(f\"Channel {ch}: Parameter '{param_name}' set to {value}\")\n                    await self._error_check()\n                except InstrumentParameterError as ipe:\n                    raise InstrumentParameterError(\n                        parameter=param_name,\n                        value=value,\n                        message=f\"Invalid value for function '{function_type}'. Cause: {ipe}\",\n                    ) from ipe\n                except InstrumentCommunicationError:\n                    raise\n                except Exception as e:\n                    self._logger.error(f\"Error setting parameter '{param_name}' for function '{scpi_func_short}': {e}\")\n                    raise InstrumentCommunicationError(\n                        instrument=self.config.model,\n                        command=cmd,\n                        message=f\"Failed to set parameter {param_name}\",\n                    ) from e\n            else:\n                raise InstrumentParameterError(\n                    parameter=param_name,\n                    message=f\"Parameter is not supported for function '{function_type}' ({scpi_func_short}). Supported: {list(param_cmds_for_func.keys())}\",\n                )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_offset","title":"<code>set_offset(channel, offset)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_offset(self, channel: Union[int, str], offset: Union[float, OutputLoadImpedance, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    offset_cmd_val = self._format_value_min_max_def(offset)\n    await self._send_command(f\"SOUR{ch}:VOLTage:OFFSet {offset_cmd_val}\")\n    self._logger.debug(f\"Channel {ch}: Offset set to {offset} V\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_output_load_impedance","title":"<code>set_output_load_impedance(channel, impedance)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_output_load_impedance(self, channel: Union[int, str], impedance: Union[float, OutputLoadImpedance, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_impedance = self._format_value_min_max_def(impedance)\n    if isinstance(impedance, (int, float)):\n        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):\n            channel_config_model = self.config.channels[ch-1]\n            if hasattr(channel_config_model, 'output') and hasattr(channel_config_model.output, 'load_impedance'):\n                channel_config_model.output.load_impedance.assert_in_range(float(impedance), name=f\"Load impedance for CH{ch}\")\n    await self._send_command(f\"OUTPut{ch}:LOAD {cmd_impedance}\")\n    self._logger.debug(f\"Channel {ch}: Output load impedance setting updated to {impedance} (using SCPI value: {cmd_impedance})\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_output_polarity","title":"<code>set_output_polarity(channel, polarity)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_output_polarity(self, channel: Union[int, str], polarity: OutputPolarity) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"OUTPut{ch}:POLarity {polarity.value}\")\n    self._logger.debug(f\"Channel {ch}: Output polarity set to {polarity.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_output_state","title":"<code>set_output_state(channel, state)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call # Duplicated @validate_call removed\nasync def set_output_state(self, channel: Union[int, str], state: SCPIOnOff) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"OUTPut{ch}:STATe {state.value}\")\n    self._logger.debug(f\"Channel {ch}: Output state set to {state.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_phase","title":"<code>set_phase(channel, phase)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_phase(self, channel: Union[int, str], phase: Union[float, OutputLoadImpedance, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    phase_cmd_val = self._format_value_min_max_def(phase)\n    if isinstance(phase, (int, float)):\n        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):\n            channel_config_model = self.config.channels[ch-1]\n            channel_config_model.phase.assert_in_range(float(phase), name=f\"Phase for CH{ch}\")\n    await self._send_command(f\"SOUR{ch}:PHASe {phase_cmd_val}\")\n    unit = await self.get_angle_unit()\n    self._logger.debug(f\"Channel {ch}: Phase set to {phase} (in current unit: {unit}, using SCPI value: {phase_cmd_val})\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_phase_reference","title":"<code>set_phase_reference(channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_phase_reference(self, channel: Union[int, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"SOUR{ch}:PHASe:REFerence\")\n    self._logger.debug(f\"Channel {ch}: Phase reference reset (current phase defined as 0).\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_phase_unlock_error_state","title":"<code>set_phase_unlock_error_state(state)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_phase_unlock_error_state(self, state: SCPIOnOff) -&gt; None:\n    await self._send_command(f\"SOUR1:PHASe:UNLock:ERRor:STATe {state.value}\")\n    self._logger.debug(f\"Phase unlock error state set to {state.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sweep_spacing","title":"<code>set_sweep_spacing(channel, spacing)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_sweep_spacing(self, channel: Union[int, str], spacing: SweepSpacing) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"SOUR{ch}:SWEep:SPACing {spacing.value}\")\n    self._logger.debug(f\"Channel {ch}: Sweep spacing set to {spacing.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sweep_start_frequency","title":"<code>set_sweep_start_frequency(channel, freq_hz)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_sweep_start_frequency(self, channel: Union[int, str], freq_hz: Union[float, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val = self._format_value_min_max_def(freq_hz)\n    await self._send_command(f\"SOUR{ch}:FREQuency:STARt {cmd_val}\")\n    self._logger.debug(f\"Channel {ch}: Sweep start frequency set to {freq_hz} Hz\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sweep_stop_frequency","title":"<code>set_sweep_stop_frequency(channel, freq_hz)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_sweep_stop_frequency(self, channel: Union[int, str], freq_hz: Union[float, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val = self._format_value_min_max_def(freq_hz)\n    await self._send_command(f\"SOUR{ch}:FREQuency:STOP {cmd_val}\")\n    self._logger.debug(f\"Channel {ch}: Sweep stop frequency set to {freq_hz} Hz\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sweep_time","title":"<code>set_sweep_time(channel, sweep_time_sec)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_sweep_time(self, channel: Union[int, str], sweep_time_sec: Union[float, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val = self._format_value_min_max_def(sweep_time_sec)\n    await self._send_command(f\"SOUR{ch}:SWEep:TIME {cmd_val}\")\n    self._logger.log(f\"Channel {ch}: Sweep time set to {sweep_time_sec} s\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sync_output_mode","title":"<code>set_sync_output_mode(channel, mode)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_sync_output_mode(self, channel: Union[int, str], mode: SyncMode) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"OUTPut{ch}:SYNC:MODE {mode.value}\")\n    self._logger.debug(f\"Channel {ch}: Sync output mode set to {mode.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sync_output_polarity","title":"<code>set_sync_output_polarity(channel, polarity)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_sync_output_polarity(self, channel: Union[int, str], polarity: OutputPolarity) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"OUTPut{ch}:SYNC:POLarity {polarity.value}\")\n    self._logger.debug(f\"Channel {ch}: Sync output polarity set to {polarity.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sync_output_source","title":"<code>set_sync_output_source(source_channel)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_sync_output_source(self, source_channel: int) -&gt; None:\n    ch_to_set = self._validate_channel(source_channel)\n    await self._send_command(f\"OUTPut:SYNC:SOURce CH{ch_to_set}\")\n    self._logger.debug(f\"Sync output source set to CH{ch_to_set}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sync_output_state","title":"<code>set_sync_output_state(state)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_sync_output_state(self, state: SCPIOnOff) -&gt; None:\n    await self._send_command(f\"OUTPut:SYNC:STATe {state.value}\")\n    self._logger.debug(f\"Sync output state set to {state.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_trigger_slope","title":"<code>set_trigger_slope(channel, slope)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_trigger_slope(self, channel: Union[int, str], slope: TriggerSlope) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"TRIGger{ch}:SLOPe {slope.value}\")\n    self._logger.log(f\"Channel {ch}: Trigger slope set to {slope.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_trigger_source","title":"<code>set_trigger_source(channel, source)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def set_trigger_source(self, channel: Union[int, str], source: TriggerSource) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"TRIGger{ch}:SOURce {source.value}\")\n    self._logger.log(f\"Channel {ch}: Trigger source set to {source.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_autorange_state","title":"<code>set_voltage_autorange_state(channel, state)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_voltage_autorange_state(self, channel: Union[int, str], state: SCPIOnOff) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"SOUR{ch}:VOLTage:RANGe:AUTO {state.value}\")\n    self._logger.debug(f\"Channel {ch}: Voltage autorange state set to {state.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_limit_high","title":"<code>set_voltage_limit_high(channel, voltage)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_voltage_limit_high(self, channel: Union[int, str], voltage: Union[float, OutputLoadImpedance, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val = self._format_value_min_max_def(voltage)\n    await self._send_command(f\"SOUR{ch}:VOLTage:LIMit:HIGH {cmd_val}\")\n    self._logger.debug(f\"Channel {ch}: Voltage high limit set to {voltage} V (using SCPI value: {cmd_val})\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_limit_low","title":"<code>set_voltage_limit_low(channel, voltage)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_voltage_limit_low(self, channel: Union[int, str], voltage: Union[float, OutputLoadImpedance, str]) -&gt; None:\n    ch = self._validate_channel(channel)\n    cmd_val = self._format_value_min_max_def(voltage)\n    await self._send_command(f\"SOUR{ch}:VOLTage:LIMit:LOW {cmd_val}\")\n    self._logger.debug(f\"Channel {ch}: Voltage low limit set to {voltage} V (using SCPI value: {cmd_val})\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_limits_state","title":"<code>set_voltage_limits_state(channel, state)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_voltage_limits_state(self, channel: Union[int, str], state: SCPIOnOff) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"SOUR{ch}:VOLTage:LIMit:STATe {state.value}\")\n    self._logger.debug(f\"Channel {ch}: Voltage limits state set to {state.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_unit","title":"<code>set_voltage_unit(channel, unit)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def set_voltage_unit(self, channel: Union[int, str], unit: VoltageUnit) -&gt; None:\n    ch = self._validate_channel(channel)\n    await self._send_command(f\"SOUR{ch}:VOLTage:UNIT {unit.value}\")\n    self._logger.debug(f\"Channel {ch}: Voltage unit set to {unit.value}\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.synchronize_phase_all_channels","title":"<code>synchronize_phase_all_channels()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>@validate_call\nasync def synchronize_phase_all_channels(self) -&gt; None:\n    if self.channel_count &lt; 2:\n        self._logger.warning(\"Warning: Phase synchronization command sent, but primarily intended for multi-channel instruments.\")\n    await self._send_command(\"PHASe:SYNChronize\")\n    self._logger.debug(\"All channels/internal phase generators synchronized.\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.WaveformGenerator.WaveformGenerator.trigger_now","title":"<code>trigger_now(channel=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/WaveformGenerator.py</code> <pre><code>async def trigger_now(self, channel: Optional[Union[int, str]] = None) -&gt; None:\n    if channel is not None:\n        ch = self._validate_channel(channel)\n        await self._send_command(f\"TRIGger{ch}\")\n        self._logger.log(f\"Sent immediate channel-specific trigger command TRIGger{ch}\")\n    else:\n        await self._send_command(\"*TRG\")\n        self._logger.log(\"Sent general bus trigger command *TRG\")\n    await self._error_check()\n</code></pre>"},{"location":"api/instruments/#multimeter","title":"Multimeter","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter","title":"<code>pytestlab.instruments.Multimeter</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.logger","title":"<code>logger = get_logger(__name__)</code>  <code>module-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter-classes","title":"Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter","title":"<code>Multimeter(config, backend, **kwargs)</code>","text":"<p>               Bases: <code>Instrument[MultimeterConfig]</code></p> <p>Drives a Digital Multimeter (DMM) for various measurements.</p> <p>This class provides a high-level interface for controlling a DMM, building upon the base <code>Instrument</code> class. It includes methods for common DMM operations such as measuring voltage, current, resistance, and frequency. It also handles instrument-specific configurations and can incorporate measurement uncertainty based on the provided configuration.</p> ATTRIBUTE DESCRIPTION <code>config</code> <p>The Pydantic configuration object (<code>MultimeterConfig</code>)     containing settings specific to this DMM.</p> <p> TYPE: <code>MultimeterConfig</code> </p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO\n    \"\"\"\n    Initialize the Instrument class.\n\n    Args:\n        config (ConfigType): Configuration for the instrument.\n        backend (AsyncInstrumentIO): The communication backend instance.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    if not isinstance(config, InstrumentConfig): # Check against the bound base\n        raise InstrumentConfigurationError(\n            self.__class__.__name__,\n            f\"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.\",\n        )\n\n    self.config = config\n    self._backend = backend # This will be an AsyncInstrumentIO instance\n    self._command_log = []\n\n    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__\n    self._logger = get_logger(logger_name)\n\n    self._logger.info(f\"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter.config","title":"<code>config</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter.configure_measurement","title":"<code>configure_measurement(function, range_val=None, resolution=None)</code>  <code>async</code>","text":"<p>Configures the instrument for a measurement without triggering it.</p> Source code in <code>pytestlab/instruments/Multimeter.py</code> <pre><code>async def configure_measurement(self, function: DMMFunction, range_val: Optional[str] = None, resolution: Optional[str] = None):\n    \"\"\"Configures the instrument for a measurement without triggering it.\"\"\"\n    scpi_function_val = function.value\n    range_for_query = range_val.upper() if range_val is not None else \"AUTO\"\n    resolution_for_query = resolution.upper() if resolution is not None else \"DEF\"\n    # Using CONFigure command as per programming guide page 44\n    cmd = f\"CONFigure:{scpi_function_val} {range_for_query},{resolution_for_query}\"\n    await self._send_command(cmd)\n    self._logger.info(f\"Configured DMM for {function.name} with range={range_for_query}, resolution={resolution_for_query}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter.from_config","title":"<code>from_config(config, debug_mode=False)</code>  <code>classmethod</code>","text":"Source code in <code>pytestlab/instruments/Multimeter.py</code> <pre><code>@classmethod\ndef from_config(cls: Type[\"Multimeter\"], config: MultimeterConfig, debug_mode: bool = False) -&gt; \"Multimeter\":\n    # This method is generally handled by the `AutoInstrument` factory.\n    # It's provided here for completeness but direct instantiation is preferred\n    # when not using the factory.\n    # If config is a dict that needs to be passed to MultimeterConfig constructor:\n    # return cls(config=MultimeterConfig(**config), debug_mode=debug_mode)\n    # If config is already a MultimeterConfig instance:\n    raise NotImplementedError(\"Please use AutoInstrument.from_config() to create instrument instances.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter.get_config","title":"<code>get_config()</code>  <code>async</code>","text":"<p>Retrieves the current measurement configuration from the DMM.</p> <p>This method queries the instrument to determine its current settings, such as the active measurement function, range, and resolution. It then parses this information into a structured <code>MultimeterConfigResult</code> object.</p> RETURNS DESCRIPTION <code>MultimeterConfigResult</code> <p>A <code>MultimeterConfigResult</code> dataclass instance with the DMM's current</p> <code>MultimeterConfigResult</code> <p>configuration.</p> RAISES DESCRIPTION <code>InstrumentDataError</code> <p>If the configuration string from the DMM                  cannot be parsed.</p> Source code in <code>pytestlab/instruments/Multimeter.py</code> <pre><code>async def get_config(self) -&gt; MultimeterConfigResult:\n    \"\"\"Retrieves the current measurement configuration from the DMM.\n\n    This method queries the instrument to determine its current settings,\n    such as the active measurement function, range, and resolution. It then\n    parses this information into a structured `MultimeterConfigResult` object.\n\n    Returns:\n        A `MultimeterConfigResult` dataclass instance with the DMM's current\n        configuration.\n\n    Raises:\n        InstrumentDataError: If the configuration string from the DMM\n                             cannot be parsed.\n    \"\"\"\n    # Query the instrument for its current configuration. The response is typically\n    # a string like '\"VOLT:DC 10,0.0001\"'.\n    config_str: str = (await self._query(\"CONFigure?\")).replace('\"', '').strip()\n    try:\n        # Handle cases where resolution is not returned, e.g., \"FRES 1.000000E+02\"\n        parts = config_str.split()\n        mode_part = parts[0]\n\n        # Settings part can be complex, find first comma\n        settings_part = \" \".join(parts[1:])\n        if ',' in settings_part:\n            range_str, resolution_str = settings_part.split(\",\", 1)\n        else:\n            range_str = settings_part\n            resolution_str = \"N/A\" # Resolution not specified in query response\n\n        # Parse the string to extract the mode, range, and resolution.\n        range_value_float: float = float(range_str)\n    except (ValueError, IndexError) as e:\n        raise InstrumentDataError(self.config.model, f\"Failed to parse configuration string: '{config_str}'\") from e\n\n    # Determine human-friendly measurement mode and assign units based on mode\n    measurement_mode_str: str = \"\" # Renamed\n    unit_str: str = \"\" # Renamed\n    mode_upper: str = mode_part.upper()\n    if mode_upper.startswith(\"VOLT\"):\n        measurement_mode_str = \"Voltage\"\n        unit_str = \"V\"\n    elif mode_upper.startswith(\"CURR\"):\n        measurement_mode_str = \"Current\"\n        unit_str = \"A\"\n    elif \"RES\" in mode_upper: # Catches RES and FRES\n        measurement_mode_str = \"Resistance\"\n        unit_str = \"Ohm\"\n    elif \"FREQ\" in mode_upper:\n        measurement_mode_str = \"Frequency\"\n        unit_str = \"Hz\"\n    elif mode_upper.startswith(\"TEMP\"):\n        measurement_mode_str = \"Temperature\"\n        unit_str = \"\u00b0C\"  # Default; could also be \u00b0F depending on settings\n    else:\n        measurement_mode_str = mode_part\n\n    return MultimeterConfigResult(\n        measurement_mode=measurement_mode_str,\n        range_value=range_value_float,\n        resolution=resolution_str.strip(),\n        units=unit_str\n    )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter.measure","title":"<code>measure(function, range_val=None, resolution=None)</code>  <code>async</code>","text":"<p>Performs a measurement and returns the result.</p> <p>This is the primary method for acquiring data from the DMM. It configures the measurement, triggers it, and reads the result. If measurement accuracy specifications are provided in the instrument's configuration, this method will calculate the uncertainty and return the value as a <code>UFloat</code> object.</p> PARAMETER DESCRIPTION <code>function</code> <p>The measurement function to perform (e.g., DC Voltage).</p> <p> TYPE: <code>DMMFunction</code> </p> <code>range_val</code> <p>The measurement range (e.g., \"1V\", \"AUTO\"). If not provided,        \"AUTO\" is used. The value is validated against the ranges        defined in the instrument's configuration.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>resolution</code> <p>The desired resolution (e.g., \"MIN\", \"MAX\", \"DEF\"). If not         provided, \"DEF\" (default) is used.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>MeasurementResult</code> <p>A <code>MeasurementResult</code> object containing the measured value (as a float</p> <code>MeasurementResult</code> <p>or <code>UFloat</code>), units, and other metadata.</p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If an unsupported <code>range_val</code> is provided.</p> Source code in <code>pytestlab/instruments/Multimeter.py</code> <pre><code>async def measure(self, function: DMMFunction, range_val: Optional[str] = None, resolution: Optional[str] = None) -&gt; MeasurementResult:\n    \"\"\"Performs a measurement and returns the result.\n\n    This is the primary method for acquiring data from the DMM. It configures\n    the measurement, triggers it, and reads the result. If measurement\n    accuracy specifications are provided in the instrument's configuration,\n    this method will calculate the uncertainty and return the value as a\n    `UFloat` object.\n\n    Args:\n        function: The measurement function to perform (e.g., DC Voltage).\n        range_val: The measurement range (e.g., \"1V\", \"AUTO\"). If not provided,\n                   \"AUTO\" is used. The value is validated against the ranges\n                   defined in the instrument's configuration.\n        resolution: The desired resolution (e.g., \"MIN\", \"MAX\", \"DEF\"). If not\n                    provided, \"DEF\" (default) is used.\n\n    Returns:\n        A `MeasurementResult` object containing the measured value (as a float\n        or `UFloat`), units, and other metadata.\n\n    Raises:\n        InstrumentParameterError: If an unsupported `range_val` is provided.\n    \"\"\"\n    scpi_function_val = function.value\n    is_autorange = range_val is None or range_val.upper() == \"AUTO\"\n\n    # The MEASure command is a combination of CONFigure, INITiate, and FETCh.\n    # This is convenient but makes querying the actual range used in autorange tricky.\n    # For accurate uncertainty, we will use CONFigure separately when in autorange.\n    if is_autorange:\n        await self.set_measurement_function(function)\n        await self._send_command(f\"{function.value}:RANGe:AUTO ON\")\n        if resolution:\n            await self._send_command(f\"{function.value}:RESolution {resolution.upper()}\")\n\n        response_str = await self._query(\"READ?\")\n    else:\n        # Use the combined MEASure? command for fixed range\n        range_for_query = range_val.upper() if range_val is not None else \"AUTO\"\n        resolution_for_query = resolution.upper() if resolution is not None else \"DEF\"\n        query_command = f\"MEASURE:{scpi_function_val}? {range_for_query},{resolution_for_query}\"\n        self._logger.debug(f\"Executing DMM measure query: {query_command}\")\n        response_str = await self._query(query_command)\n\n    try:\n        reading = float(response_str)\n    except ValueError:\n        raise InstrumentDataError(self.config.instrument['model'], f\"Could not parse measurement reading: '{response_str}'\")\n\n    value_to_return: Union[float, UFloat] = reading\n\n    # --- Uncertainty Calculation ---\n    function_spec = self._get_function_spec(function)\n    if function_spec:\n        try:\n            # Determine the actual range used by the instrument to find the correct spec\n            current_instrument_config = await self.get_config()\n            actual_instrument_range = current_instrument_config.range_value\n\n            # Find the matching range specification\n            matching_range_spec = None\n            # Find the smallest nominal range that is &gt;= the actual range used.\n            # Assumes specs in YAML are sorted by nominal value, which is typical.\n            for r_spec in sorted(function_spec.ranges, key=lambda r: r.nominal):\n                if r_spec.nominal &gt;= actual_instrument_range:\n                    matching_range_spec = r_spec\n                    break\n\n            # Fallback to the largest range if no suitable one is found (e.g. if actual &gt; largest nominal)\n            if not matching_range_spec:\n                matching_range_spec = max(function_spec.ranges, key=lambda r: r.nominal)\n\n            if matching_range_spec:\n                accuracy_spec = matching_range_spec.default_accuracy\n                if accuracy_spec:\n                    # Use the spec's nominal value for the '% of range' calculation\n                    range_for_calc = matching_range_spec.nominal\n                    std_dev = accuracy_spec.calculate_uncertainty(reading, range_for_calc)\n                    if std_dev &gt; 0:\n                        value_to_return = ufloat(reading, std_dev)\n                        self._logger.debug(f\"Applied accuracy spec for range {range_for_calc}, value: {value_to_return}\")\n                    else:\n                         self._logger.debug(f\"Calculated uncertainty is zero. Returning float.\")\n                else:\n                    self._logger.warning(f\"No applicable accuracy specification found for function '{function.name}' at range {actual_instrument_range}. Returning float.\")\n            else:\n                self._logger.warning(f\"Could not find a matching range specification for function '{function.name}' at range {actual_instrument_range}. Returning float.\")\n\n        except Exception as e:\n            self._logger.error(f\"Error during uncertainty calculation: {e}. Returning float.\")\n    else:\n        self._logger.debug(f\"No measurement function specification in config for '{function.name}'. Returning float.\")\n\n    units_val, measurement_name_val = self._get_measurement_unit_and_type(function)\n\n    return MeasurementResult(\n        values=value_to_return,\n        instrument=self.config.model,\n        units=units_val,\n        measurement_type=measurement_name_val,\n    )\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter.set_measurement_function","title":"<code>set_measurement_function(function)</code>  <code>async</code>","text":"<p>Configures the primary measurement function of the DMM.</p> <p>This method sets the DMM to measure a specific quantity, such as DC Voltage, AC Current, or Resistance.</p> PARAMETER DESCRIPTION <code>function</code> <p>The desired measurement function, as defined by the       <code>DMMFunction</code> enum.</p> <p> TYPE: <code>DMMFunction</code> </p> Source code in <code>pytestlab/instruments/Multimeter.py</code> <pre><code>async def set_measurement_function(self, function: DMMFunction) -&gt; None:\n    \"\"\"Configures the primary measurement function of the DMM.\n\n    This method sets the DMM to measure a specific quantity, such as DC\n    Voltage, AC Current, or Resistance.\n\n    Args:\n        function: The desired measurement function, as defined by the\n                  `DMMFunction` enum.\n    \"\"\"\n    # Using the recommended SCPI command from the programming guide (page 145)\n    await self._send_command(f'SENSe:FUNCtion \"{function.value}\"')\n    self._logger.info(f\"Set measurement function to {function.name} ({function.value})\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Multimeter.Multimeter.set_trigger_source","title":"<code>set_trigger_source(source)</code>  <code>async</code>","text":"<p>Sets the trigger source for initiating a measurement.</p> <p>The trigger source determines what event will cause the DMM to start taking a reading. - \"IMM\": Immediate, the DMM triggers as soon as it's ready. - \"EXT\": External, a hardware signal on the rear panel triggers the DMM. - \"BUS\": A software command (<code>*TRG</code>) triggers the DMM.</p> PARAMETER DESCRIPTION <code>source</code> <p>The desired trigger source.</p> <p> TYPE: <code>Literal['IMM', 'EXT', 'BUS']</code> </p> Source code in <code>pytestlab/instruments/Multimeter.py</code> <pre><code>async def set_trigger_source(self, source: Literal[\"IMM\", \"EXT\", \"BUS\"]) -&gt; None:\n    \"\"\"Sets the trigger source for initiating a measurement.\n\n    The trigger source determines what event will cause the DMM to start\n    taking a reading.\n    - \"IMM\": Immediate, the DMM triggers as soon as it's ready.\n    - \"EXT\": External, a hardware signal on the rear panel triggers the DMM.\n    - \"BUS\": A software command (`*TRG`) triggers the DMM.\n\n    Args:\n        source: The desired trigger source.\n    \"\"\"\n    await self._send_command(f\"TRIG:SOUR {source.upper()}\")\n    self._logger.info(f\"Set trigger source to {source}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Multimeter.MultimeterConfigResult","title":"<code>MultimeterConfigResult(measurement_mode, range_value, resolution, units='')</code>  <code>dataclass</code>","text":"<p>Stores the current measurement configuration of the multimeter.</p> <p>This data class holds the state of the multimeter's configuration at a point in time, such as the measurement mode, range, and resolution. It is typically returned by methods that query the instrument's status.</p> ATTRIBUTE DESCRIPTION <code>measurement_mode</code> <p>The type of measurement being made (e.g., \"Voltage\").</p> <p> TYPE: <code>str</code> </p> <code>range_value</code> <p>The configured measurement range.</p> <p> TYPE: <code>float</code> </p> <code>resolution</code> <p>The configured resolution.</p> <p> TYPE: <code>str</code> </p> <code>units</code> <p>The units for the measurement range (e.g., \"V\", \"A\").</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/instruments/#pytestlab.instruments.Multimeter.MultimeterConfigResult-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.MultimeterConfigResult.measurement_mode","title":"<code>measurement_mode</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.MultimeterConfigResult.range_value","title":"<code>range_value</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.MultimeterConfigResult.resolution","title":"<code>resolution</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.MultimeterConfigResult.units","title":"<code>units = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.MultimeterConfigResult-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.Multimeter.MultimeterConfigResult.__str__","title":"<code>__str__()</code>","text":"Source code in <code>pytestlab/instruments/Multimeter.py</code> <pre><code>def __str__(self) -&gt; str:\n    return (f\"Measurement Mode: {self.measurement_mode}\\n\"\n            f\"Range: {self.range_value} {self.units}\\n\"\n            f\"Resolution: {self.resolution}\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.Multimeter-functions","title":"Functions","text":""},{"location":"api/instruments/#dc-active-load","title":"DC Active Load","text":""},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad","title":"<code>pytestlab.instruments.DCActiveLoad</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad-classes","title":"Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad","title":"<code>DCActiveLoad(config, backend, **kwargs)</code>","text":"<p>               Bases: <code>Instrument</code></p> <p>Drives a DC Electronic Load instrument, such as the Keysight EL30000 series.</p> <p>This class provides a driver for controlling a DC Active Load, enabling programmatic control over its operating modes and settings. It is designed to work with SCPI-compliant instruments and leverages a detailed Pydantic configuration model to provide uncertainty-aware measurements and feature-rich control.</p> <p>The driver supports the following primary operations: - Setting the operating mode (Constant Current, Voltage, Power, Resistance). - Programming the load value for the current mode. - Enabling or disabling the load's input. - Measuring voltage, current, and power with uncertainty. - Configuring and controlling transient and battery test modes.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>def __init__(self, config: DCActiveLoadConfig, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None:\n    super().__init__(config, backend, **kwargs)\n    self.current_mode = None\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.config","title":"<code>config</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.current_mode","title":"<code>current_mode = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.configure_transient_mode","title":"<code>configure_transient_mode(mode, channel=1)</code>  <code>async</code>","text":"<p>Sets the operating mode of the transient generator.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def configure_transient_mode(self, mode: Literal['CONTinuous', 'PULSe', 'TOGGle', 'LIST'], channel: int = 1) -&gt; None:\n    \"\"\"Sets the operating mode of the transient generator.\"\"\"\n    await self._send_command(f\"TRANsient:MODE {mode.upper()}, (@{channel})\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.enable_battery_test","title":"<code>enable_battery_test(state, channel=1)</code>  <code>async</code>","text":"<p>Enables or disables the battery test operation.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def enable_battery_test(self, state: bool, channel: int = 1) -&gt; None:\n    \"\"\"Enables or disables the battery test operation.\"\"\"\n    await self._send_command(f\"BATTery:ENABle {'ON' if state else 'OFF'}, (@{channel})\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.enable_input","title":"<code>enable_input(state, channel=1)</code>  <code>async</code>","text":"<p>Enables or disables the load's input.</p> PARAMETER DESCRIPTION <code>state</code> <p>True to enable the input, False to disable.</p> <p> TYPE: <code>bool</code> </p> <code>channel</code> <p>The channel to control (default is 1).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def enable_input(self, state: bool, channel: int = 1) -&gt; None:\n    \"\"\"Enables or disables the load's input.\n\n    Args:\n        state: True to enable the input, False to disable.\n        channel: The channel to control (default is 1).\n    \"\"\"\n    await self._send_command(f\"INPut:STATe {'ON' if state else 'OFF'}, (@{channel})\")\n    self._log(f\"Input on channel {channel} turned {'ON' if state else 'OFF'}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.fetch_datalogger_data","title":"<code>fetch_datalogger_data(num_points, channel=1)</code>  <code>async</code>","text":"<p>Fetches the specified number of logged data points.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def fetch_datalogger_data(self, num_points: int, channel: int = 1) -&gt; List[float]:\n    \"\"\"Fetches the specified number of logged data points.\"\"\"\n    response = await self._query(f\"FETCh:SCALar:DLOG? {num_points}, (@{channel})\")\n    return [float(x) for x in response.split(',')]\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.fetch_scope_data","title":"<code>fetch_scope_data(measurement, channel=1)</code>  <code>async</code>","text":"<p>Fetches the captured waveform (scope) data as a NumPy array.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def fetch_scope_data(self, measurement: Literal[\"current\", \"voltage\", \"power\"], channel: int = 1) -&gt; np.ndarray:\n    \"\"\"Fetches the captured waveform (scope) data as a NumPy array.\"\"\"\n    scpi_map = {\"current\": \"CURRent\", \"voltage\": \"VOLTage\", \"power\": \"POWer\"}\n    raw_data = await self._query_raw(f\"FETCh:ARRay:{scpi_map[measurement]}? (@{channel})\")\n    # Assumes the backend handles binary block data parsing; if not, call self._read_to_np\n    return np.frombuffer(raw_data, dtype=np.float32) # Assuming float data\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.from_config","title":"<code>from_config(config, debug_mode=False, simulate=False)</code>  <code>classmethod</code>","text":"<p>Creates a DCActiveLoad instance from a configuration.</p> <p>This factory method allows for the creation of a DCActiveLoad driver from either a raw dictionary or a <code>DCActiveLoadConfig</code> object. It simplifies the instantiation process by handling the configuration object creation internally.</p> PARAMETER DESCRIPTION <code>config</code> <p>A dictionary or a <code>DCActiveLoadConfig</code> object containing the     instrument's settings.</p> <p> TYPE: <code>Union[Dict[str, Any], DCActiveLoadConfig]</code> </p> <code>debug_mode</code> <p>If True, enables detailed logging for debugging purposes.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>simulate</code> <p>If True, initializes the instrument in simulation mode.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>DCActiveLoad</code> <p>An initialized DCActiveLoad object.</p> RAISES DESCRIPTION <code>InstrumentConfigurationError</code> <p>If the provided config is not a dict or                           a <code>DCActiveLoadConfig</code> instance.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>@classmethod\ndef from_config(\n    cls: Type[DCActiveLoad],\n    config: Union[Dict[str, Any], DCActiveLoadConfig],\n    debug_mode: bool = False, simulate: bool = False\n) -&gt; DCActiveLoad:\n    \"\"\"Creates a DCActiveLoad instance from a configuration.\n\n    This factory method allows for the creation of a DCActiveLoad driver from\n    either a raw dictionary or a `DCActiveLoadConfig` object. It simplifies\n    the instantiation process by handling the configuration object creation\n    internally.\n\n    Args:\n        config: A dictionary or a `DCActiveLoadConfig` object containing the\n                instrument's settings.\n        debug_mode: If True, enables detailed logging for debugging purposes.\n        simulate: If True, initializes the instrument in simulation mode.\n\n    Returns:\n        An initialized DCActiveLoad object.\n\n    Raises:\n        InstrumentConfigurationError: If the provided config is not a dict or\n                                      a `DCActiveLoadConfig` instance.\n    \"\"\"\n    conf_obj: DCActiveLoadConfig\n    if isinstance(config, dict):\n        conf_obj = DCActiveLoadConfig(**config)\n    elif isinstance(config, DCActiveLoadConfig):\n        conf_obj = config\n    else:\n        raise InstrumentConfigurationError(\n            \"DCActiveLoad\", \"Configuration must be a dict or DCActiveLoadConfig instance.\"\n        )\n    return cls(config=conf_obj, debug_mode=debug_mode, simulate=simulate)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.get_battery_test_measurement","title":"<code>get_battery_test_measurement(metric, channel=1)</code>  <code>async</code>","text":"<p>Queries a measurement from the ongoing battery test.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def get_battery_test_measurement(self, metric: Literal[\"capacity\", \"power\", \"time\"], channel: int = 1) -&gt; float:\n    \"\"\"Queries a measurement from the ongoing battery test.\"\"\"\n    scpi_map = {\"capacity\": \"CAPacity\", \"power\": \"POWer\", \"time\": \"TIMe\"}\n    response = await self._query(f\"BATTery:MEASure:{scpi_map[metric]}? (@{channel})\")\n    return float(response)\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.is_input_enabled","title":"<code>is_input_enabled(channel=1)</code>  <code>async</code>","text":"<p>Queries the state of the load's input.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the input is enabled, False otherwise.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def is_input_enabled(self, channel: int = 1) -&gt; bool:\n    \"\"\"Queries the state of the load's input.\n\n    Returns:\n        True if the input is enabled, False otherwise.\n    \"\"\"\n    response = await self._query(f\"INPut:STATe? (@{channel})\")\n    return response.strip() == '1'\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.measure_current","title":"<code>measure_current()</code>  <code>async</code>","text":"<p>Measures the sinking current, including uncertainty if available.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def measure_current(self) -&gt; MeasurementResult:\n    \"\"\"Measures the sinking current, including uncertainty if available.\"\"\"\n    return await self._measure_with_uncertainty(\"current\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.measure_power","title":"<code>measure_power()</code>  <code>async</code>","text":"<p>Measures the power being dissipated, including uncertainty if available.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def measure_power(self) -&gt; MeasurementResult:\n    \"\"\"Measures the power being dissipated, including uncertainty if available.\"\"\"\n    return await self._measure_with_uncertainty(\"power\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.measure_voltage","title":"<code>measure_voltage()</code>  <code>async</code>","text":"<p>Measures the voltage across the load, including uncertainty if available.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def measure_voltage(self) -&gt; MeasurementResult:\n    \"\"\"Measures the voltage across the load, including uncertainty if available.\"\"\"\n    return await self._measure_with_uncertainty(\"voltage\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_battery_cutoff_capacity","title":"<code>set_battery_cutoff_capacity(capacity, state=True, channel=1)</code>  <code>async</code>","text":"<p>Configures the capacity (Ah) cutoff condition for the battery test.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def set_battery_cutoff_capacity(self, capacity: float, state: bool = True, channel: int = 1) -&gt; None:\n    \"\"\"Configures the capacity (Ah) cutoff condition for the battery test.\"\"\"\n    await self._send_command(f\"BATTery:CUTOff:CAPacity:STATe {'ON' if state else 'OFF'}, (@{channel})\")\n    if state:\n        await self._send_command(f\"BATTery:CUTOff:CAPacity {capacity}, (@{channel})\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_battery_cutoff_timer","title":"<code>set_battery_cutoff_timer(time_s, state=True, channel=1)</code>  <code>async</code>","text":"<p>Configures the timer (seconds) cutoff condition for the battery test.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def set_battery_cutoff_timer(self, time_s: float, state: bool = True, channel: int = 1) -&gt; None:\n    \"\"\"Configures the timer (seconds) cutoff condition for the battery test.\"\"\"\n    await self._send_command(f\"BATTery:CUTOff:TIMer:STATe {'ON' if state else 'OFF'}, (@{channel})\")\n    if state:\n        await self._send_command(f\"BATTery:CUTOff:TIMer {time_s}, (@{channel})\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_battery_cutoff_voltage","title":"<code>set_battery_cutoff_voltage(voltage, state=True, channel=1)</code>  <code>async</code>","text":"<p>Configures the voltage cutoff condition for the battery test.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def set_battery_cutoff_voltage(self, voltage: float, state: bool = True, channel: int = 1) -&gt; None:\n    \"\"\"Configures the voltage cutoff condition for the battery test.\"\"\"\n    await self._send_command(f\"BATTery:CUTOff:VOLTage:STATe {'ON' if state else 'OFF'}, (@{channel})\")\n    if state:\n        await self._send_command(f\"BATTery:CUTOff:VOLTage {voltage}, (@{channel})\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_load","title":"<code>set_load(value)</code>  <code>async</code>","text":"<p>Programs the load's setpoint for the current operating mode.</p> <p>This method sets the target value that the load will maintain. The unit of the <code>value</code> argument depends on the currently active mode: - \"CC\" mode: <code>value</code> is in Amperes (A). - \"CV\" mode: <code>value</code> is in Volts (V). - \"CP\" mode: <code>value</code> is in Watts (W). - \"CR\" mode: <code>value</code> is in Ohms (\u03a9).</p> PARAMETER DESCRIPTION <code>value</code> <p>The target value for the load.</p> <p> TYPE: <code>float</code> </p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If the operating mode has not been set first                       by calling <code>set_mode()</code>.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def set_load(self, value: float) -&gt; None:\n    \"\"\"Programs the load's setpoint for the current operating mode.\n\n    This method sets the target value that the load will maintain. The unit\n    of the `value` argument depends on the currently active mode:\n    - \"CC\" mode: `value` is in Amperes (A).\n    - \"CV\" mode: `value` is in Volts (V).\n    - \"CP\" mode: `value` is in Watts (W).\n    - \"CR\" mode: `value` is in Ohms (\u03a9).\n\n    Args:\n        value: The target value for the load.\n\n    Raises:\n        InstrumentParameterError: If the operating mode has not been set first\n                                  by calling `set_mode()`.\n    \"\"\"\n    if self.current_mode is None:\n        raise InstrumentParameterError(\"Load mode has not been set. Call set_mode() first.\")\n\n    command_map = {\"CC\": \"CURRent\", \"CV\": \"VOLTage\", \"CP\": \"POWer\", \"CR\": \"RESistance\"}\n    scpi_param = command_map.get(self.current_mode)\n\n    if scpi_param:\n        await self._send_command(f\"{scpi_param}:LEVel:IMMediate:AMPLitude {value}\")\n        self._log(f\"Load value set to {value} in mode {self.current_mode}.\")\n    else:\n        raise InstrumentParameterError(f\"Internal error: Unknown current_mode '{self.current_mode}'.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_mode","title":"<code>set_mode(mode)</code>  <code>async</code>","text":"<p>Sets the operating mode of the electronic load.</p> <p>This method configures the load to operate in one of the supported modes. The mode determines what physical quantity the load will attempt to keep constant.</p> <p>The supported modes are: - \"CC\": Constant Current - \"CV\": Constant Voltage - \"CP\": Constant Power - \"CR\": Constant Resistance</p> PARAMETER DESCRIPTION <code>mode</code> <p>The desired operating mode. The input is case-insensitive.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>InstrumentParameterError</code> <p>If the specified mode is not supported.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def set_mode(self, mode: str) -&gt; None:\n    \"\"\"Sets the operating mode of the electronic load.\n\n    This method configures the load to operate in one of the supported modes.\n    The mode determines what physical quantity the load will attempt to keep\n    constant.\n\n    The supported modes are:\n    - \"CC\": Constant Current\n    - \"CV\": Constant Voltage\n    - \"CP\": Constant Power\n    - \"CR\": Constant Resistance\n\n    Args:\n        mode: The desired operating mode. The input is case-insensitive.\n\n    Raises:\n        InstrumentParameterError: If the specified mode is not supported.\n    \"\"\"\n    mode_upper = mode.upper()\n    mode_map: Dict[str, str] = {\n        \"CC\": \"CURR\",\n        \"CV\": \"VOLTage\",\n        \"CP\": \"POWer\",\n        \"CR\": \"RESistance\"\n    }\n    if mode_upper not in mode_map:\n        raise InstrumentParameterError(\n            parameter=\"mode\", value=mode, valid_range=list(mode_map.keys()),\n            message=f\"Unsupported mode '{mode}'. Valid modes are: {', '.join(mode_map.keys())}.\"\n        )\n    await self._send_command(f\"FUNC {mode_map[mode_upper]}\")\n    self.current_mode = mode_upper\n    self._log(f\"Operating mode set to {mode_upper}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_range","title":"<code>set_range(value, channel=1)</code>  <code>async</code>","text":"<p>Sets the operating range for the current mode.</p> PARAMETER DESCRIPTION <code>value</code> <p>The maximum expected value to set the range. Can also be \"MIN\" or \"MAX\".</p> <p> TYPE: <code>Union[float, str]</code> </p> <code>channel</code> <p>The channel to configure (default is 1).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def set_range(self, value: Union[float, str], channel: int = 1) -&gt; None:\n    \"\"\"Sets the operating range for the current mode.\n\n    Args:\n        value: The maximum expected value to set the range. Can also be \"MIN\" or \"MAX\".\n        channel: The channel to configure (default is 1).\n    \"\"\"\n    if self.current_mode is None:\n        raise InstrumentParameterError(\"Mode must be set before setting range.\")\n    command_map = {\"CC\": \"CURRent\", \"CV\": \"VOLTage\", \"CP\": \"POWer\", \"CR\": \"RESistance\"}\n    scpi_param = command_map.get(self.current_mode)\n    await self._send_command(f\"{scpi_param}:RANGe {value}, (@{channel})\")\n    self._log(f\"Range for mode {self.current_mode} on channel {channel} set for value {value}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_slew_rate","title":"<code>set_slew_rate(rate, channel=1)</code>  <code>async</code>","text":"<p>Sets the slew rate for the current operating mode.</p> PARAMETER DESCRIPTION <code>rate</code> <p>The desired slew rate. Units depend on the mode (A/s, V/s, etc.).   Can also be \"MIN\", \"MAX\", or \"INF\".</p> <p> TYPE: <code>Union[float, str]</code> </p> <code>channel</code> <p>The channel to configure (default is 1).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def set_slew_rate(self, rate: Union[float, str], channel: int = 1) -&gt; None:\n    \"\"\"Sets the slew rate for the current operating mode.\n\n    Args:\n        rate: The desired slew rate. Units depend on the mode (A/s, V/s, etc.).\n              Can also be \"MIN\", \"MAX\", or \"INF\".\n        channel: The channel to configure (default is 1).\n    \"\"\"\n    if self.current_mode is None:\n        raise InstrumentParameterError(\"Mode must be set before setting slew rate.\")\n\n    command_map = {\"CC\": \"CURRent\", \"CV\": \"VOLTage\", \"CP\": \"POWer\", \"CR\": \"RESistance\"}\n    scpi_param = command_map.get(self.current_mode)\n    await self._send_command(f\"{scpi_param}:SLEW {rate}, (@{channel})\")\n    self._log(f\"Slew rate for mode {self.current_mode} on channel {channel} set to {rate}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_transient_level","title":"<code>set_transient_level(value, channel=1)</code>  <code>async</code>","text":"<p>Sets the secondary (transient) level for the current operating mode.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def set_transient_level(self, value: float, channel: int = 1) -&gt; None:\n    \"\"\"Sets the secondary (transient) level for the current operating mode.\"\"\"\n    if self.current_mode is None:\n        raise InstrumentParameterError(\"Mode must be set before setting transient level.\")\n    command_map = {\"CC\": \"CURRent\", \"CV\": \"VOLTage\", \"CP\": \"POWer\", \"CR\": \"RESistance\"}\n    scpi_param = command_map.get(self.current_mode)\n    await self._send_command(f\"{scpi_param}:TLEVel {value}, (@{channel})\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.short_input","title":"<code>short_input(state, channel=1)</code>  <code>async</code>","text":"<p>Enables or disables a short circuit on the input.</p> PARAMETER DESCRIPTION <code>state</code> <p>True to enable the short, False to disable.</p> <p> TYPE: <code>bool</code> </p> <code>channel</code> <p>The channel to control (default is 1).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def short_input(self, state: bool, channel: int = 1) -&gt; None:\n    \"\"\"Enables or disables a short circuit on the input.\n\n    Args:\n        state: True to enable the short, False to disable.\n        channel: The channel to control (default is 1).\n    \"\"\"\n    await self._send_command(f\"INPut:SHORt:STATe {'ON' if state else 'OFF'}, (@{channel})\")\n    self._log(f\"Input short on channel {channel} turned {'ON' if state else 'OFF'}.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.start_transient","title":"<code>start_transient(continuous=False, channel=1)</code>  <code>async</code>","text":"<p>Initiates the transient trigger system.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def start_transient(self, continuous: bool = False, channel: int = 1) -&gt; None:\n    \"\"\"Initiates the transient trigger system.\"\"\"\n    await self._send_command(f\"INITiate:CONTinuous:TRANsient {'ON' if continuous else 'OFF'}, (@{channel})\")\n    if not continuous:\n        await self._send_command(f\"INITiate:TRANsient (@{channel})\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.DCActiveLoad.stop_transient","title":"<code>stop_transient(channel=1)</code>  <code>async</code>","text":"<p>Aborts any pending or in-progress transient operations.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def stop_transient(self, channel: int = 1) -&gt; None:\n    \"\"\"Aborts any pending or in-progress transient operations.\"\"\"\n    await self._send_command(f\"ABORt:TRANsient (@{channel})\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.DCActiveLoad.health_check","title":"<code>health_check(self)</code>  <code>async</code>","text":"<p>Performs a health check on the DC Electronic Load.</p> Source code in <code>pytestlab/instruments/DCActiveLoad.py</code> <pre><code>async def health_check(self) -&gt; HealthReport:\n        \"\"\"Performs a health check on the DC Electronic Load.\"\"\"\n        report = HealthReport()\n        try:\n            report.instrument_idn = await self.id()\n            errors = await self.get_all_errors()\n            if errors:\n                report.status = HealthStatus.WARNING\n                report.warnings.extend([f\"Stored Error: {code} - {msg}\" for code, msg in errors])\n            else:\n                report.status = HealthStatus.OK\n        except Exception as e:\n            report.status = HealthStatus.ERROR\n            report.errors.append(f\"Health check failed: {e}\")\n        return report\n</code></pre>"},{"location":"api/instruments/#spectrum-analyzer","title":"Spectrum Analyzer","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser","title":"<code>pytestlab.instruments.SpectrumAnalyser</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser-classes","title":"Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult","title":"<code>PlaceholderMeasurementResult(x, y, x_label='Frequency (Hz)', y_label='Amplitude (dBm)')</code>","text":"Source code in <code>pytestlab/instruments/SpectrumAnalyser.py</code> <pre><code>def __init__(self, x: List[float], y: List[float], x_label: str = \"Frequency (Hz)\", y_label: str = \"Amplitude (dBm)\"):\n    self.x = x\n    self.y = y\n    self.x_label = x_label\n    self.y_label = y_label\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult.x","title":"<code>x = x</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult.x_label","title":"<code>x_label = x_label</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult.y","title":"<code>y = y</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult.y_label","title":"<code>y_label = y_label</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.SpectrumAnalyser","title":"<code>SpectrumAnalyser(config, backend, **kwargs)</code>","text":"<p>               Bases: <code>Instrument[SpectrumAnalyzerConfig]</code></p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO\n    \"\"\"\n    Initialize the Instrument class.\n\n    Args:\n        config (ConfigType): Configuration for the instrument.\n        backend (AsyncInstrumentIO): The communication backend instance.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    if not isinstance(config, InstrumentConfig): # Check against the bound base\n        raise InstrumentConfigurationError(\n            self.__class__.__name__,\n            f\"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.\",\n        )\n\n    self.config = config\n    self._backend = backend # This will be an AsyncInstrumentIO instance\n    self._command_log = []\n\n    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__\n    self._logger = get_logger(logger_name)\n\n    self._logger.info(f\"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.SpectrumAnalyser-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.SpectrumAnalyser.configure_measurement","title":"<code>configure_measurement(center_freq=None, span=None, rbw=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/SpectrumAnalyser.py</code> <pre><code>async def configure_measurement(\n    self, \n    center_freq: Optional[float] = None, \n    span: Optional[float] = None, \n    rbw: Optional[float] = None\n) -&gt; None:\n    if center_freq is not None:\n        await self._send_command(f\"FREQ:CENT {center_freq}\") # Use SCPI_MAP later\n        self.config.frequency_center = center_freq # Update config\n    if span is not None:\n        await self._send_command(f\"FREQ:SPAN {span}\")\n        self.config.frequency_span = span # Update config\n    if rbw is not None:\n        await self._send_command(f\"BAND {rbw}\") # RBW command\n        self.config.resolution_bandwidth = rbw # Update config\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.SpectrumAnalyser.SpectrumAnalyser.get_trace","title":"<code>get_trace(channel=1)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/SpectrumAnalyser.py</code> <pre><code>async def get_trace(self, channel: int = 1) -&gt; PlaceholderMeasurementResult: # Use actual MeasurementResult later\n    # Example: Query trace data, parse it (often CSV or binary)\n    # raw_data_str = await self._query(f\"TRAC:DATA? TRACE{channel}\") # Use SCPI_MAP\n    # For simulation, SimBackend needs to be taught to respond to this\n    # For now, return dummy data\n    # freqs = [1e9, 2e9, 3e9] # Dummy frequencies\n    # amps = [-20, -30, -25]  # Dummy amplitudes\n    # return PlaceholderMeasurementResult(x=freqs, y=amps)\n    self._logger.warning(\"get_trace for SpectrumAnalyser is a placeholder and returns dummy data.\")\n    # Simulating a basic trace for now\n    sim_freqs = [self.config.frequency_center or 1e9 - (self.config.frequency_span or 100e6)/2 + i * ((self.config.frequency_span or 100e6)/10) for i in range(11)]\n    sim_amps = [-20.0 - i*2 for i in range(11)] # Dummy amplitudes\n    return PlaceholderMeasurementResult(x=sim_freqs, y=sim_amps)\n</code></pre>"},{"location":"api/instruments/#vector-network-analyzer-vna","title":"Vector Network Analyzer (VNA)","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser","title":"<code>pytestlab.instruments.VectorNetworkAnalyser</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser-classes","title":"Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.SParameterData","title":"<code>SParameterData(frequencies, s_params, param_names)</code>","text":"Source code in <code>pytestlab/instruments/VectorNetworkAnalyser.py</code> <pre><code>def __init__(self, frequencies: List[float], s_params: List[List[complex]], param_names: List[str]):\n    self.frequencies = frequencies # List of frequencies\n    self.s_params = s_params       # List of lists, each inner list contains complex S-param values for a given S-parameter type\n    self.param_names = param_names # List of S-parameter names, e.g., [\"S11\", \"S21\"]\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.SParameterData-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.SParameterData.frequencies","title":"<code>frequencies = frequencies</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.SParameterData.param_names","title":"<code>param_names = param_names</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.SParameterData.s_params","title":"<code>s_params = s_params</code>  <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.SParameterData-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser","title":"<code>VectorNetworkAnalyser(config, backend, **kwargs)</code>","text":"<p>               Bases: <code>Instrument[VNAConfig]</code></p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO\n    \"\"\"\n    Initialize the Instrument class.\n\n    Args:\n        config (ConfigType): Configuration for the instrument.\n        backend (AsyncInstrumentIO): The communication backend instance.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    if not isinstance(config, InstrumentConfig): # Check against the bound base\n        raise InstrumentConfigurationError(\n            self.__class__.__name__,\n            f\"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.\",\n        )\n\n    self.config = config\n    self._backend = backend # This will be an AsyncInstrumentIO instance\n    self._command_log = []\n\n    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__\n    self._logger = get_logger(logger_name)\n\n    self._logger.info(f\"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser-attributes","title":"Attributes","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser.model_config","title":"<code>model_config = {'arbitrary_types_allowed': True}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser.configure_s_parameter_sweep","title":"<code>configure_s_parameter_sweep(s_params=None, start_freq=None, stop_freq=None, num_points=None, if_bandwidth=None, power_level=None)</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/VectorNetworkAnalyser.py</code> <pre><code>async def configure_s_parameter_sweep(\n    self, \n    s_params: Optional[List[str]] = None, # e.g. [\"S11\", \"S21\"]\n    start_freq: Optional[float] = None, \n    stop_freq: Optional[float] = None, \n    num_points: Optional[int] = None,\n    if_bandwidth: Optional[float] = None,\n    power_level: Optional[float] = None\n) -&gt; None:\n    if s_params is not None:\n        # SCPI command to select S-parameters might be like: CALC:PAR:DEF \"S11\"\n        # This is highly instrument specific. For now, just update config.\n        self.config.s_parameters = s_params\n        self._logger.info(f\"VNA S-parameters set to: {s_params}\")\n    if start_freq is not None:\n        await self._send_command(f\"SENS:FREQ:STAR {start_freq}\") # Example SCPI\n        self.config.start_frequency = start_freq\n    if stop_freq is not None:\n        await self._send_command(f\"SENS:FREQ:STOP {stop_freq}\") # Example SCPI\n        self.config.stop_frequency = stop_freq\n    if num_points is not None:\n        await self._send_command(f\"SENS:SWE:POIN {num_points}\") # Example SCPI\n        self.config.num_points = num_points\n    if if_bandwidth is not None:\n        await self._send_command(f\"SENS:BWID {if_bandwidth}\") # Example SCPI for IF bandwidth\n        self.config.if_bandwidth = if_bandwidth\n    if power_level is not None:\n        await self._send_command(f\"SOUR:POW {power_level}\") # Example SCPI for power\n        self.config.power_level = power_level\n    self._logger.info(\"VNA measurement configured (simulated).\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser.get_s_parameter_data","title":"<code>get_s_parameter_data()</code>  <code>async</code>","text":"Source code in <code>pytestlab/instruments/VectorNetworkAnalyser.py</code> <pre><code>async def get_s_parameter_data(self) -&gt; SParameterData:\n    # Example: Query S-parameter data. This is often complex, involving selecting\n    # the S-parameter, then querying data (e.g., in Real, Imaginary or LogMag, Phase format).\n    # raw_data_str = await self._query(f\"CALC:DATA? SDAT\") # Example SCPI for S-parameter data\n    # For simulation, SimBackend needs to be taught to respond.\n    self._logger.warning(\"get_s_parameter_data for VNA is a placeholder and returns dummy data.\")\n\n    num_points = self.config.num_points or 101\n    start_f = self.config.start_frequency or 1e9\n    stop_f = self.config.stop_frequency or 2e9\n\n    frequencies = [start_f + i * (stop_f - start_f) / (num_points -1 if num_points &gt; 1 else 1) for i in range(num_points)]\n\n    s_params_to_measure = self.config.s_parameters or [\"S11\"]\n    sim_s_params_data: List[List[complex]] = []\n\n    for _ in s_params_to_measure:\n        # Dummy data: e.g., S11 a simple reflection, S21 a simple transmission\n        param_data = []\n        for i in range(num_points):\n            # Create some varying complex numbers\n            real_part = -0.1 * i / num_points \n            imag_part = -0.05 * (1 - i / num_points)\n            param_data.append(complex(real_part, imag_part))\n        sim_s_params_data.append(param_data)\n\n    return SParameterData(frequencies=frequencies, s_params=sim_s_params_data, param_names=s_params_to_measure)\n</code></pre>"},{"location":"api/instruments/#power-meter","title":"Power Meter","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerMeter","title":"<code>pytestlab.instruments.PowerMeter</code>","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerMeter-classes","title":"Classes","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerMeter.PowerMeter","title":"<code>PowerMeter(config, backend, **kwargs)</code>","text":"<p>               Bases: <code>Instrument[PowerMeterConfig]</code></p> <p>Drives a Power Meter instrument for power measurements.</p> <p>This class provides a high-level interface for controlling a power meter, building upon the base <code>Instrument</code> class. It includes methods for configuring the power sensor and reading power values.</p> Source code in <code>pytestlab/instruments/instrument.py</code> <pre><code>def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO\n    \"\"\"\n    Initialize the Instrument class.\n\n    Args:\n        config (ConfigType): Configuration for the instrument.\n        backend (AsyncInstrumentIO): The communication backend instance.\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    if not isinstance(config, InstrumentConfig): # Check against the bound base\n        raise InstrumentConfigurationError(\n            self.__class__.__name__,\n            f\"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.\",\n        )\n\n    self.config = config\n    self._backend = backend # This will be an AsyncInstrumentIO instance\n    self._command_log = []\n\n    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__\n    self._logger = get_logger(logger_name)\n\n    self._logger.info(f\"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerMeter.PowerMeter-functions","title":"Functions","text":""},{"location":"api/instruments/#pytestlab.instruments.PowerMeter.PowerMeter.configure_sensor","title":"<code>configure_sensor(channel=1, freq=None, averaging_count=None, units=None)</code>  <code>async</code>","text":"<p>Configures the settings for a specific power sensor channel.</p> <p>This method allows setting the frequency compensation, averaging count, and power units for the measurement.</p> PARAMETER DESCRIPTION <code>channel</code> <p>The sensor channel number to configure (default is 1).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>freq</code> <p>The frequency compensation value in Hz.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>averaging_count</code> <p>The number of measurements to average.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>units</code> <p>The desired power units (e.g., \"dBm\", \"W\").</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>pytestlab/instruments/PowerMeter.py</code> <pre><code>async def configure_sensor(\n    self,\n    channel: int = 1,\n    freq: Optional[float] = None,\n    averaging_count: Optional[int] = None,\n    units: Optional[str] = None\n) -&gt; None:\n    \"\"\"Configures the settings for a specific power sensor channel.\n\n    This method allows setting the frequency compensation, averaging count,\n    and power units for the measurement.\n\n    Args:\n        channel: The sensor channel number to configure (default is 1).\n        freq: The frequency compensation value in Hz.\n        averaging_count: The number of measurements to average.\n        units: The desired power units (e.g., \"dBm\", \"W\").\n    \"\"\"\n    # The specific SCPI commands can vary between power meter models.\n    # The following are common examples.\n\n    # Set the frequency compensation for the sensor.\n    if freq is not None:\n        await self._send_command(f\"SENS{channel}:FREQ {freq}\")\n        self.config.frequency_compensation_value = freq  # Update local config state\n\n    # Set the number of readings to average.\n    if averaging_count is not None:\n        await self._send_command(f\"SENS{channel}:AVER:COUN {averaging_count}\")\n        self.config.averaging_count = averaging_count  # Update local config state\n\n    # Set the units for the power measurement.\n    if units is not None:\n        # Validate that the requested units are supported by the config model.\n        if units in PowerMeterConfig.model_fields['power_units'].annotation.__args__:\n            await self._send_command(f\"UNIT:POW {units.upper()}\")\n            self.config.power_units = units  # type: ignore\n        else:\n            self._logger.warning(f\"Invalid power units '{units}' specified. Using config default '{self.config.power_units}'.\")\n\n    self._logger.info(f\"Power meter sensor channel {channel} configured.\")\n</code></pre>"},{"location":"api/instruments/#pytestlab.instruments.PowerMeter.PowerMeter.read_power","title":"<code>read_power(channel=1)</code>  <code>async</code>","text":"<p>Reads the power from a specified sensor channel.</p> <p>This method queries the instrument for a power reading. Note that this is a placeholder implementation and currently returns simulated data.</p> PARAMETER DESCRIPTION <code>channel</code> <p>The sensor channel number to read from (default is 1).</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The measured power as a float. The units depend on the current</p> <code>float</code> <p>instrument configuration.</p> Source code in <code>pytestlab/instruments/PowerMeter.py</code> <pre><code>async def read_power(self, channel: int = 1) -&gt; float:\n    \"\"\"Reads the power from a specified sensor channel.\n\n    This method queries the instrument for a power reading. Note that this\n    is a placeholder implementation and currently returns simulated data.\n\n    Args:\n        channel: The sensor channel number to read from (default is 1).\n\n    Returns:\n        The measured power as a float. The units depend on the current\n        instrument configuration.\n    \"\"\"\n    # In a real implementation, you would query the instrument.\n    # Example: raw_power_str = await self._query(f\"FETC{channel}?\")\n    # The SimBackend would need to be configured to provide realistic responses.\n    self._logger.warning(f\"read_power for PowerMeter channel {channel} is a placeholder and returns dummy data.\")\n\n    # Simulate a power reading based on the configured units.\n    sim_power = -10.0  # Default dummy power in dBm\n    if self.config.power_units == \"W\":\n        sim_power = 0.0001  # 100uW\n    elif self.config.power_units == \"mW\":\n        sim_power = 0.1  # 0.1mW\n    elif self.config.power_units == \"uW\":\n        sim_power = 100.0  # 100uW\n\n    # For more realistic simulations, a small random variation could be added.\n    # import random\n    # sim_power *= (1 + random.uniform(-0.01, 0.01))\n\n    return sim_power\n</code></pre>"},{"location":"api/instruments/#facade-pattern","title":"Facade Pattern","text":"<p>All instrument drivers expose \"facade\" objects for common operations, enabling a fluent, chainable API. For example, you can configure and enable a channel with:</p> <pre><code>await scope.channel(1).setup(scale=0.5, offset=0).enable()\n</code></pre> <p>See the 10-Minute Tour for practical examples.</p>"},{"location":"api/instruments/#simulation-support","title":"Simulation Support","text":"<p>All drivers support simulation via the <code>simulate=True</code> flag or by using a simulated backend. See the Simulation Guide for details.</p>"},{"location":"api/instruments/#extending-drivers","title":"Extending Drivers","text":"<p>To add support for a new instrument, create a profile YAML file and use <code>AutoInstrument.from_config()</code> or subclass <code>Instrument</code>. See Creating Profiles for guidance.</p>"},{"location":"api/measurements/","title":"Measurement Session","text":"<p>The <code>MeasurementSession</code> class in PyTestLab provides a high-level, context-managed interface for orchestrating complex measurement workflows. It is designed to coordinate multiple instruments, manage experiment metadata, and ensure reproducibility and traceability of your measurements.</p>"},{"location":"api/measurements/#overview","title":"Overview","text":"<p>A <code>MeasurementSession</code> encapsulates:</p> <ul> <li>The set of instruments involved in a measurement.</li> <li>Experiment metadata (operator, DUT, environmental conditions, etc.).</li> <li>The sequence of measurement steps and their results.</li> <li>Automatic logging and database integration.</li> </ul> <p>This abstraction is ideal for automating multi-instrument experiments, batch measurements, or compliance/audit scenarios.</p>"},{"location":"api/measurements/#api-reference","title":"API Reference","text":""},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession","title":"<code>pytestlab.measurements.MeasurementSession(name=None, description='', tz='UTC', *, bench=None)</code>","text":"<p>               Bases: <code>AbstractAsyncContextManager</code>, <code>AbstractContextManager</code></p> <p>Core builder \u2013 read the extensive doc-string in earlier assistant response for design details. Now supports asynchronous operations for sweeps.</p> Source code in <code>pytestlab/measurements/session.py</code> <pre><code>def __init__(\n    self,\n    name: Optional[str] = None,\n    description: str = \"\",\n    tz: str = \"UTC\",\n    *,\n    bench: Optional[Bench] = None,\n) -&gt; None:\n    self.name = name or \"Untitled\"\n    self.description = description\n    self.tz = tz\n    self.created_at = datetime.now().astimezone().isoformat()\n    self._parameters: Dict[str, _Parameter] = {}\n    self._instruments: Dict[str, _InstrumentRecord] = {}\n    self._meas_funcs: List[Tuple[str, T_MeasFunc]] = []\n    self._data_rows: List[Dict[str, Any]] = []\n    self._experiment: Optional[Experiment] = None\n    self._has_run = False\n    self._bench = bench\n\n    # Inherit experiment data from bench if available\n    if bench is not None and bench.experiment is not None:\n        # Assign bench experiment properties\n        self._experiment = bench.experiment\n        self.name = bench.experiment.name\n        self.description = bench.experiment.description\n\n    # Set up instruments\n    if self._bench:\n        # Print debug info\n        print(f\"DEBUG: Setting up {len(self._bench.instruments)} instruments from bench\")\n        for alias, inst in self._bench.instruments.items():\n            self._instruments[alias] = _InstrumentRecord(\n                alias=alias,\n                resource=f\"bench:{alias}\",\n                instance=inst,\n                auto_close=False,\n            )\n</code></pre>"},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession-attributes","title":"Attributes","text":""},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.created_at","title":"<code>created_at = datetime.now().astimezone().isoformat()</code>  <code>instance-attribute</code>","text":""},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.data","title":"<code>data</code>  <code>property</code>","text":""},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.description","title":"<code>description = description</code>  <code>instance-attribute</code>","text":""},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.name","title":"<code>name = name or 'Untitled'</code>  <code>instance-attribute</code>","text":""},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.tz","title":"<code>tz = tz</code>  <code>instance-attribute</code>","text":""},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession-functions","title":"Functions","text":""},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"Source code in <code>pytestlab/measurements/session.py</code> <pre><code>async def __aenter__(self) -&gt; \"MeasurementSession\":  # noqa: D401\n    return self\n</code></pre>"},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.__aexit__","title":"<code>__aexit__(exc_type, exc, tb)</code>  <code>async</code>","text":"Source code in <code>pytestlab/measurements/session.py</code> <pre><code>async def __aexit__(self, exc_type, exc, tb) -&gt; bool:  # noqa: D401\n    await self._disconnect_all_instruments()\n    return False\n</code></pre>"},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.__enter__","title":"<code>__enter__()</code>","text":"<p>Synchronous context manager entry.</p> Source code in <code>pytestlab/measurements/session.py</code> <pre><code>def __enter__(self) -&gt; \"MeasurementSession\":  # noqa: D401\n    \"\"\"Synchronous context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.__exit__","title":"<code>__exit__(exc_type, exc, tb)</code>","text":"<p>Synchronous context manager exit.</p> Source code in <code>pytestlab/measurements/session.py</code> <pre><code>def __exit__(self, exc_type, exc, tb) -&gt; bool:  # noqa: D401\n    \"\"\"Synchronous context manager exit.\"\"\"\n    # Use asyncio to run the async disconnect method synchronously\n    try:\n        loop = asyncio.get_event_loop()\n        if loop.is_running():\n            # Create a new loop if we're already in a running event loop\n            loop = asyncio.new_event_loop()\n            loop.run_until_complete(self._disconnect_all_instruments())\n            loop.close()\n        else:\n            loop.run_until_complete(self._disconnect_all_instruments())\n    except Exception:  # noqa: BLE001\n        pass  # Keep original error handling behavior\n    return False\n</code></pre>"},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.acquire","title":"<code>acquire(func=None, /, *, name=None)</code>","text":"Source code in <code>pytestlab/measurements/session.py</code> <pre><code>def acquire(self, func: T_MeasFunc | None = None, /, *, name: str | None = None):\n    if func is None:  # decorator usage\n        return lambda f: self.acquire(f, name=name)\n\n    reg_name = name or func.__name__\n    if any(n == reg_name for n, _ in self._meas_funcs):\n        raise ValueError(f\"Measurement '{reg_name}' already registered.\")\n    self._meas_funcs.append((reg_name, func))\n    return func\n</code></pre>"},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.instrument","title":"<code>instrument(alias, config_key, /, **kw)</code>  <code>async</code>","text":"Source code in <code>pytestlab/measurements/session.py</code> <pre><code>async def instrument(self, alias: str, config_key: str, /, **kw) -&gt; Any:\n    if alias in self._instruments:\n        record = self._instruments[alias]\n        if not record.resource.startswith(\"bench:\"):\n            raise ValueError(f\"Instrument alias '{alias}' already in use.\")\n        return record.instance\n    if self._bench:\n        raise ValueError(\n            f\"Instrument '{alias}' not found on the bench. \"\n            \"When using a bench, all instruments must be defined in the bench configuration.\"\n        )\n    inst = await AutoInstrument.from_config(config_key, **kw)\n    self._instruments[alias] = _InstrumentRecord(alias, config_key, inst)\n    return inst\n</code></pre>"},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.parameter","title":"<code>parameter(name, values, /, *, unit=None, notes='')</code>","text":"Source code in <code>pytestlab/measurements/session.py</code> <pre><code>def parameter(self, name: str, values: T_ParamIterable, /, *, unit: str | None = None, notes: str = \"\") -&gt; None:\n    if name in self._parameters:\n        raise ValueError(f\"Parameter '{name}' already exists.\")\n    if callable(values) and not isinstance(values, (list, tuple, np.ndarray)):\n        values = list(values())\n    else:\n        values = list(values)\n    self._parameters[name] = _Parameter(name, values, unit, notes)\n</code></pre>"},{"location":"api/measurements/#pytestlab.measurements.MeasurementSession.run","title":"<code>run(show_progress=True)</code>  <code>async</code>","text":"Source code in <code>pytestlab/measurements/session.py</code> <pre><code>async def run(self, show_progress: bool = True) -&gt; Experiment:\n    if not self._parameters:\n        raise RuntimeError(\"No parameters defined.\")\n    if not self._meas_funcs:\n        raise RuntimeError(\"No measurement functions registered.\")\n\n    names = [p.name for p in self._parameters.values()]\n    value_lists = [p.values for p in self._parameters.values()]\n    combinations = list(itertools.product(*value_lists))\n\n    self._data_rows = [{}] * len(combinations)  # pre-allocate\n    iterator = tqdm(enumerate(combinations), total=len(combinations), desc=\"Measurement sweep\", disable=not show_progress)\n\n    for idx, combo in iterator:\n        param_ctx = dict(zip(names, combo, strict=True))\n        row: Dict[str, Any] = {**param_ctx, \"timestamp\": time.time()}\n\n        for meas_name, func in self._meas_funcs:\n            sig = inspect.signature(func)\n            kwargs = {n: v for n, v in param_ctx.items() if n in sig.parameters}\n            for alias, inst_rec in self._instruments.items():\n                if alias in sig.parameters:\n                    kwargs[alias] = inst_rec.instance\n            if \"ctx\" in sig.parameters:\n                kwargs[\"ctx\"] = row\n            res = await func(**kwargs)\n            if not isinstance(res, Mapping):\n                raise TypeError(f\"Measurement '{meas_name}' returned {type(res)}, expected Mapping.\")\n            for key, val in res.items():\n                col = key if key not in row else f\"{meas_name}.{key}\"\n                row[col] = val\n\n        self._data_rows[idx] = row\n        # Yield control to the event loop periodically in long sweeps\n        await asyncio.sleep(0)\n\n\n    self._has_run = True\n    self._build_experiment()\n    if self._bench and self._bench.db:\n        await self._bench.save_experiment()\n    return self._experiment\n</code></pre>"},{"location":"api/measurements/#example-usage","title":"Example Usage","text":"<pre><code>import asyncio\nfrom pytestlab.measurements import MeasurementSession\nfrom pytestlab.instruments import AutoInstrument\n\nasync def main():\n    # Create instrument instances (simulated for this example)\n    dmm = await AutoInstrument.from_config(\"keysight/EDU34450A\", simulate=True)\n    psu = await AutoInstrument.from_config(\"keysight/EDU36311A\", simulate=True)\n    await dmm.connect_backend()\n    await psu.connect_backend()\n\n    # Start a measurement session\n    async with MeasurementSession(\n        instruments={\"dmm\": dmm, \"psu\": psu},\n        metadata={\"operator\": \"Alice\", \"experiment\": \"Power Supply Test\"}\n    ) as session:\n        # Configure instruments\n        await psu.channel(1).set(voltage=3.3, current_limit=0.5).on()\n        # Perform measurement\n        voltage = await dmm.measure_voltage_dc()\n        # Record result in the session\n        session.record(\"dmm_voltage\", voltage)\n\n        # ... additional steps ...\n\n    # Session automatically logs results and closes instruments\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/measurements/#key-features","title":"Key Features","text":"<ul> <li>Async Context Management: Ensures all resources are properly initialized and cleaned up.</li> <li>Metadata Tracking: Attach arbitrary metadata to each session for traceability.</li> <li>Result Recording: Store and retrieve results by key for later analysis or database storage.</li> <li>Integration: Works seamlessly with PyTestLab's database and experiment modules.</li> </ul> <p>For more advanced usage, see the Experiments &amp; Sweeps API and the 10-Minute Tour.</p>"},{"location":"profiles/creating/","title":"Creating Profiles","text":"<p>Instrument profiles are YAML files that define an instrument's capabilities and map them to SCPI commands. PyTestLab uses these profiles along with Pydantic models to provide a structured and validated way to control instruments.</p>"},{"location":"profiles/creating/#profile-structure","title":"Profile Structure","text":"<p>A profile YAML file has two main sections:</p> <ol> <li>Metadata: Fields like <code>manufacturer</code>, <code>model</code>, and <code>device_type</code>. The <code>device_type</code> is crucial as it links the YAML file to a specific Pydantic configuration model (e.g., <code>PowerSupplyConfig</code>).</li> <li>Configuration Data: Structured data that matches the fields in the corresponding Pydantic model. This includes channel definitions, supported modes, value ranges, and accuracy specifications.</li> </ol>"},{"location":"profiles/creating/#example-power-supply-profile","title":"Example: Power Supply Profile","text":"<p>This example shows a simplified profile for a power supply.</p> my_psu_profile.yaml<pre><code># Metadata\nmanufacturer: MyBrand\nmodel: PSU-101\ndevice_type: power_supply\n\n# Configuration Data (matches PowerSupplyConfig model)\ntotal_power: 100\n\nchannels:\n  - channel_id: 1\n    description: \"Main Output\"\n    voltage_range:\n      min_val: 0.0\n      max_val: 30.0\n    current_limit_range:\n      min_val: 0.0\n      max_val: 3.0\n</code></pre>"},{"location":"profiles/creating/#creating-a-new-profile","title":"Creating a New Profile","text":"<ol> <li>Create a YAML file: Start a new <code>.yaml</code> file for your instrument.</li> <li>Add Metadata: Fill in the <code>manufacturer</code>, <code>model</code>, and <code>device_type</code>. The <code>device_type</code> must match one of the defined Pydantic config models in <code>pytestlab.config</code>.</li> <li>Add Configuration Data: Refer to the corresponding Pydantic model in the Configuration API Reference and fill in the fields with the specifications from your instrument's datasheet.</li> <li>Save the Profile: Save the file in a known location. You can then load it directly by its path in <code>AutoInstrument.from_config()</code> or place it in <code>pytestlab/profiles/&lt;vendor&gt;/</code> to load it by key.</li> <li>Validate: Use the CLI to validate your new profile: <code>pytestlab profile validate path/to/your/profile.yaml</code>.</li> </ol> <p>For more complex instruments, you may need to define nested structures for triggers, channels, FFT, etc., as seen in the built-in profiles.</p>"},{"location":"profiles/creating/#tips","title":"Tips","text":"<ul> <li>Use the built-in profiles as templates: Browse the Profile Gallery to see real examples.</li> <li>Match the schema: The YAML structure must match the Pydantic model for your <code>device_type</code>. See the Configuration API Reference for details.</li> <li>Simulation logic: You can add a <code>simulation</code> section to provide deterministic responses for testing (see the Simulation Guide).</li> <li>Validation: Always validate your profile before use to catch schema errors early.</li> </ul> <p>For further details, see the API Reference and the Simulation Guide.</p>"},{"location":"profiles/gallery/","title":"Instrument Profile Gallery","text":"<p>This page lists all the instrument profiles available out-of-the-box with PyTestLab. These profiles live in the <code>pytestlab/profiles/</code> directory.</p> <p>You can use these profiles by their key (e.g., <code>\"keysight/DSOX1204G\"</code>) when creating an instrument.</p>"},{"location":"profiles/gallery/#keysight-34460a","title":"keysight 34460A","text":"<ul> <li>Device Type: <code>multimeter</code></li> <li>Profile: <code>34460A.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-34470a","title":"keysight 34470A","text":"<ul> <li>Device Type: <code>multimeter</code></li> <li>Profile: <code>34470A.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-dsox1202g","title":"Keysight DSOX1202G","text":"<ul> <li>Device Type: <code>oscilloscope</code></li> <li>Profile: <code>DSOX1202G.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-dsox1204g","title":"Keysight DSOX1204G","text":"<ul> <li>Device Type: <code>oscilloscope</code></li> <li>Profile: <code>DSOX1204G.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-dsox3054g","title":"keysight DSOX3054G","text":"<ul> <li>Device Type: <code>oscilloscope</code></li> <li>Profile: <code>DSOX3054G.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-e36313a","title":"keysight E36313A","text":"<ul> <li>Device Type: <code>power_supply</code></li> <li>Profile: <code>E36313A.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-e5071c","title":"Keysight E5071C","text":"<ul> <li>Device Type: <code>vna</code></li> <li>Profile: <code>E5071C_VNA.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-edu33212a","title":"Keysight EDU33212A","text":"<ul> <li>Device Type: <code>waveform_generator</code></li> <li>Profile: <code>EDU33212A.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-edu34450a","title":"Keysight EDU34450A","text":"<ul> <li>Device Type: <code>multimeter</code></li> <li>Profile: <code>EDU34450A.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-edu36311a","title":"Keysight EDU36311A","text":"<ul> <li>Device Type: <code>power_supply</code></li> <li>Profile: <code>EDU36311A.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-el33133a","title":"Keysight EL33133A","text":"<ul> <li>Device Type: <code>dc_active_load</code></li> <li>Profile: <code>EL33133A.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-msox2024a","title":"keysight MSOX2024A","text":"<ul> <li>Device Type: <code>oscilloscope</code></li> <li>Profile: <code>MSOX2024A.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-mxr404a","title":"Keysight MXR404A","text":"<ul> <li>Device Type: <code>oscilloscope</code></li> <li>Profile: <code>MXR404A.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-n9000a","title":"Keysight N9000A","text":"<ul> <li>Device Type: <code>spectrum_analyzer</code></li> <li>Profile: <code>N9000A_SA.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"profiles/gallery/#keysight-u2000a","title":"Keysight U2000A","text":"<ul> <li>Device Type: <code>power_meter</code></li> <li>Profile: <code>U2000A_PM.yaml</code></li> <li>Code Owners: <code>@e-a-olowe</code></li> <li>Last Updated: N/A</li> </ul>"},{"location":"user_guide/async_vs_sync/","title":"Asynchronous by Design","text":"<p>PyTestLab is designed with an asynchronous-first approach to instrument control and data acquisition. This guide explains why async is the default, how it benefits your workflows, and how to use async code in both scripts and notebooks.</p>"},{"location":"user_guide/async_vs_sync/#why-async","title":"Why Async?","text":"<p>Interacting with laboratory instruments is fundamentally I/O-bound: every command you send to a device involves waiting for a response. In a synchronous program, this waiting blocks your entire application, making it unresponsive and inefficient\u2014especially when controlling multiple instruments.</p> <p>Asynchronous programming (using Python's <code>asyncio</code>) allows your code to perform other tasks while waiting for I/O to complete. This is crucial for:</p> <ul> <li>Responsiveness: GUIs and CLIs remain interactive while instruments are busy.</li> <li>Concurrency: Easily coordinate multiple instruments in parallel.</li> <li>Efficiency: Lower memory and CPU usage compared to threads or processes.</li> </ul>"},{"location":"user_guide/async_vs_sync/#async-in-pytestlab","title":"Async in PyTestLab","text":"<p>All instrument methods that involve I/O are async functions (coroutines). You must use the <code>await</code> keyword to call them.</p>"},{"location":"user_guide/async_vs_sync/#example-async-oscilloscope-measurement","title":"Example: Async Oscilloscope Measurement","text":"Async Oscilloscope Example<pre><code>import asyncio\nimport pytestlab\n\nasync def measure_waveform():\n    # Create and connect to a simulated oscilloscope\n    scope = await pytestlab.AutoInstrument.from_config(\n        \"keysight/DSOX1204G\",\n        simulate=True\n    )\n    await scope.connect_backend()\n\n    # Configure channel and trigger\n    await scope.channel(1).setup(scale=0.5, offset=0).enable()\n    await scope.trigger.setup_edge(source=\"CH1\", level=0.25)\n\n    # Acquire waveform\n    result = await scope.read_channels(1)\n    print(\"Captured waveform data:\")\n    print(result.values.head())\n\n    await scope.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(measure_waveform())\n</code></pre> <p>In this example, every instrument operation (<code>connect_backend</code>, <code>setup</code>, <code>read_channels</code>, etc.) is asynchronous and must be awaited.</p>"},{"location":"user_guide/async_vs_sync/#using-async-in-different-environments","title":"Using Async in Different Environments","text":""},{"location":"user_guide/async_vs_sync/#in-a-script","title":"In a Script","text":"<p>Use <code>asyncio.run()</code> to execute your main async function:</p> <pre><code>import asyncio\n\nasync def main():\n    # ... your async code ...\n    pass\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"user_guide/async_vs_sync/#in-a-jupyter-notebook-or-ipython","title":"In a Jupyter Notebook or IPython","text":"<p>Modern Jupyter and IPython support top-level await. You can simply write:</p> <pre><code>import pytestlab\n\nscope = await pytestlab.AutoInstrument.from_config(\"keysight/DSOX1204G\", simulate=True)\nawait scope.connect_backend()\nawait scope.channel(1).setup(scale=0.2).enable()\nresult = await scope.read_channels(1)\nprint(result.values.head())\nawait scope.close()\n</code></pre> <p>If you see <code>SyntaxError: 'await' outside function</code>, your environment may not support top-level await. In that case, define an async function and use <code>await</code> inside it, or use <code>nest_asyncio</code> to patch the event loop.</p>"},{"location":"user_guide/async_vs_sync/#migrating-synchronous-scripts","title":"Migrating Synchronous Scripts","text":"<p>If you have old synchronous scripts, migrate them by:</p> <ol> <li>Changing all instrument I/O calls to <code>await</code> their async versions.</li> <li>Wrapping your main logic in an <code>async def</code> function.</li> <li>Running your code with <code>asyncio.run()</code>.</li> </ol> <p>Synchronous (not supported): <pre><code># This will NOT work with PyTestLab!\ndef measure_sync():\n    osc = SomeSyncOscilloscope()\n    osc.connect()\n    osc.setup_acquisition()\n    waveform = osc.read_waveform()\n    print(waveform)\n    osc.disconnect()\n</code></pre></p> <p>Asynchronous (PyTestLab way): <pre><code>import asyncio\nimport pytestlab\n\nasync def measure_async():\n    osc = await pytestlab.AutoInstrument.from_config(\"keysight/DSOX1204G\", simulate=True)\n    await osc.connect_backend()\n    await osc.channel(1).setup(scale=0.5).enable()\n    result = await osc.read_channels(1)\n    print(result.values.head())\n    await osc.close()\n\nasyncio.run(measure_async())\n</code></pre></p>"},{"location":"user_guide/async_vs_sync/#faq","title":"FAQ","text":""},{"location":"user_guide/async_vs_sync/#why-not-threads-or-processes","title":"Why not threads or processes?","text":"<p>Async I/O is lighter, safer, and easier to reason about for I/O-bound tasks. It avoids the complexity and overhead of threads, and is ideal for controlling many instruments concurrently.</p>"},{"location":"user_guide/async_vs_sync/#can-i-use-pytestlab-synchronously","title":"Can I use PyTestLab synchronously?","text":"<p>No. All instrument I/O is async by design. This ensures your code is robust, scalable, and ready for modern lab automation.</p>"},{"location":"user_guide/async_vs_sync/#what-if-i-need-to-call-async-code-from-sync-code","title":"What if I need to call async code from sync code?","text":"<p>You must use an event loop. In scripts, use <code>asyncio.run()</code>. In notebooks, use top-level <code>await</code> or an async function.</p> <p>For more practical examples, see the 10-Minute Tour and the Getting Started Guide.</p>"},{"location":"user_guide/bench_descriptors/","title":"Working with Benches","text":"<p>Bench Descriptors provide a powerful way to define and manage a collection of laboratory instruments as a single, cohesive unit called a \"Bench\". This is particularly useful for complex experimental setups where multiple instruments need to be configured and controlled together.</p> <p>The configuration for a bench is defined in a YAML file.</p>"},{"location":"user_guide/bench_descriptors/#the-benchyaml-file","title":"The <code>bench.yaml</code> File","text":"<p>A <code>bench.yaml</code> file is a declarative way to describe your entire test setup. It can include instrument definitions, safety limits, automation scripts, and metadata for traceability.</p> bench.yaml<pre><code>bench_name: \"Power Amplifier Characterization\"\ndescription: \"A bench for testing the gain and efficiency of a power amplifier.\"\nversion: \"1.0\"\n\nexperiment:\n  title: \"PA Gain Compression Test\"\n  operator: \"Lab User\"\n\nsimulate: false  # Global flag. Set to true to run the entire bench in simulation mode.\n\nbackend_defaults:\n  type: \"visa\"      # Default backend for all instruments (\"visa\", \"lamb\", or \"sim\").\n  timeout_ms: 10000\n\ninstruments:\n  # Each key under 'instruments' is an alias used to access it in Python (e.g., bench.psu)\n  vna:\n    profile: \"keysight/E5071C_VNA\"\n    address: \"TCPIP0::K-E5071C-12345::inst0::INSTR\"\n\n  psu:\n    profile: \"keysight/EDU36311A\"\n    address: \"TCPIP0::172.22.1.5::inst0::INSTR\"\n    safety_limits:  # Optional safety limits\n      channels:\n        1: { voltage: { max: 5.5 }, current: { max: 1.0 } }\n        2: { voltage: { max: 12.0 }, current: { max: 0.5 } }\n\n  sa:\n    profile: \"keysight/N9000A_SA\"\n    address: \"TCPIP0::K-N9000A-67890::inst0::INSTR\"\n\n  dmm:\n    profile: \"keysight/34470A\"\n    address: \"USB0::0x0957::0x1B07::MY56430012::INSTR\"\n\n  source1:\n    profile: \"my_custom_profiles/custom_signal_generator.yaml\"\n    address: \"lamb::SG001\"\n    backend:\n      type: \"lamb\"\n\n  awg:\n    profile: \"keysight/EDU33212A\"\n    address: \"USB0::0x2A8D::0x2A01::MY57701234::INSTR\"\n    simulate: true  # Individual instruments can override the global simulate flag\n\n  sim_psu:\n    profile: \"keysight/EDU36311A\"\n    # Address defaults to \"sim\" if not provided\n    # simulate: true\n\nautomation:\n  pre_experiment:\n    - \"psu: output all OFF\"\n    - \"python scripts/setup_environment.py\"\n  post_experiment:\n    - \"psu: output all OFF\"\n    - \"python scripts/save_results.py\"\n\ntraceability:\n  dut:\n    serial_number: \"PA-SN-042\"\n    description: \"Power Amplifier Prototype Rev C\"\n</code></pre> <p>Key Fields:</p> <ul> <li><code>bench_name</code> (string): A descriptive name for your bench.</li> <li><code>simulate</code> (boolean): A global flag to run all instruments in simulation mode. Can be overridden per instrument.</li> <li><code>backend_defaults</code> (dict): Default settings for instrument backends (e.g., <code>type</code>, <code>timeout_ms</code>).</li> <li><code>instruments</code> (dict): A dictionary where each key is an alias for an instrument.<ul> <li>Alias (e.g., <code>psu</code>, <code>dmm</code>): How you will refer to the instrument in your Python code (e.g., <code>bench.psu</code>).</li> <li><code>profile</code> (string): The instrument profile to use (e.g., <code>\"keysight/EDU36311A\"</code>).</li> <li><code>address</code> (string): The VISA resource string or other connection identifier.</li> <li><code>safety_limits</code> (dict): Defines maximum voltage/current to prevent accidental damage.</li> </ul> </li> <li><code>automation</code> (dict): A place to define scripts or commands to run before (<code>pre_experiment</code>) or after (<code>post_experiment</code>) your main script.</li> <li><code>traceability</code> (dict): A section for metadata about your test, such as calibration dates or information about the Device Under Test (DUT).</li> </ul>"},{"location":"user_guide/bench_descriptors/#using-a-bench-in-python","title":"Using a Bench in Python","text":"<p>The <code>pytestlab.Bench</code> class is the primary way to work with bench configurations. The recommended way to load a bench is with the <code>async with</code> statement, which handles instrument connection and cleanup automatically.</p> <pre><code>import asyncio\nimport pytestlab\n\nasync def main():\n    # Bench.open() loads the YAML, validates it, and connects to all instruments.\n    # The async with statement ensures instruments are closed properly.\n    try:\n        async with await pytestlab.Bench.open(\"path/to/your/bench.yaml\") as bench:\n            print(f\"\u2705 Bench '{bench.config.bench_name}' loaded successfully.\")\n            print(f\"\ud83d\udd2c Testing DUT: {bench.config.traceability.dut.description}\")\n\n            # Access instruments by their alias.\n            # The API is the same as using a standalone instrument.\n            await bench.psu.channel(1).set(voltage=3.3, current_limit=0.5).on()\n\n            # Perform a measurement with the DMM.\n            dc_voltage = await bench.dmm.measure_voltage_dc()\n            print(f\"Measured Voltage: {dc_voltage.values:.4f} V\")\n\n        # Post-experiment hooks are run automatically upon exiting the 'async with' block.\n        print(\"\u2705 Bench closed successfully.\")\n\n    except Exception as e:\n        print(f\"\u274c An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"user_guide/bench_descriptors/#safety-limits","title":"Safety Limits","text":"<p>When <code>safety_limits</code> are defined in <code>bench.yaml</code>, PyTestLab wraps the instrument driver with a safety layer. If you attempt to send a command that exceeds a defined limit, a <code>SafetyLimitError</code> is raised before the command is sent to the instrument.</p> <pre><code>try:\n    # This will fail because the safety limit in our YAML is 5.5V\n    await bench.psu.set_voltage(1, 6.0)\nexcept SafetyLimitError as e:\n    print(f\"Caught expected safety error: {e}\")\n</code></pre>"},{"location":"user_guide/bench_descriptors/#command-line-interface","title":"Command-Line Interface","text":"<p>PyTestLab provides CLI commands to manage and inspect bench configurations.</p> <ul> <li>List instruments in a bench: <pre><code>pytestlab bench ls path/to/bench.yaml\n</code></pre></li> <li>Validate a bench configuration: <pre><code>pytestlab bench validate path/to/bench.yaml\n</code></pre></li> <li>Identify instruments in a bench (IDN query): <pre><code>pytestlab bench id path/to/bench.yaml\n</code></pre></li> <li>Convert a bench to simulation mode: <pre><code>pytestlab bench sim path/to/bench.yaml --output-path bench.sim.yaml\n</code></pre></li> </ul> <p>For more information, see the CLI Reference.</p> <p>This system allows for flexible and reproducible management of your test setups, whether they involve real or simulated instruments.</p>"},{"location":"user_guide/cli/","title":"Command-Line Interface","text":"<p>PyTestLab includes a powerful command-line interface (CLI) built with Typer for managing profiles, instruments, and benches. You can access it via the <code>pytestlab</code> command.</p>"},{"location":"user_guide/cli/#general-usage","title":"General Usage","text":"<p>To see all available commands and sub-commands, use the <code>--help</code> flag:</p> <pre><code>pytestlab --help\n</code></pre>"},{"location":"user_guide/cli/#profile-management-pytestlab-profile","title":"Profile Management (<code>pytestlab profile</code>)","text":"<p>Commands for inspecting and validating instrument profiles.</p>"},{"location":"user_guide/cli/#list","title":"<code>list</code>","text":"<p>Lists all available built-in instrument profiles.</p> <pre><code>pytestlab profile list\n</code></pre>"},{"location":"user_guide/cli/#show","title":"<code>show</code>","text":"<p>Displays the contents of a specific profile YAML file.</p> <pre><code>pytestlab profile show keysight/DSOX1204G\n</code></pre>"},{"location":"user_guide/cli/#validate","title":"<code>validate</code>","text":"<p>Validates one or more profiles against their Pydantic models to ensure they are well-formed.</p> <pre><code>pytestlab profile validate path/to/my_custom_profiles/\n</code></pre>"},{"location":"user_guide/cli/#bench-management-pytestlab-bench","title":"Bench Management (<code>pytestlab bench</code>)","text":"<p>Commands for working with <code>bench.yaml</code> files.</p>"},{"location":"user_guide/cli/#ls","title":"<code>ls</code>","text":"<p>Lists the instruments defined in a bench configuration file.</p> <pre><code>pytestlab bench ls path/to/bench.yaml\n</code></pre>"},{"location":"user_guide/cli/#validate_1","title":"<code>validate</code>","text":"<p>Validates the structure of a <code>bench.yaml</code> file and checks that all specified profiles can be loaded.</p> <pre><code>pytestlab bench validate path/to/bench.yaml\n</code></pre>"},{"location":"user_guide/cli/#id","title":"<code>id</code>","text":"<p>Connects to all non-simulated instruments in a bench and queries their <code>*IDN?</code> string.</p> <pre><code>pytestlab bench id path/to/bench.yaml\n</code></pre>"},{"location":"user_guide/cli/#sim","title":"<code>sim</code>","text":"<p>Converts an existing <code>bench.yaml</code> file into a new one configured entirely for simulation mode.</p> <pre><code># Print the simulated config to the console\npytestlab bench sim path/to/bench.yaml\n\n# Save the simulated config to a new file\npytestlab bench sim path/to/bench.yaml --output-path bench.sim.yaml\n</code></pre> <p>For more details on simulation, see the Simulation Guide.</p>"},{"location":"user_guide/cli/#simulation-profile-tools-pytestlab-sim-profile","title":"Simulation Profile Tools (<code>pytestlab sim-profile</code>)","text":"<p>Commands for recording, editing, and managing simulation profiles.</p>"},{"location":"user_guide/cli/#record","title":"<code>record</code>","text":"<p>Interactively record a simulation profile by proxying commands to a real instrument and saving the responses.</p> <pre><code>pytestlab sim-profile record keysight/EDU36311A --address \"TCPIP0::...\"\n</code></pre>"},{"location":"user_guide/cli/#edit","title":"<code>edit</code>","text":"<p>Opens the user-specific simulation profile for the specified instrument in your default text editor.</p> <pre><code>pytestlab sim-profile edit keysight/EDU36311A\n</code></pre>"},{"location":"user_guide/cli/#reset","title":"<code>reset</code>","text":"<p>Deletes the user-specific simulation profile, reverting to the default profile.</p> <pre><code>pytestlab sim-profile reset keysight/EDU36311A\n</code></pre>"},{"location":"user_guide/cli/#diff","title":"<code>diff</code>","text":"<p>Shows the differences between the user-specific simulation profile and the default profile.</p> <pre><code>pytestlab sim-profile diff keysight/EDU36311A\n</code></pre>"},{"location":"user_guide/cli/#other-useful-commands","title":"Other Useful Commands","text":"<ul> <li> <p><code>pytestlab --version</code>   Print the installed version of PyTestLab.</p> </li> <li> <p><code>pytestlab profile list</code>   List all available instrument profiles.</p> </li> <li> <p><code>pytestlab bench validate</code>   Validate your bench configuration before running experiments.</p> </li> </ul>"},{"location":"user_guide/cli/#tips","title":"Tips","text":"<ul> <li>Use <code>pytestlab --help</code> and <code>pytestlab &lt;subcommand&gt; --help</code> for detailed usage and options.</li> <li>The CLI is ideal for quick validation, automation, and scripting in CI/CD pipelines.</li> <li>For advanced scripting, combine CLI commands with Python scripts using the PyTestLab API.</li> </ul> <p>For more information, see the User Guide and the Simulation Guide.</p>"},{"location":"user_guide/connecting/","title":"Connecting to Instruments","text":"<p>PyTestLab provides a unified and straightforward way to connect to both real and simulated instruments.</p>"},{"location":"user_guide/connecting/#using-autoinstrument","title":"Using <code>AutoInstrument</code>","text":"<p>The <code>pytestlab.AutoInstrument</code> factory is the primary way to create a single instrument instance. You need to provide a configuration source, which can be a profile key (e.g., <code>\"keysight/DSOX1204G\"</code>) or a path to a YAML file.</p> <p>Asynchronous Connection</p> <p>Creating an instrument instance with <code>AutoInstrument.from_config()</code> does not establish the connection. You must always <code>await</code> the <code>connect_backend()</code> method on the created instrument object.</p>"},{"location":"user_guide/connecting/#connecting-to-a-real-instrument","title":"Connecting to a Real Instrument","text":"<p>To connect to a physical instrument, you typically need its VISA address.</p> <pre><code>import asyncio\nimport pytestlab\n\nasync def main():\n    # Create an instrument instance from a profile and specify its address\n    dmm = await pytestlab.AutoInstrument.from_config(\n        \"keysight/34470A\",\n        address_override=\"USB0::0x0957::0x1B07::MY56430012::INSTR\"\n    )\n\n    # Establish the connection\n    await dmm.connect_backend()\n\n    print(f\"Connected to: {await dmm.id()}\")\n\n    # ... perform operations ...\n\n    await dmm.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"user_guide/connecting/#connecting-to-a-simulated-instrument","title":"Connecting to a Simulated Instrument","text":"<p>To create a simulated instrument for development or testing, set the <code>simulate=True</code> flag. No address is needed.</p> <pre><code>import asyncio\nimport pytestlab\n\nasync def main():\n    scope_sim = await pytestlab.AutoInstrument.from_config(\"keysight/DSOX1204G\", simulate=True)\n    await scope_sim.connect_backend()\n\n    print(f\"Connected to simulated instrument: {await scope_sim.id()}\")\n\n    await scope_sim.close()\n\nasyncio.run(main())\n</code></pre> <p>Simulation mode is ideal for development, CI, and testing when hardware is unavailable.</p>"},{"location":"user_guide/connecting/#using-a-bench","title":"Using a Bench","text":"<p>For managing multiple instruments, the <code>pytestlab.Bench</code> class is the recommended approach. It handles the connection and cleanup for all instruments defined in your <code>bench.yaml</code> file automatically.</p> <pre><code>import asyncio\nimport pytestlab\n\nasync def main():\n    async with await pytestlab.Bench.open(\"bench.yaml\") as bench:\n        print(f\"Bench loaded: {bench.config.bench_name}\")\n        # Access instruments by alias, e.g.:\n        await bench.psu.channel(1).set(voltage=3.3, current_limit=0.5).on()\n        voltage = await bench.dmm.measure_voltage_dc()\n        print(f\"Measured: {voltage.values:.4f} V\")\n    # All instruments are closed automatically here\n\nasyncio.run(main())\n</code></pre> <p>See the Working with Benches guide for more details.</p>"},{"location":"user_guide/connecting/#troubleshooting-connections","title":"Troubleshooting Connections","text":"<ul> <li>VISA Not Found: Ensure you have installed a VISA library (NI-VISA, Keysight IO Libraries, etc.) and that it is accessible in your system's PATH.</li> <li>Address Errors: Double-check your instrument's VISA address. Use <code>pytestlab profile list</code> and <code>pytestlab bench ls</code> to inspect available profiles and bench configurations.</li> <li>Simulation: If you encounter persistent connection issues, try running in simulation mode to isolate hardware vs. software problems.</li> </ul>"},{"location":"user_guide/connecting/#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started Guide</li> <li>Async vs. Sync Programming</li> <li>Simulation Guide</li> <li>Bench Descriptors</li> </ul>"},{"location":"user_guide/errors/","title":"Error Handling","text":"<p>PyTestLab provides robust error handling through a set of custom exception types. Understanding these exceptions and best practices for handling them will help you write reliable, safe, and maintainable test scripts.</p>"},{"location":"user_guide/errors/#common-exceptions","title":"Common Exceptions","text":"<p>Here are the most important exception types you may encounter:</p> <ul> <li> <p><code>InstrumentConnectionError</code>   Raised when PyTestLab fails to connect to an instrument. Causes include an incorrect address, network issues, or the instrument being offline.</p> </li> <li> <p><code>InstrumentCommunicationError</code>   Raised when an error occurs during communication with an instrument after a connection is established. Examples: timeouts, malformed commands, or unexpected responses.</p> </li> <li> <p><code>InstrumentParameterError</code>   Raised when an invalid parameter is passed to an instrument method. For example, setting a voltage outside the allowed range.</p> </li> <li> <p><code>InstrumentConfigurationError</code>   Raised when there is an error in an instrument's profile or bench configuration file. This can happen if required fields are missing or the file does not conform to the expected schema.</p> </li> <li> <p><code>SafetyLimitError</code>   Raised when an operation would violate a safety limit defined in your <code>bench.yaml</code> file. This prevents accidental damage to equipment or DUTs.</p> </li> <li> <p><code>InstrumentNotFoundError</code>   Raised when you try to access an instrument alias that is not defined in your bench configuration.</p> </li> </ul>"},{"location":"user_guide/errors/#best-practices","title":"Best Practices","text":""},{"location":"user_guide/errors/#catch-specific-exceptions","title":"Catch Specific Exceptions","text":"<p>Always catch the most specific exception possible. This allows you to handle different error types appropriately.</p> <pre><code>import pytestlab\nfrom pytestlab.errors import (\n    InstrumentConnectionError,\n    InstrumentParameterError,\n    SafetyLimitError,\n)\n\ntry:\n    async with await pytestlab.Bench.open(\"bench.yaml\") as bench:\n        # This might raise InstrumentParameterError if 6.0 is out of range,\n        # or SafetyLimitError if it exceeds a safety limit.\n        await bench.psu.set_voltage(1, 6.0)\nexcept InstrumentConnectionError as e:\n    print(f\"Failed to connect: {e}\")\nexcept InstrumentParameterError as e:\n    print(f\"Invalid parameter: {e}\")\nexcept SafetyLimitError as e:\n    print(f\"Safety violation: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"user_guide/errors/#use-async-with-for-cleanup","title":"Use <code>async with</code> for Cleanup","text":"<p>The <code>Bench</code> and <code>MeasurementSession</code> classes are asynchronous context managers. Using them with <code>async with</code> ensures all instruments are closed and cleanup hooks are run, even if an error occurs.</p> <pre><code>async def safe_operation():\n    try:\n        async with await pytestlab.Bench.open(\"bench.yaml\") as bench:\n            # ... your code ...\n            pass\n    except Exception as e:\n        print(f\"Operation failed: {e}\")\n    # Instruments are closed automatically here\n</code></pre>"},{"location":"user_guide/errors/#debugging-tips","title":"Debugging Tips","text":"<ul> <li>Check addresses: If you get a connection error, verify the instrument address in your config.</li> <li>Consult datasheets: If you get a parameter error, check the instrument's manual for valid ranges.</li> <li>Enable logging: PyTestLab uses Python's <code>logging</code> module. Increase the log level for more detail.</li> <li>Validate configs: Use the CLI (<code>pytestlab profile validate</code> or <code>pytestlab bench validate</code>) to catch configuration errors early.</li> <li>Use simulation: Develop and debug with simulated instruments to avoid hardware risks.</li> </ul>"},{"location":"user_guide/errors/#further-reading","title":"Further Reading","text":"<ul> <li>API Exception Reference</li> <li>Simulation Guide</li> <li>Bench Descriptors &amp; Safety Limits</li> </ul>"},{"location":"user_guide/getting_started/","title":"Getting Started with PyTestLab","text":"<p>Welcome to PyTestLab! This guide will walk you through the essential first steps to get up and running with the toolbox.</p> <p>The best way to get started is with our interactive 10-Minute Tour. This Jupyter Notebook will guide you through:</p> <ul> <li>Connecting to a simulated instrument.</li> <li>Using the asynchronous, facade-based API for instrument control.</li> <li>Performing a simple measurement.</li> <li>Storing results in a database.</li> </ul> <p>\u27a1\ufe0f Start the 10-Minute Tour</p>"},{"location":"user_guide/getting_started/#1-installation","title":"1. Installation","text":"<p>Before you begin, make sure you have PyTestLab installed. If not, see the Installation Guide.</p> <pre><code>pip install pytestlab\n</code></pre> <p>For full functionality (plotting, uncertainty, etc.), use:</p> <pre><code>pip install pytestlab[full]\n</code></pre>"},{"location":"user_guide/getting_started/#2-your-first-instrument-simulated","title":"2. Your First Instrument (Simulated)","text":"<p>PyTestLab is async-first. All instrument operations are asynchronous and use Python's <code>async/await</code> syntax.</p> <p>Here's how to connect to a simulated oscilloscope and acquire data:</p> <pre><code>import asyncio\nfrom pytestlab.instruments import AutoInstrument\n\nasync def main():\n    # Create a simulated oscilloscope\n    scope = await AutoInstrument.from_config(\"keysight/DSOX1204G\", simulate=True)\n    await scope.connect_backend()\n\n    # Configure channel and trigger\n    await scope.channel(1).setup(scale=0.5, offset=0).enable()\n    await scope.trigger.setup_edge(source=\"CH1\", level=0.25)\n\n    # Acquire waveform data\n    result = await scope.read_channels(1)\n    print(\"Acquired waveform data:\")\n    print(result.values.head())  # .values is a Polars DataFrame\n\n    await scope.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"user_guide/getting_started/#3-next-steps","title":"3. Next Steps","text":"<ul> <li>Explore the 10-Minute Tour for a hands-on walkthrough.</li> <li>Learn about Async vs. Sync programming in PyTestLab.</li> <li>See how to Connect to real instruments.</li> <li>Browse the Profile Gallery for supported devices.</li> <li>Read about Simulation Mode for hardware-free development.</li> </ul>"},{"location":"user_guide/getting_started/#4-need-help","title":"4. Need Help?","text":"<ul> <li>Check the User Guide for more topics.</li> <li>Join the community or open an issue on GitHub if you get stuck.</li> </ul> <p>Happy testing and measuring!</p>"},{"location":"user_guide/simulation/","title":"Simulation Mode","text":"<p>PyTestLab features a powerful, YAML-driven simulation backend (<code>SimBackendV2</code>) that provides realistic and deterministic behavior for your instruments.</p>"},{"location":"user_guide/simulation/#how-simulation-works","title":"How Simulation Works","text":"<p>The behavior of a simulated instrument is defined in the <code>simulation</code> section of its profile YAML file. This section maps SCPI commands (using exact matches or regex patterns) to specific responses or state changes.</p>"},{"location":"user_guide/simulation/#example-profile-with-simulation-logic","title":"Example: Profile with Simulation Logic","text":"pytestlab/profiles/pytestlab/virtual_instrument.yaml<pre><code>manufacturer: PyTestLab\nmodel: Virtual-Instrument-1\ndevice_type: virtual_instrument\n\nsimulation:\n  initial_state:\n    voltage: 0.0\n    current: 0.0\n    counter: 0\n\n  scpi:\n    # Simple query with a static response\n    \"*IDN?\": \"PyTestLab,Virtual-Instrument-1,0,1.0\"\n\n    # Command that changes state using regex capture group ($1)\n    \"SET:VOLT ([-+]?[0-9]*\\\\.?[0-9]+)\":\n      set:\n        voltage: \"py:float(g1)\" # Use a python expression to cast\n\n    # Query that retrieves a value from the state\n    \"MEAS:VOLT?\":\n      get: \"voltage\"\n\n    # Command with state manipulation\n    \"COUNT:INC\":\n      inc:\n        counter: 1\n\n    # Query with a dynamic Python lambda expression\n    \"DYNAMIC:RAND?\":\n      response: \"lambda: str(random.randint(1, 100))\"\n</code></pre>"},{"location":"user_guide/simulation/#enabling-simulation","title":"Enabling Simulation","text":"<p>There are several ways to enable simulation mode:</p> <ol> <li>Globally in <code>bench.yaml</code>: Set <code>simulate: true</code> at the top level of your bench file.</li> <li>Per-instrument in <code>bench.yaml</code>: Add <code>simulate: true</code> to a specific instrument's definition.</li> <li>In <code>AutoInstrument</code>: Pass <code>simulate=True</code> when creating an instrument instance.     <pre><code>import pytestlab\nscope = await pytestlab.AutoInstrument.from_config(\"keysight/DSOX1204G\", simulate=True)\n</code></pre></li> </ol>"},{"location":"user_guide/simulation/#recording-a-simulation-profile","title":"Recording a Simulation Profile","text":"<p>You can automatically generate a simulation profile by recording the interaction with a real instrument. This is useful for creating a high-fidelity simulation of a specific instrument's behavior.</p>"},{"location":"user_guide/simulation/#step-by-step-guide","title":"Step-by-Step Guide","text":"<ol> <li> <p>Connect to the real instrument you want to profile.</p> </li> <li> <p>Run the <code>sim-profile record</code> command, providing the profile key and VISA address.</p> <pre><code>pytestlab sim-profile record keysight/EDU36311A --address \"TCPIP0::...\"\n</code></pre> </li> <li> <p>Interact with the instrument in the interactive REPL that appears. All commands and responses will be recorded. You can also point the command to a Python script to run automatically.</p> </li> <li> <p>Stop the recording by pressing <code>Ctrl+D</code> or typing <code>exit()</code>. The recorded YAML profile will be saved to your user configuration directory (e.g., <code>~/.config/pytestlab/recorded_sim_profiles/</code>).</p> </li> </ol> <p>See the CLI Reference for more <code>sim-profile</code> commands like <code>edit</code>, <code>reset</code>, and <code>diff</code>.</p>"},{"location":"user_guide/simulation/#advanced-simulation-features","title":"Advanced Simulation Features","text":"<ul> <li>Stateful Simulation: The simulation backend can maintain internal state (e.g., voltages, counters) and update it in response to commands.</li> <li>Python Expressions: Use <code>py:</code> or <code>lambda:</code> in responses to compute dynamic values.</li> <li>Regex Matching: SCPI command patterns can use regular expressions for flexible matching and parameter extraction.</li> <li>Deterministic Testing: Simulation ensures repeatable results for CI/CD and development.</li> </ul>"},{"location":"user_guide/simulation/#when-to-use-simulation","title":"When to Use Simulation","text":"<ul> <li>Development: Write and test your automation scripts without hardware.</li> <li>Continuous Integration: Run your test suite in CI pipelines without requiring lab instruments.</li> <li>Education: Teach instrument automation concepts without needing physical devices.</li> <li>Prototyping: Quickly prototype new measurement flows and experiment logic.</li> </ul>"},{"location":"user_guide/simulation/#limitations","title":"Limitations","text":"<ul> <li>Simulation is only as accurate as the profile and recorded logic. For high-fidelity simulation, record real instrument sessions.</li> <li>Not all edge cases or error conditions may be covered by default profiles.</li> </ul>"},{"location":"user_guide/simulation/#further-reading","title":"Further Reading","text":"<ul> <li>Creating Profiles</li> <li>Working with Benches</li> <li>Command-Line Interface Reference</li> </ul>"},{"location":"user_guide/uncertainty/","title":"Handling Uncertainty","text":"<p>PyTestLab provides first-class support for measurement uncertainty, enabling you to propagate and quantify errors throughout your data analysis workflow. This is essential for scientific rigor and for meeting compliance requirements in regulated environments.</p>"},{"location":"user_guide/uncertainty/#why-uncertainty-matters","title":"Why Uncertainty Matters","text":"<p>Every measurement has an associated uncertainty, arising from instrument limitations, environmental factors, and other sources of error. Properly tracking and propagating these uncertainties is crucial for:</p> <ul> <li>Assessing the reliability of your results</li> <li>Comparing measurements from different instruments or labs</li> <li>Meeting the requirements of standards such as ISO/IEC 17025</li> </ul>"},{"location":"user_guide/uncertainty/#how-pytestlab-handles-uncertainty","title":"How PyTestLab Handles Uncertainty","text":"<p>PyTestLab integrates with the <code>uncertainties</code> Python package to represent and propagate measurement errors automatically.</p>"},{"location":"user_guide/uncertainty/#instrument-profiles-and-accuracy","title":"Instrument Profiles and Accuracy","text":"<p>Instrument profiles in PyTestLab can specify accuracy specifications directly in their YAML configuration, typically as a combination of percentage of reading, percentage of range, and absolute offset. These are parsed and used to compute the standard uncertainty for each measurement.</p> <p>Example excerpt from a DMM profile:</p> <pre><code>accuracy:\n  dc_voltage:\n    percentage: 0.025   # \u00b10.025% of reading\n    absolute: 0.0005    # \u00b10.0005 V\n</code></pre>"},{"location":"user_guide/uncertainty/#automatic-uncertainty-propagation","title":"Automatic Uncertainty Propagation","text":"<p>When you perform a measurement using a PyTestLab instrument driver, the returned value is a <code>UFloat</code> object (from the <code>uncertainties</code> package) if accuracy data is available. This object contains both the nominal value and its standard deviation.</p> <pre><code>import pytestlab\n\n# Assume 'dmm' is an initialized instrument with accuracy specs\nresult = await dmm.measure_voltage_dc()\nprint(result.values)  # e.g., 5.0012+/-0.0025\n\n# The value is a UFloat, so you can do math and propagate errors:\nresistor = 1000.0  # Ohms, assumed exact\ncurrent = result.values / resistor\nprint(f\"Current: {current}\")  # Uncertainty is propagated automatically\n</code></pre>"},{"location":"user_guide/uncertainty/#working-with-ufloat-objects","title":"Working with UFloat Objects","text":"<ul> <li>Nominal value: <code>result.values.nominal_value</code></li> <li>Standard deviation: <code>result.values.std_dev</code></li> <li>String representation: <code>str(result.values)</code> (e.g., <code>5.0012+/-0.0025</code>)</li> <li>Math operations: All standard math operations propagate uncertainty.</li> </ul> <p>For more, see the uncertainties documentation.</p>"},{"location":"user_guide/uncertainty/#custom-uncertainty-models","title":"Custom Uncertainty Models","text":"<p>If your instrument or measurement requires a custom uncertainty model (e.g., temperature dependence, non-Gaussian errors), you can:</p> <ul> <li>Extend the instrument profile with additional fields</li> <li>Post-process the returned <code>UFloat</code> objects with your own calculations</li> <li>Use the <code>uncertainties.ufloat</code> constructor to wrap your own values</li> </ul>"},{"location":"user_guide/uncertainty/#best-practices","title":"Best Practices","text":"<ul> <li>Always check your instrument profile: Ensure accuracy specs are present and correct.</li> <li>Use the returned <code>UFloat</code> objects: Don\u2019t discard uncertainty information in your analysis.</li> <li>Propagate uncertainty through all calculations: This is automatic with <code>uncertainties</code>, but be careful when converting to plain floats.</li> <li>Document your uncertainty sources: For compliance and reproducibility.</li> </ul>"},{"location":"user_guide/uncertainty/#further-reading","title":"Further Reading","text":"<ul> <li>uncertainties package documentation</li> <li>PyTestLab Configuration Models</li> <li>10-Minute Tour: Uncertainty Example</li> </ul>"}]}