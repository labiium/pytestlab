<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Scientific test & measurement toolbox for Python.">
    <meta name="author" content="LABIIUM">
    <meta name="robots" content="index, follow">

    <!-- Favicon -->
    <link rel="icon" href="../../img/favicon.ico" type="image/x-icon">

    <title>Instruments - PyTestLab</title>

    <!-- CSS -->
    <link rel="stylesheet" href="../../css/theme.css">

    <!-- Prism.js CSS for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">

    <!-- Search styles -->
    <style>
        .search-container {
            position: relative;
            margin-right: 1rem;
        }

        .md-search {
            position: relative;
        }

        .md-search__inner {
            width: 100%;
        }

        .md-search__form {
            position: relative;
            display: flex;
            align-items: center;
            padding: 0 0.5rem;
            height: 2.4rem;
            width: 16rem;
        }

        .md-search__input {
            flex-grow: 1;
            height: 100%;
            background: transparent;
            border: none;
            outline: none;
            padding: 0 0.5rem;
        }

        .md-search__icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1.8rem;
            height: 1.8rem;
            cursor: pointer;
        }

        .md-search__icon svg {
            width: 1.2rem;
            height: 1.2rem;
        }

        .md-search-result {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            width: 24rem;
            max-height: 75vh;
            overflow-y: auto;
            margin-top: 0.5rem;
            z-index: 100;
        }
    </style>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=Manrope:wght@800&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">

    <!-- Extra head content from plugins -->
    
</head>
<body>
    <div id="background-beams"></div>

    <div class="layout">
        <!-- Header / Navigation -->
        <header class="site-header">
            <div class="container">
                <div class="header-content">
                    <div class="logo-container">
                        <a href="../.." class="site-logo">
                            <img src="../../img/pytestlab_logo.png" alt="PyTestLab Logo">
                            <span class="site-name">PyTestLab</span>
                        </a>
                    </div>

                    <nav class="nav-primary">
                        <button class="mobile-nav-toggle" aria-label="Toggle navigation">
                            <span class="line"></span>
                            <span class="line"></span>
                            <span class="line"></span>
                        </button>

                        <ul class="nav-links">
                            
                                
                            
                                
                                    
                                        <li class="nav-item dropdown ">
                                            <a href="#" class="dropdown-toggle">Docs</a>
                                            <ul class="dropdown-menu glass-card">
                                                
                                                    <li class="">
                                                        <a href="../../installation/">Installation</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../user_guide/getting_started/">Getting Started</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../user_guide/async_vs_sync/">Async vs. Sync</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../user_guide/connecting/">Connecting to Instruments</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../user_guide/simulation/">Simulation Mode</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../user_guide/bench_descriptors/">Bench Descriptors</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../user_guide/errors/">Error Handling</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../user_guide/uncertainty/">Handling Uncertainty</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../user_guide/cli/">Command-Line Interface</a>
                                                    </li>
                                                
                                            </ul>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li class="nav-item dropdown ">
                                            <a href="#" class="dropdown-toggle">Tutorials</a>
                                            <ul class="dropdown-menu glass-card">
                                                
                                                    <li class="">
                                                        <a href="../../../tutorials/10_minute_tour.ipynb">10 Minute Tour</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../../tutorials/compliance.ipynb">Compliance and Audit</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../../tutorials/custom_validations.ipynb">Custom Validations</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../../tutorials/profile_creation.ipynb">Profile Creation</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../../tutorials/smartbench.ipynb">SmartBench Example</a>
                                                    </li>
                                                
                                            </ul>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li class="nav-item dropdown active">
                                            <a href="#" class="dropdown-toggle">API</a>
                                            <ul class="dropdown-menu glass-card">
                                                
                                                    <li class="active">
                                                        <a href="./">Instruments</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../measurements/">Measurements</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../experiments/">Experiments & Database</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../backends/">Backends</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../config/">Configuration</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../errors/">Errors</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../common/">Common Utilities</a>
                                                    </li>
                                                
                                            </ul>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li class="nav-item dropdown ">
                                            <a href="#" class="dropdown-toggle">Instruments</a>
                                            <ul class="dropdown-menu glass-card">
                                                
                                                    <li class="">
                                                        <a href="../../profiles/gallery/">Profile Gallery</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../profiles/creating/">Creating Profiles</a>
                                                    </li>
                                                
                                            </ul>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li class="nav-item dropdown ">
                                            <a href="#" class="dropdown-toggle">Community</a>
                                            <ul class="dropdown-menu glass-card">
                                                
                                                    <li class="">
                                                        <a href="../../contributing/">Contributing</a>
                                                    </li>
                                                
                                                    <li class="">
                                                        <a href="../../changelog/">Changelog</a>
                                                    </li>
                                                
                                            </ul>
                                        </li>
                                    
                                
                            
                        </ul>
                    </nav>

                    <div class="header-actions">
                        <!-- Search component -->
                        <div class="search-container">
                            <button class="search-button" id="searchButton" aria-label="Open Search">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="11" cy="11" r="8"></circle>
                                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                </svg>
                            </button>
                        </div>

                        <!-- Search Modal -->
                        <div class="search-modal" id="searchModal">
                            <div class="search-modal-content">
                                <form class="search-form">
                                    <input type="text" class="search-input" id="searchInput" placeholder="Search documentation..." autofocus>
                                    <button type="button" class="search-close" id="searchClose">
                                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <line x1="18" y1="6" x2="6" y2="18"></line>
                                            <line x1="6" y1="6" x2="18" y2="18"></line>
                                        </svg>
                                    </button>
                                </form>
                                <div class="search-results">
                                    <div class="search-results-meta" id="searchResultsMeta">Type to start searching</div>
                                    <div id="searchResults"></div>
                                </div>
                            </div>
                        </div>

                        
                        <a href="https://github.com/pytestlab/pytestlab" target="_blank" class="beam-button beam-button-sm">
                            <span class="beam-button-text">GitHub</span>
                        </a>
                        
                    </div>
                </div>
            </div>
        </header>

        <!-- Page Content -->
        <main class="main-content">
            <div class="container">
                <div class="content-layout">
                    <!-- Sidebar / Table of Contents -->
                    
                    <aside class="sidebar">
                        <div class="glass-card toc-container">
                            <div class="toc-header">
                                <h4>Contents</h4>
                            </div>
                            
                                <ul class="toc">
                                    
                                        <li class="toc-item level-1">
                                            <a href="#instrument-drivers">Instrument Drivers</a>
                                            
                                                <ul>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#core-instrument-classes">Core Instrument Classes</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.AutoInstrument">AutoInstrument</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.Instrument">Instrument</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#supported-instrument-types">Supported Instrument Types</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.Oscilloscope">Oscilloscope</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.PowerSupply">PowerSupply</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.WaveformGenerator">WaveformGenerator</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.Multimeter">Multimeter</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.DCActiveLoad">DCActiveLoad</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.SpectrumAnalyser">SpectrumAnalyser</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.VectorNetworkAnalyser">VectorNetworkAnalyser</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#pytestlab.instruments.PowerMeter">PowerMeter</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#facade-pattern">Facade Pattern</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#simulation-support">Simulation Support</a>
                                                        </li>
                                                    
                                                        <li class="toc-item level-2">
                                                            <a href="#extending-drivers">Extending Drivers</a>
                                                        </li>
                                                    
                                                </ul>
                                            
                                        </li>
                                    
                                </ul>
                            
                        </div>
                    </aside>
                    

                    <!-- Main Content Area -->
                    <div class="page-content glass-card">
                        <div class="article">
                            
                            <h1 class="page-title">Instruments</h1>
                            
                            

                            
                                <h1 id="instrument-drivers">Instrument Drivers</h1>
<p>This section documents the main instrument driver classes provided by PyTestLab. All drivers support both real and simulated backends, and expose a modern, async-first API.</p>
<hr />
<h2 id="core-instrument-classes">Core Instrument Classes</h2>


<div class="doc doc-object doc-module">



<h2 id="pytestlab.instruments.AutoInstrument" class="doc doc-heading">
            <code>pytestlab.instruments.AutoInstrument</code>


</h2>

    <div class="doc doc-contents first">









  <div class="doc doc-children">






<h3 id="pytestlab.instruments.AutoInstrument-classes">Classes</h3>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.AutoInstrument.AutoInstrument" class="doc doc-heading">
            <code>AutoInstrument</code>


</h4>


    <div class="doc doc-contents ">


        <p>A factory class for creating and configuring instrument objects.</p>
<p>This class provides a high-level interface to instantiate various types of
instruments based on configuration files, instrument types, or other
identifiers. It handles the complexities of locating configuration data,
selecting the appropriate communication backend (e.g., VISA, simulation),
and initializing the correct instrument driver.</p>
<p>The primary methods are <code>from_config</code> for creating an instrument from a
configuration source and <code>from_type</code> for creating one based on a generic
instrument category.</p>










  <div class="doc doc-children">







<h5 id="pytestlab.instruments.AutoInstrument.AutoInstrument-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.AutoInstrument.AutoInstrument.from_config" class="doc doc-heading">
            <code class="highlight language-python">from_config(config_source, *args, serial_number=None, debug_mode=False, simulate=None, backend_type_hint=None, address_override=None, timeout_override_ms=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Initializes an instrument from a configuration source.</p>
<p>This is the primary factory method for creating instrument instances. It
orchestrates the entire setup process:
1. Loads configuration from a dictionary, a local file, or a CDN URL.
2. Determines whether to run in simulation or live mode.
3. Selects and instantiates the appropriate communication backend (Sim, VISA, Lamb).
4. Instantiates the final instrument driver with the config and backend.</p>
<p>Note: This method creates and configures the instrument object but does not
establish the connection. The caller must explicitly call <code>await
instrument.connect_backend()</code> on the returned object.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>config_source</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>A dictionary containing the configuration, a string
           identifier for a CDN/local profile, or a file path.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>serial_number</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>An optional serial number to override the one in the config.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>debug_mode</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>If True, prints detailed logs during the setup process.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="bool">bool</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>False</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>simulate</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>Explicitly enable or disable simulation mode, overriding
      environment variables and config settings.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="bool">bool</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>backend_type_hint</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>Manually specify the backend ('visa' or 'lamb'),
               bypassing automatic detection.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>address_override</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>Use a specific communication address, overriding the
              one in the config.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>timeout_override_ms</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>Use a specific communication timeout in milliseconds.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a>[<span title="typing.Any">Any</span>]</code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>An initialized instrument object ready to be connected.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><span title="FileNotFoundError">FileNotFoundError</span></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the configuration source is a string and the
               corresponding file cannot be found.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentConfigurationError(instrument=None, message='')" href="../errors/#pytestlab.errors.InstrumentConfigurationError">InstrumentConfigurationError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the configuration is invalid or a
                          required setting is missing.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><span title="TypeError">TypeError</span></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If <code>config_source</code> is not a dictionary or a string.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/AutoInstrument.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
async def from_config(cls: Type[AutoInstrument],
                config_source: Union[str, Dict[str, Any]],
                *args,
                serial_number: Optional[str] = None,
                debug_mode: bool = False, # For logging during config load
                simulate: Optional[bool] = None,
                backend_type_hint: Optional[str] = None,
                address_override: Optional[str] = None,
                timeout_override_ms: Optional[int] = None
               ) -&gt; Instrument[Any]: # Returns an instance of a subclass of Instrument
    """Initializes an instrument from a configuration source.

    This is the primary factory method for creating instrument instances. It
    orchestrates the entire setup process:
    1. Loads configuration from a dictionary, a local file, or a CDN URL.
    2. Determines whether to run in simulation or live mode.
    3. Selects and instantiates the appropriate communication backend (Sim, VISA, Lamb).
    4. Instantiates the final instrument driver with the config and backend.

    Note: This method creates and configures the instrument object but does not
    establish the connection. The caller must explicitly call `await
    instrument.connect_backend()` on the returned object.

    Args:
        config_source: A dictionary containing the configuration, a string
                       identifier for a CDN/local profile, or a file path.
        serial_number: An optional serial number to override the one in the config.
        debug_mode: If True, prints detailed logs during the setup process.
        simulate: Explicitly enable or disable simulation mode, overriding
                  environment variables and config settings.
        backend_type_hint: Manually specify the backend ('visa' or 'lamb'),
                           bypassing automatic detection.
        address_override: Use a specific communication address, overriding the
                          one in the config.
        timeout_override_ms: Use a specific communication timeout in milliseconds.

    Returns:
        An initialized instrument object ready to be connected.

    Raises:
        FileNotFoundError: If the configuration source is a string and the
                           corresponding file cannot be found.
        InstrumentConfigurationError: If the configuration is invalid or a
                                      required setting is missing.
        TypeError: If `config_source` is not a dictionary or a string.
    """
    # Support serial_number as positional second argument
    if len(args) &gt; 0 and isinstance(args[0], str):
        serial_number = args[0]

    config_data: Dict[str, Any]

    # Step 1: Load configuration data from the provided source
    config_model: PydanticInstrumentConfig
    if isinstance(config_source, PydanticInstrumentConfig):
        config_model = config_source
        config_data = config_model.model_dump(mode='python')
    elif isinstance(config_source, dict):
        config_data = config_source
        config_model = load_profile(config_data)
    elif isinstance(config_source, str):
        try:
            # Try fetching from the CDN first
            config_data = await cls.get_config_from_cdn(config_source)
            if debug_mode: print(f"Successfully loaded configuration for '{config_source}' from CDN.")
        except FileNotFoundError:
            try:
                # Fallback to local file system if not found on CDN
                config_data = await cls.get_config_from_local(config_source)
                if debug_mode: print(f"Successfully loaded configuration for '{config_source}' from local.")
            except FileNotFoundError:
                # If not found in either location, raise an error
                raise FileNotFoundError(f"Configuration '{config_source}' not found in CDN or local paths.")
        config_model = load_profile(config_data)
    else:
        raise TypeError("config_source must be a file path (str), a dict, or an InstrumentConfig object.")

    # Override the serial number in the config if one is provided as an argument
    if serial_number is not None and hasattr(config_model, 'serial_number'):
        config_model.serial_number = serial_number # type: ignore

    backend_instance: AsyncInstrumentIO

    # Step 2: Determine the final simulation mode based on a clear priority
    final_simulation_mode: bool
    if simulate is not None:
        # Highest priority: explicit argument to the function
        final_simulation_mode = simulate
        if debug_mode: print(f"Simulation mode explicitly set to {final_simulation_mode} by argument.")
    else:
        # Second priority: environment variable
        env_simulate = os.getenv("PYTESTLAB_SIMULATE")
        if env_simulate is not None:
            final_simulation_mode = env_simulate.lower() in ('true', '1', 'yes')
            if debug_mode: print(f"Simulation mode set to {final_simulation_mode} by PYTESTLAB_SIMULATE environment variable.")
        else:
            # Lowest priority: default to False
            final_simulation_mode = False
            if debug_mode: print(f"Simulation mode defaulted to {final_simulation_mode} (no explicit argument or PYTESTLAB_SIMULATE).")

    # Step 3: Determine the actual communication address and timeout
    actual_address: Optional[str]
    if address_override is not None:
        # Argument override has the highest priority for address
        actual_address = address_override
        if debug_mode: print(f"Address overridden to '{actual_address}'.")
    else:
        # Otherwise, get the address from the configuration data
        actual_address = getattr(config_model, 'address', getattr(config_model, 'resource_name', None))
        if debug_mode: print(f"Address from config: '{actual_address}'.")

    actual_timeout: int
    default_communication_timeout_ms = 30000 # Default if not in override or config
    if timeout_override_ms is not None:
        actual_timeout = timeout_override_ms
        if debug_mode: print(f"Timeout overridden to {actual_timeout}ms.")
    else:
        # Assuming 'communication.timeout_ms' or 'communication_timeout_ms' might exist
        # Prefer 'communication_timeout_ms' as per previous logic if 'communication' object isn't standard
        timeout_from_config = getattr(config_model, 'communication_timeout_ms', None)
        if hasattr(config_model, 'communication') and hasattr(config_model.communication, 'timeout_ms'): # type: ignore
             timeout_from_config = config_model.communication.timeout_ms # type: ignore

        if isinstance(timeout_from_config, int) and timeout_from_config &gt; 0:
            actual_timeout = timeout_from_config
            if debug_mode: print(f"Timeout from config: {actual_timeout}ms.")
        else:
            actual_timeout = default_communication_timeout_ms
            if debug_mode: print(f"Warning: Invalid or missing timeout in config, using default {actual_timeout}ms.")

    if not isinstance(actual_timeout, int) or actual_timeout &lt;= 0: # Final safety check
        actual_timeout = default_communication_timeout_ms
        if debug_mode: print(f"Warning: Corrected invalid timeout to default {actual_timeout}ms.")


    # Step 4: Instantiate the appropriate backend based on the mode and configuration
    if final_simulation_mode:
        # Helper to resolve sim profile path
        def resolve_sim_profile_path(profile_key_or_path: str) -&gt; str:
            # 1. User override in ~/.pytestlab/profiles
            user_profile = os.path.expanduser(os.path.join("~/.pytestlab/profiles", profile_key_or_path + ".yaml"))
            if os.path.exists(user_profile):
                return user_profile
            # 2. User sim_profiles (legacy)
            user_sim_profile = os.path.expanduser(os.path.join("~/.pytestlab/sim_profiles", profile_key_or_path + ".yaml"))
            if os.path.exists(user_sim_profile):
                return user_sim_profile
            # 3. Package profile
            import pytestlab as ptl
            pkg_profile = os.path.join(os.path.dirname(ptl.__file__), "profiles", profile_key_or_path + ".yaml")
            if os.path.exists(pkg_profile):
                return pkg_profile
            # 4. Direct path
            if os.path.exists(profile_key_or_path):
                return profile_key_or_path
            raise FileNotFoundError(f"Simulation profile not found for '{profile_key_or_path}'")

        device_model_str = getattr(config_model, "model", "GenericSimulatedModel")
        if isinstance(config_source, str):
            sim_profile_path = os.path.abspath(resolve_sim_profile_path(config_source))
            if debug_mode:
                print(f"Resolved sim profile path: {sim_profile_path}")
        else:
            # Write dict config to a temp file
            with tempfile.NamedTemporaryFile("w", suffix=".yaml", delete=False) as tf:
                yaml.dump(config_data, tf)
                sim_profile_path = os.path.abspath(tf.name)
            if debug_mode:
                print(f"Wrote temp sim profile: {sim_profile_path}")
        backend_instance = SimBackendV2(
            profile_path=sim_profile_path,
            model=device_model_str,
            timeout_ms=actual_timeout,
        )
        if debug_mode:
            print(
                f"Using SimBackendV2 for {device_model_str} with timeout {actual_timeout}ms. Profile: {sim_profile_path}"
            )
    else:
        # For live hardware, determine the backend type (VISA or Lamb)
        if backend_type_hint:
            # Explicit hint overrides any inference
            chosen_backend_type = backend_type_hint.lower()
            if debug_mode: print(f"Backend type hint provided: '{chosen_backend_type}'.")
        elif actual_address and "LAMB::" in actual_address.upper():
            # Infer 'lamb' backend from the address format
            chosen_backend_type = 'lamb'
            if debug_mode: print(f"Inferred backend type: 'lamb' from address '{actual_address}'.")
        elif actual_address:
            # Infer 'visa' for any other address type
            chosen_backend_type = 'visa'
            if debug_mode: print(f"Inferred backend type: 'visa' from address '{actual_address}'.")
        else:
            # Default to 'lamb' if no address is provided (e.g., for remote discovery)
            chosen_backend_type = 'lamb'
            if debug_mode: print(f"Defaulting backend type to 'lamb' (no address present).")

        if chosen_backend_type == 'visa':
            if actual_address is None:
                raise InstrumentConfigurationError(
                    config_source, "Missing address/resource_name for VISA backend."
                )
            backend_instance = AsyncVisaBackend(address=actual_address, timeout_ms=actual_timeout)
            if debug_mode: print(f"Using AsyncVisaBackend for '{actual_address}' with timeout {actual_timeout}ms.")
        elif chosen_backend_type == 'lamb':
            lamb_server_url = getattr(config_model, 'lamb_url', 'http://lamb-server:8000')
            if actual_address:
                backend_instance = AsyncLambBackend(address=actual_address, url=lamb_server_url, timeout_ms=actual_timeout)
            elif hasattr(config_model, "model") and hasattr(config_model, "serial_number"):
                backend_instance = AsyncLambBackend(
                    address=None,
                    url=lamb_server_url,
                    timeout_ms=actual_timeout,
                    model_name=getattr(config_model, "model"),
                    serial_number=getattr(config_model, "serial_number")
                )
            else:
                raise InstrumentConfigurationError(
                    config_source,
                    "Lamb backend requires either an address or both model and serial_number in the config.",
                )
            if debug_mode:
                print(f"Using AsyncLambBackend for model='{getattr(config_model, 'model', None)}', serial='{getattr(config_model, 'serial_number', None)}' via '{lamb_server_url}' with timeout {actual_timeout}ms.")
        else:
            raise InstrumentConfigurationError(
                config_source, f"Unsupported backend_type '{chosen_backend_type}'."
            )

    # Step 5: Instantiate the final instrument driver class
    device_type_str: str = config_model.device_type
    instrument_class_to_init = cls._instrument_mapping.get(device_type_str.lower())

    if instrument_class_to_init is None:
        raise InstrumentConfigurationError(
            config_source,
            f"Unknown device_type: '{device_type_str}'. No registered instrument class.",
        )

    # The instrument's constructor receives the parsed configuration model and the
    # instantiated backend.
    instrument = instrument_class_to_init(config=config_model, backend=backend_instance)

    if debug_mode:
        print(f"Instantiated {instrument_class_to_init.__name__} with {type(backend_instance).__name__}.")
        print("Note: Backend connection is not established by __init__. Call 'await instrument.connect_backend()' explicitly.")

    return instrument</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.AutoInstrument.AutoInstrument.from_type" class="doc doc-heading">
            <code class="highlight language-python">from_type(instrument_type, *args, **kwargs)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Initializes a specific instrument driver based on its type string.</p>
<p>This factory method uses a mapping to find the appropriate instrument class
for a given <code>instrument_type</code> string (e.g., 'oscilloscope') and passes
any additional arguments to its constructor.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>instrument_type</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The type of the instrument to initialize.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>*args</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>Positional arguments to pass to the instrument's constructor.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Any">Any</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>()</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>Keyword arguments to pass to the instrument's constructor.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Any">Any</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>{}</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>An instance of a specific Instrument subclass.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentConfigurationError(instrument=None, message='')" href="../errors/#pytestlab.errors.InstrumentConfigurationError">InstrumentConfigurationError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the instrument_type is not recognized.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/AutoInstrument.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
def from_type(cls: Type[AutoInstrument], instrument_type: str, *args: Any, **kwargs: Any) -&gt; Instrument:
    """Initializes a specific instrument driver based on its type string.

    This factory method uses a mapping to find the appropriate instrument class
    for a given `instrument_type` string (e.g., 'oscilloscope') and passes
    any additional arguments to its constructor.

    Args:
        instrument_type: The type of the instrument to initialize.
        *args: Positional arguments to pass to the instrument's constructor.
        **kwargs: Keyword arguments to pass to the instrument's constructor.

    Returns:
        An instance of a specific Instrument subclass.

    Raises:
        InstrumentConfigurationError: If the instrument_type is not recognized.
    """
    instrument_class = cls._instrument_mapping.get(instrument_type.lower())
    if instrument_class:
        return instrument_class(*args, **kwargs) # type: ignore
    else:
        raise InstrumentConfigurationError(
            instrument_type, f"Unknown instrument type: {instrument_type}"
        )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.AutoInstrument.AutoInstrument.get_config_from_cdn" class="doc doc-heading">
            <code class="highlight language-python">get_config_from_cdn(identifier)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Fetches an instrument configuration from a CDN with local caching.</p>
<p>This method attempts to retrieve a configuration file from a predefined
CDN URL. For efficiency, it caches the configuration locally. If a cached
version is available, it's used directly. Otherwise, the file is
downloaded, cached for future use, and then returned.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>identifier</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The unique identifier for the configuration, which is
        used to construct the CDN URL (e.g., 'keysight/dsox1204g').</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]</code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The loaded configuration data as a dictionary.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><span title="FileNotFoundError">FileNotFoundError</span></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the configuration is not found on the CDN.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentConfigurationError(instrument=None, message='')" href="../errors/#pytestlab.errors.InstrumentConfigurationError">InstrumentConfigurationError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the downloaded configuration is invalid.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/AutoInstrument.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
async def get_config_from_cdn(cls: Type[AutoInstrument], identifier: str) -&gt; Dict[str, Any]:
    """Fetches an instrument configuration from a CDN with local caching.

    This method attempts to retrieve a configuration file from a predefined
    CDN URL. For efficiency, it caches the configuration locally. If a cached
    version is available, it's used directly. Otherwise, the file is
    downloaded, cached for future use, and then returned.

    Args:
        identifier: The unique identifier for the configuration, which is
                    used to construct the CDN URL (e.g., 'keysight/dsox1204g').

    Returns:
        The loaded configuration data as a dictionary.

    Raises:
        FileNotFoundError: If the configuration is not found on the CDN.
        InstrumentConfigurationError: If the downloaded configuration is invalid.
    """
    import pytestlab as ptl

    cache_dir = os.path.join(os.path.dirname(ptl.__file__), "cache", "configs")
    os.makedirs(cache_dir, exist_ok=True)

    cache_file = os.path.join(cache_dir, f"{identifier}.yaml")

    # Check for a cached version of the configuration first
    if os.path.exists(cache_file):
        try:
            async with aiofiles.open(cache_file, 'r') as f:
                content = await f.read()
                loaded_config = yaml.safe_load(content)
                # Validate the cached content; if corrupt, proceed to download
                if not isinstance(loaded_config, dict):
                    os.remove(cache_file)
                    raise InstrumentConfigurationError(
                        identifier, "Cached config is not a valid dictionary."
                    )
                return loaded_config
        except Exception as e:
            # If reading the cache fails, remove the broken file and fetch from CDN
            print(f"Cache read failed for {identifier}: {e}. Fetching from CDN.")
            if os.path.exists(cache_file):
                try:
                    os.remove(cache_file)
                except OSError:
                    pass

    # If not cached, fetch from the official CDN
    url = f"https://pytestlab.org/config/{identifier}.yaml"
    async with httpx.AsyncClient() as client:
        try:
            response = await client.get(url, timeout=10)
            response.raise_for_status()  # Raise an exception for bad status codes

            config_text = response.text
            loaded_config = yaml.safe_load(config_text)
            if not isinstance(loaded_config, dict):
                raise InstrumentConfigurationError(
                    identifier,
                    f"CDN config for {identifier} is not a valid dictionary.",
                )

            # Cache the newly downloaded configuration
            async with aiofiles.open(cache_file, 'w') as f:
                await f.write(config_text)

            return loaded_config
        except httpx.HTTPStatusError as http_err:
            # Handle HTTP errors, specifically 404 for not found
            if http_err.response.status_code == 404:
                 raise FileNotFoundError(f"Configuration file not found at {url} (HTTP 404).") from http_err
            else:
                 raise FileNotFoundError(f"Failed to fetch configuration from CDN ({url}): HTTP {http_err.response.status_code}") from http_err
        except httpx.RequestError as e:
            # Handle network-related errors
            raise FileNotFoundError(f"Failed to fetch configuration from CDN ({url}): {str(e)}") from e
        except yaml.YAMLError as ye:
            # Handle errors in parsing the YAML content
            raise InstrumentConfigurationError(
                identifier, f"Error parsing YAML from CDN for {identifier}: {ye}"
            ) from ye</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.AutoInstrument.AutoInstrument.get_config_from_local" class="doc doc-heading">
            <code class="highlight language-python">get_config_from_local(identifier, normalized_identifier=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Loads an instrument configuration from the local filesystem.</p>
<p>This method searches for a configuration file in two primary locations:
1. A built-in 'profiles' directory within the PyTestLab package.
2. A direct file path provided by the user.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>identifier</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The identifier for the profile (e.g., 'keysight/dsox1204g')
        or a direct path to a .yaml or .json file.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>normalized_identifier</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>A pre-normalized version of the identifier.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]</code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The loaded configuration data as a dictionary.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><span title="FileNotFoundError">FileNotFoundError</span></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If no configuration file can be found at any of the
               searched locations.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentConfigurationError(instrument=None, message='')" href="../errors/#pytestlab.errors.InstrumentConfigurationError">InstrumentConfigurationError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the file is found but is not a valid
                          YAML/JSON dictionary.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/AutoInstrument.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
async def get_config_from_local(cls: Type[AutoInstrument], identifier: str, normalized_identifier: Optional[str] = None) -&gt; Dict[str, Any]:
    """Loads an instrument configuration from the local filesystem.

    This method searches for a configuration file in two primary locations:
    1. A built-in 'profiles' directory within the PyTestLab package.
    2. A direct file path provided by the user.

    Args:
        identifier: The identifier for the profile (e.g., 'keysight/dsox1204g')
                    or a direct path to a .yaml or .json file.
        normalized_identifier: A pre-normalized version of the identifier.

    Returns:
        The loaded configuration data as a dictionary.

    Raises:
        FileNotFoundError: If no configuration file can be found at any of the
                           searched locations.
        InstrumentConfigurationError: If the file is found but is not a valid
                                      YAML/JSON dictionary.
    """
    import pytestlab as ptl

    norm_id = normalized_identifier if normalized_identifier is not None else os.path.normpath(identifier)

    current_file_directory = os.path.dirname(ptl.__file__)
    preset_path = os.path.join(current_file_directory, "profiles", norm_id + '.yaml')

    # Determine the correct file path to load from
    path_to_try: Optional[str] = None
    if os.path.exists(preset_path):
        # First, check for a built-in profile matching the identifier
        path_to_try = preset_path
    elif os.path.exists(identifier) and (identifier.endswith('.yaml') or identifier.endswith('.json')):
        # Next, check if the identifier is a direct path to an existing file
        path_to_try = identifier

    if path_to_try:
        try:
            async with aiofiles.open(path_to_try, 'r') as file:
                content = await file.read()
                loaded_config = yaml.safe_load(content)
                if not isinstance(loaded_config, dict):
                    raise InstrumentConfigurationError(
                        identifier,
                        f"Local config file '{path_to_try}' did not load as a dictionary.",
                    )
                return loaded_config
        except yaml.YAMLError as ye:
            raise InstrumentConfigurationError(
                identifier,
                f"Error parsing YAML from local file '{path_to_try}': {ye}",
            ) from ye
        except Exception as e:
            raise FileNotFoundError(f"Error reading local config file '{path_to_try}': {e}") from e

    raise FileNotFoundError(f"No configuration found for identifier '{identifier}' in local paths.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.AutoInstrument.AutoInstrument.register_instrument" class="doc doc-heading">
            <code class="highlight language-python">register_instrument(instrument_type, instrument_class)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Dynamically registers a new custom instrument class.</p>
<p>This allows users to extend PyTestLab with their own instrument drivers.
Once registered, the new instrument type can be used with the factory
methods like <code>from_config</code> and <code>from_type</code>.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>instrument_type</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The string identifier for the new instrument type
             (e.g., 'my_custom_scope'). This is case-insensitive.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>instrument_class</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The class object that implements the instrument driver.
              It must be a subclass of <code>pytestlab.Instrument</code>.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Type">Type</span>[<a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a>[<span title="typing.Any">Any</span>]]</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentConfigurationError(instrument=None, message='')" href="../errors/#pytestlab.errors.InstrumentConfigurationError">InstrumentConfigurationError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the instrument type name is already
                          in use or if the provided class is not a
                          valid subclass of <code>Instrument</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/AutoInstrument.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
def register_instrument(cls: Type[AutoInstrument], instrument_type: str, instrument_class: Type[Instrument[Any]]) -&gt; None:
    """Dynamically registers a new custom instrument class.

    This allows users to extend PyTestLab with their own instrument drivers.
    Once registered, the new instrument type can be used with the factory
    methods like `from_config` and `from_type`.

    Args:
        instrument_type: The string identifier for the new instrument type
                         (e.g., 'my_custom_scope'). This is case-insensitive.
        instrument_class: The class object that implements the instrument driver.
                          It must be a subclass of `pytestlab.Instrument`.

    Raises:
        InstrumentConfigurationError: If the instrument type name is already
                                      in use or if the provided class is not a
                                      valid subclass of `Instrument`.
    """
    type_key = instrument_type.lower() 
    if type_key in cls._instrument_mapping:
        raise InstrumentConfigurationError(
            instrument_type,
            f"Instrument type '{instrument_type}' already registered with class {cls._instrument_mapping[type_key].__name__}",
        )
    if not issubclass(instrument_class, Instrument):
        raise InstrumentConfigurationError(
            instrument_type,
            f"Cannot register class {instrument_class.__name__}. It must be a subclass of Instrument.",
        )
    cls._instrument_mapping[type_key] = instrument_class
    # Consider using a logger if available, instead of print
    print(f"Instrument type '{instrument_type}' registered with class {instrument_class.__name__}.")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>
<h3 id="pytestlab.instruments.AutoInstrument-functions">Functions</h3>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h2 id="pytestlab.instruments.Instrument" class="doc doc-heading">
              <code class="highlight language-python">pytestlab.instruments.Instrument(config, backend, **kwargs)</code>

</h2>


    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="typing.Generic">Generic</span>[<span title="pytestlab.instruments.instrument.ConfigType">ConfigType</span>]</code></p>


        <p>Base class for all instrument drivers.</p>
<p>This class provides the core functionality for interacting with an instrument
through a standardized, asynchronous interface. It handles command sending,
querying, error checking, and logging. It is designed to be subclassed for
specific instrument types (e.g., Oscilloscope, PowerSupply).</p>
<p>The <code>Instrument</code> class is generic and typed with <code>ConfigType</code>, which allows
each subclass to specify its own Pydantic configuration model.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="config = config

  
      instance-attribute
   (pytestlab.instruments.Instrument.config)" href="#pytestlab.instruments.Instrument.config">config</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The Pydantic configuration model instance for this
                 instrument.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="pytestlab.instruments.instrument.ConfigType">ConfigType</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="pytestlab.instruments.Instrument._backend">_backend</span></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The communication backend used to interact
                          with the hardware or simulation.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="pytestlab.instruments.instrument.AsyncInstrumentIO">AsyncInstrumentIO</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="pytestlab.instruments.Instrument._command_log">_command_log</span></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>A log of all commands sent and
                                 responses received.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="List">List</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="pytestlab.instruments.Instrument._logger">_logger</span></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The logger instance for this instrument.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Any">Any</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>

        <p>Initialize the Instrument class.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>config</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>Configuration for the instrument.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="pytestlab.instruments.instrument.ConfigType">ConfigType</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>backend</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The communication backend instance.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="pytestlab.instruments.instrument.AsyncInstrumentIO">AsyncInstrumentIO</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>**kwargs</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>Additional keyword arguments.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Any">Any</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>{}</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO
    """
    Initialize the Instrument class.

    Args:
        config (ConfigType): Configuration for the instrument.
        backend (AsyncInstrumentIO): The communication backend instance.
        **kwargs: Additional keyword arguments.
    """
    if not isinstance(config, InstrumentConfig): # Check against the bound base
        raise InstrumentConfigurationError(
            self.__class__.__name__,
            f"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.",
        )

    self.config = config
    self._backend = backend # This will be an AsyncInstrumentIO instance
    self._command_log = []

    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__
    self._logger = get_logger(logger_name)

    self._logger.info(f"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.")</code></pre>
                  </details>



  <div class="doc doc-children">





<h3 id="pytestlab.instruments.Instrument-attributes">Attributes</h3>

<div class="doc doc-object doc-attribute">



<h4 id="pytestlab.instruments.Instrument.config" class="doc doc-heading">
            <code class="highlight language-python">config = config</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

    </div>

</div>

<h3 id="pytestlab.instruments.Instrument-functions">Functions</h3>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.clear_status" class="doc doc-heading">
            <code class="highlight language-python">clear_status()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Clears the instrument's status registers and error queue (*CLS).</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def clear_status(self) -&gt; None:
    """
    Clears the instrument's status registers and error queue (*CLS).
    """
    await self._send_command("*CLS", skip_check=True)
    self._logger.debug("Status registers and error queue cleared (*CLS).")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.close" class="doc doc-heading">
            <code class="highlight language-python">close()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Close the connection to the instrument via the backend.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def close(self) -&gt; None:
    """Close the connection to the instrument via the backend."""
    try:
        model_name_for_logger = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__
        self._logger.info(f"Instrument '{model_name_for_logger}': Closing connection.")
        await self._backend.close() # Changed to use close as per AsyncInstrumentIO
        self._logger.info(f"Instrument '{model_name_for_logger}': Connection closed.")
    except Exception as e:
        self._logger.error(f"Instrument '{model_name_for_logger}': Error during backend close: {e}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.connect_backend" class="doc doc-heading">
            <code class="highlight language-python">connect_backend()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Establishes the connection to the instrument via the backend.</p>
<p>This method must be called after the instrument is instantiated to open
the communication channel. It delegates the connection logic to the
underlying backend.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentConnectionError(instrument=None, message='')" href="../errors/#pytestlab.errors.InstrumentConnectionError">InstrumentConnectionError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the backend fails to connect.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def connect_backend(self) -&gt; None:
    """Establishes the connection to the instrument via the backend.

    This method must be called after the instrument is instantiated to open
    the communication channel. It delegates the connection logic to the
    underlying backend.

    Raises:
        InstrumentConnectionError: If the backend fails to connect.
    """
    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__
    try:
        await self._backend.connect()
        self._logger.info(f"Instrument '{logger_name}': Backend connected.")
    except Exception as e:
        self._logger.error(f"Instrument '{logger_name}': Failed to connect backend: {e}")
        if hasattr(self._backend, 'disconnect'): # Check if disconnect is available (it should be for AsyncInstrumentIO)
            try:
                await self._backend.disconnect()
            except Exception as disc_e:
                self._logger.error(f"Instrument '{logger_name}': Error disconnecting backend during failed connect: {disc_e}")
        raise InstrumentConnectionError(
            instrument=logger_name, message=f"Failed to connect backend: {e}"
        ) from e</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.from_config" class="doc doc-heading">
            <code class="highlight language-python">from_config(config, debug_mode=False)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
def from_config(cls: Type[Instrument], config: InstrumentConfig, debug_mode: bool = False) -&gt; Instrument:
    # This method will likely need significant changes to support async backends.
    # For now, it's a placeholder and might not work correctly with async backends.
    # It should ideally accept an async_mode flag or similar to determine backend type.
    if not isinstance(config, InstrumentConfig):
        raise InstrumentConfigurationError(
            cls.__name__, "from_config expects an InstrumentConfig object."
        )
    # The backend instantiation is missing here and is crucial.
    # This will be handled by AutoInstrument.from_config later.
    raise NotImplementedError(
        "from_config needs to be updated for async backend instantiation."
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.get_all_errors" class="doc doc-heading">
            <code class="highlight language-python">get_all_errors()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Reads and clears all errors currently present in the instrument's error queue.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_all_errors(self) -&gt; TypingList[Tuple[int, str]]:
    """
    Reads and clears all errors currently present in the instrument's error queue.
    """
    errors: TypingList[Tuple[int, str]] = []
    max_errors_to_read = 50
    for i in range(max_errors_to_read):
        try:
            code, message = await self.get_error()
        except InstrumentCommunicationError as e:
            self._logger.debug(f"Communication error while reading error queue (iteration {i+1}): {e}")
            if errors:
                 self._logger.debug(f"Returning errors read before communication failure: {errors}")
            return errors

        if code == 0:
            break
        errors.append((code, message))
        if code == -350:
             self._logger.debug("Error queue overflow (-350) detected. Stopping read.")
             break
    else:
        self._logger.debug(f"Warning: Read {max_errors_to_read} errors without reaching 'No error'. "
                  "Error queue might still contain errors or be in an unexpected state.")

    if not errors:
        self._logger.debug("No errors found in instrument queue.")
    else:
         self._logger.debug(f"Retrieved {len(errors)} error(s) from queue: {errors}")
    return errors</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.get_communication_timeout" class="doc doc-heading">
            <code class="highlight language-python">get_communication_timeout()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Gets the communication timeout from the backend.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_communication_timeout(self) -&gt; int:
    """Gets the communication timeout from the backend."""
    timeout = await self._backend.get_timeout()
    self._logger.debug(f"Communication timeout retrieved from backend: {timeout} ms.")
    return timeout</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.get_error" class="doc doc-heading">
            <code class="highlight language-python">get_error()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Reads and clears the oldest error from the instrument's error queue.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_error(self) -&gt; Tuple[int, str]:
    """
    Reads and clears the oldest error from the instrument's error queue.
    """
    response = (await self._query("SYSTem:ERRor?")).strip()
    try:
        code_str, msg_part = response.split(',', 1)
        code = int(code_str)
        message = msg_part.strip().strip('"')
    except (ValueError, IndexError) as e:
        self._logger.debug(f"Warning: Unexpected error response format: '{response}'. Raising error.")
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command="SYSTem:ERRor?",
            message=f"Could not parse error response: '{response}'",
        ) from e

    if code != 0:
         self._logger.debug(f"Instrument Error Query: Code={code}, Message='{message}'")
    return code, message</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.get_scpi_version" class="doc doc-heading">
            <code class="highlight language-python">get_scpi_version()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Queries the version of the SCPI standard the instrument complies with.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_scpi_version(self) -&gt; str:
    """
    Queries the version of the SCPI standard the instrument complies with.
    """
    response = (await self._query("SYSTem:VERSion?")).strip()
    self._logger.debug(f"SCPI Version reported: {response}")
    return response</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.health_check" class="doc doc-heading">
            <code class="highlight language-python">health_check()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Performs a basic health check of the instrument.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">@abstractmethod
async def health_check(self) -&gt; HealthReport: # Type hint HealthReport
    """Performs a basic health check of the instrument."""
    # Base implementation could try IDN and error queue check
    # report = HealthReport() # Initialize HealthReport
    # try:
    #     report.instrument_idn = await self.id() # Ensure await for async calls
    #     instrument_errors = await self.get_all_errors() # Ensure await for async calls
    #     if instrument_errors:
    #         report.warnings.extend([f"Stored Error: {code} - {msg}" for code, msg in instrument_errors])
    #
    #     if not report.errors and not report.warnings:
    #          report.status = HealthStatus.OK
    #     elif report.warnings and not report.errors:
    #          report.status = HealthStatus.WARNING
    #     else: # if errors are present
    #          report.status = HealthStatus.ERROR
    #
    # except Exception as e:
    #     report.status = HealthStatus.ERROR
    #     report.errors.append(f"Health check failed during IDN/Error Query: {str(e)}")
    # return report
    pass # Replace with actual base implementation</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.id" class="doc doc-heading">
            <code class="highlight language-python">id()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Query the instrument for its identification string (*IDN?).</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def id(self) -&gt; str:
    """
    Query the instrument for its identification string (*IDN?).
    """
    name = await self._query("*IDN?")
    self._logger.debug(f"Connected to {name}")
    return name</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.lock_panel" class="doc doc-heading">
            <code class="highlight language-python">lock_panel(lock=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Locks or unlocks the front panel of the instrument.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def lock_panel(self, lock: bool = True) -&gt; None:
    """
    Locks or unlocks the front panel of the instrument.
    """
    if lock:
        await self._send_command(":SYSTem:LOCK")
    else:
        await self._send_command(":SYSTem:LOCal")
    self._logger.debug(f"Panel {'locked' if lock else 'unlocked (local control enabled)'}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.requires" class="doc doc-heading">
            <code class="highlight language-python">requires(requirement)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Decorator to specify method requirements based on instrument configuration.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
def requires(cls, requirement: str) -&gt; Callable:
    """
    Decorator to specify method requirements based on instrument configuration.
    """
    def decorator(func: Callable) -&gt; Callable:
        def wrapped_func(self: Instrument, *args: Any, **kwargs: Any) -&gt; Any:
            if not hasattr(self.config, 'requires') or not callable(self.config.requires):
                raise InstrumentConfigurationError(
                    self.config.model,
                    "Config object missing 'requires' method for decorator.",
                )

            if self.config.requires(requirement):
                return func(self, *args, **kwargs)
            else:
                raise InstrumentConfigurationError(
                    self.config.model,
                    f"Method '{func.__name__}' requires '{requirement}', which is not available for this instrument model/configuration.",
                )
        return wrapped_func
    return decorator</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.reset" class="doc doc-heading">
            <code class="highlight language-python">reset()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Reset the instrument to its default settings (*RST).</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def reset(self) -&gt; None:
    """Reset the instrument to its default settings (*RST)."""
    await self._send_command("*RST")
    self._logger.debug("Instrument reset to default settings (*RST).")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.run_self_test" class="doc doc-heading">
            <code class="highlight language-python">run_self_test(full_test=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Executes the instrument's internal self-test routine (*TST?) and reports result.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def run_self_test(self, full_test: bool = True) -&gt; str:
    """
    Executes the instrument's internal self-test routine (*TST?) and reports result.
    """
    if not full_test:
         self._logger.debug("Note: `full_test=False` currently ignored, running standard *TST? self-test.")

    self._logger.debug("Running self-test (*TST?)...")
    try:
         result_str = await self._query("*TST?")
         code = int(result_str.strip())
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command="*TST?",
            message=f"Unexpected non-integer response: '{result_str}'",
        )
    except InstrumentCommunicationError as e:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command="*TST?",
            message="Failed to execute query.",
        ) from e

    if code == 0:
        self._logger.debug("Self-test query (*TST?) returned 0 (Passed).")
        errors_after_test = await self.get_all_errors()
        if errors_after_test:
             details = "; ".join([f"{c}: {m}" for c, m in errors_after_test])
             warn_msg = f"Self-test query passed, but errors found in queue afterwards: {details}"
             self._logger.debug(warn_msg)
        return "Passed"
    else:
        self._logger.debug(f"Self-test query (*TST?) returned non-zero code: {code} (Failed). Reading error queue...")
        errors = await self.get_all_errors()
        details = "; ".join([f"{c}: {m}" for c, m in errors]) if errors else 'No specific errors reported in queue'
        fail_msg = f"Failed: Code {code}. Errors: {details}"
        self._logger.debug(fail_msg)
        return fail_msg</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.set_communication_timeout" class="doc doc-heading">
            <code class="highlight language-python">set_communication_timeout(timeout_ms)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Sets the communication timeout on the backend.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_communication_timeout(self, timeout_ms: int) -&gt; None:
    """Sets the communication timeout on the backend."""
    await self._backend.set_timeout(timeout_ms)
    self._logger.debug(f"Communication timeout set to {timeout_ms} ms on backend.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.Instrument.wait_for_operation_complete" class="doc doc-heading">
            <code class="highlight language-python">wait_for_operation_complete(query_instrument=True, timeout=10.0)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Waits for the instrument to finish all pending overlapping commands.
The 'timeout' parameter's effect depends on the backend's query timeout settings.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
              <pre class="highlight"><code class="language-python">async def wait_for_operation_complete(self, query_instrument: bool = True, timeout: float = 10.0) -&gt; Optional[str]:
    """
    Waits for the instrument to finish all pending overlapping commands.
    The 'timeout' parameter's effect depends on the backend's query timeout settings.
    """
    if query_instrument:
        # The original logic for setting/restoring instrument.timeout has been removed
        # as the _Backend protocol does not define a timeout attribute.
        # The 'timeout' argument of this method might influence a timeout if the
        # _query method or backend implementation uses it, but _query currently
        # passes 'delay', not 'timeout'. For *OPC?, no delay is typically needed.
        # The backend's own communication timeout will apply to the query.
        self._logger.debug(f"Waiting for operation complete (*OPC?). Effective timeout depends on backend (method timeout hint: {timeout}s).")
        try:
            # The timeout parameter of this method is not directly passed to _query here.
            # _query's delay parameter is for a different purpose.
            response = await self._query("*OPC?") # This now uses self._backend.query
            self._logger.debug("Operation complete query (*OPC?) returned.")
            if response.strip() != "1":
                self._logger.debug(f"Warning: *OPC? returned '{response}' instead of expected '1'.")
            return response.strip()
        except InstrumentCommunicationError as e:
            # The 'timeout' parameter of this method is noted here for context.
            err_msg = f"*OPC? query failed. This may be due to backend communication timeout (related to method's timeout param: {timeout}s)."
            self._logger.debug(err_msg)
            raise InstrumentCommunicationError(
                instrument=self.config.model, command="*OPC?", message=err_msg
            ) from e
        # 'finally' block for restoring timeout removed.
    else:
        await self._send_command("*OPC") # This now uses self._backend.write
        self._logger.debug("Operation complete command (*OPC) sent (non-blocking). Status polling required.")
        return None</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div><hr />
<h2 id="supported-instrument-types">Supported Instrument Types</h2>
<h3 id="oscilloscope">Oscilloscope</h3>


<div class="doc doc-object doc-module">



<h2 id="pytestlab.instruments.Oscilloscope" class="doc doc-heading">
            <code>pytestlab.instruments.Oscilloscope</code>


</h2>

    <div class="doc doc-contents first">









  <div class="doc doc-children">






<h3 id="pytestlab.instruments.Oscilloscope-classes">Classes</h3>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Oscilloscope.ChannelReadingResult" class="doc doc-heading">
              <code class="highlight language-python">ChannelReadingResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.experiments.results.MeasurementResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs) (pytestlab.experiments.MeasurementResult)" href="../experiments/#pytestlab.experiments.results.MeasurementResult">MeasurementResult</a></code></p>


        <p>A result class for oscilloscope channel readings (time, voltage, etc).</p>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/experiments/results.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat],
             instrument: str,
             units: str,
             measurement_type: str,
             timestamp: Optional[float] = None, # Allow optional timestamp override
             envelope: Optional[Dict[str, Any]] = None, # Add envelope as an explicit argument
             sampling_rate: Optional[float] = None, # Add sampling_rate for FFT
             **kwargs: Any) -&gt; None: # Added **kwargs and type hint
    self.values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat] = values
    self.units: str = units
    self.instrument: str = instrument
    self.measurement_type: str = measurement_type
    self.timestamp: float = timestamp if timestamp is not None else time.time()
    # Envelope logic: always provide an envelope attribute
    if envelope is not None:
        self.envelope = envelope
    else:
        # Default: minimal valid envelope (empty dict, or customize as needed)
        self.envelope = {}

    # Store sampling rate for FFT calculations
    self.sampling_rate = sampling_rate

    # Store any additional kwargs as attributes
    for key, value in kwargs.items():
        setattr(self, key, value)</code></pre>
                  </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Oscilloscope.FFTResult" class="doc doc-heading">
              <code class="highlight language-python">FFTResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.experiments.results.MeasurementResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs) (pytestlab.experiments.MeasurementResult)" href="../experiments/#pytestlab.experiments.results.MeasurementResult">MeasurementResult</a></code></p>


        <p>A result class for FFT data from the oscilloscope.</p>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/experiments/results.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat],
             instrument: str,
             units: str,
             measurement_type: str,
             timestamp: Optional[float] = None, # Allow optional timestamp override
             envelope: Optional[Dict[str, Any]] = None, # Add envelope as an explicit argument
             sampling_rate: Optional[float] = None, # Add sampling_rate for FFT
             **kwargs: Any) -&gt; None: # Added **kwargs and type hint
    self.values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat] = values
    self.units: str = units
    self.instrument: str = instrument
    self.measurement_type: str = measurement_type
    self.timestamp: float = timestamp if timestamp is not None else time.time()
    # Envelope logic: always provide an envelope attribute
    if envelope is not None:
        self.envelope = envelope
    else:
        # Default: minimal valid envelope (empty dict, or customize as needed)
        self.envelope = {}

    # Store sampling rate for FFT calculations
    self.sampling_rate = sampling_rate

    # Store any additional kwargs as attributes
    for key, value in kwargs.items():
        setattr(self, key, value)</code></pre>
                  </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Oscilloscope.FRanalysisResult" class="doc doc-heading">
              <code class="highlight language-python">FRanalysisResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.experiments.results.MeasurementResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs) (pytestlab.experiments.MeasurementResult)" href="../experiments/#pytestlab.experiments.results.MeasurementResult">MeasurementResult</a></code></p>


        <p>A result class for frequency response analysis data.</p>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/experiments/results.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat],
             instrument: str,
             units: str,
             measurement_type: str,
             timestamp: Optional[float] = None, # Allow optional timestamp override
             envelope: Optional[Dict[str, Any]] = None, # Add envelope as an explicit argument
             sampling_rate: Optional[float] = None, # Add sampling_rate for FFT
             **kwargs: Any) -&gt; None: # Added **kwargs and type hint
    self.values: Union[np.ndarray, pl.DataFrame, np.float64, TypingList[Any], UFloat] = values
    self.units: str = units
    self.instrument: str = instrument
    self.measurement_type: str = measurement_type
    self.timestamp: float = timestamp if timestamp is not None else time.time()
    # Envelope logic: always provide an envelope attribute
    if envelope is not None:
        self.envelope = envelope
    else:
        # Default: minimal valid envelope (empty dict, or customize as needed)
        self.envelope = {}

    # Store sampling rate for FFT calculations
    self.sampling_rate = sampling_rate

    # Store any additional kwargs as attributes
    for key, value in kwargs.items():
        setattr(self, key, value)</code></pre>
                  </details>



  <div class="doc doc-children">











  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Oscilloscope.Oscilloscope" class="doc doc-heading">
              <code class="highlight language-python">Oscilloscope(config, debug_mode=False, simulate=False, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a>[<a class="autorefs autorefs-internal" title="pytestlab.config.oscilloscope_config.OscilloscopeConfig" href="../config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig">OscilloscopeConfig</a>]</code></p>


        <p>Drives a digital oscilloscope for waveform acquisition and measurement.</p>
<p>This class provides a comprehensive, high-level interface for controlling an
oscilloscope. It builds upon the base <code>Instrument</code> class and adds extensive
functionality specific to oscilloscopes.</p>
<p>Key features include:
- Facade-based interfaces for channels, trigger, and acquisition for cleaner code.
- Methods for reading waveforms, performing automated measurements (e.g., Vpp, Vrms).
- Support for advanced features like FFT and Frequency Response Analysis (FRA).
- Built-in waveform generator control if the hardware supports it.
- Screenshot capability.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="config

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Oscilloscope.config)" href="#pytestlab.instruments.Oscilloscope.Oscilloscope.config">config</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The Pydantic configuration object (<code>OscilloscopeConfig</code>)
    containing settings specific to this oscilloscope.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><a class="autorefs autorefs-internal" title="pytestlab.config.oscilloscope_config.OscilloscopeConfig" href="../config/#pytestlab.config.oscilloscope_config.OscilloscopeConfig">OscilloscopeConfig</a></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="trigger = ScopeTriggerFacade(self)

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Oscilloscope.trigger)" href="#pytestlab.instruments.Oscilloscope.Oscilloscope.trigger">trigger</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>A <code>ScopeTriggerFacade</code> for configuring trigger settings.</p>
              </div>
              <p>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="acquisition = ScopeAcquisitionFacade(self)

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Oscilloscope.acquisition)" href="#pytestlab.instruments.Oscilloscope.Oscilloscope.acquisition">acquisition</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>A <code>ScopeAcquisitionFacade</code> for acquisition system settings.</p>
              </div>
              <p>
              </p>
            </td>
          </tr>
      </tbody>
    </table>

        <p>Initialize the Oscilloscope class with the given VISA resource and profile information.</p>
<p>Args:
config (OscilloscopeConfig): Configuration object for the oscilloscope.
debug_mode (bool): Enable debug mode. (Handled by base or backend)
simulate (bool): Enable simulation mode. (Handled by base or backend)</p>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, config: OscilloscopeConfig, debug_mode: bool = False, simulate: bool = False, **kwargs: Any) -&gt; None: # config is now non-optional
    """
    Initialize the Oscilloscope class with the given VISA resource and profile information.

    Args:
    config (OscilloscopeConfig): Configuration object for the oscilloscope.
    debug_mode (bool): Enable debug mode. (Handled by base or backend)
    simulate (bool): Enable simulation mode. (Handled by base or backend)
    """
    # The config is already validated by the loader to be OscilloscopeConfig V2
    super().__init__(config=config, debug_mode=debug_mode, simulate=simulate, **kwargs) # Pass kwargs
    # Initialize facades
    self.trigger = ScopeTriggerFacade(self)
    self.acquisition = ScopeAcquisitionFacade(self)</code></pre>
                  </details>



  <div class="doc doc-children">





<h5 id="pytestlab.instruments.Oscilloscope.Oscilloscope-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.acquisition" class="doc doc-heading">
            <code class="highlight language-python">acquisition = ScopeAcquisitionFacade(self)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.config" class="doc doc-heading">
            <code class="highlight language-python">config</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.trigger" class="doc doc-heading">
            <code class="highlight language-python">trigger = ScopeTriggerFacade(self)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.Oscilloscope.Oscilloscope-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.auto_scale" class="doc doc-heading">
            <code class="highlight language-python">auto_scale()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Auto scale the oscilloscope display.</p>
<p>This method sends an SCPI command to the oscilloscope to auto scale the display.</p>
<p>Example:</p>
<blockquote>
<blockquote>
<blockquote>
<p>auto_scale()</p>
</blockquote>
</blockquote>
</blockquote>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def auto_scale(self) -&gt; None:
    """
    Auto scale the oscilloscope display.

    This method sends an SCPI command to the oscilloscope to auto scale the display.

    Example:
    &gt;&gt;&gt; auto_scale()
    """
    await self._send_command(":AUToscale")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.channel" class="doc doc-heading">
            <code class="highlight language-python">channel(ch_num)</code>

</h6>


    <div class="doc doc-contents ">

        <p>Returns a facade for interacting with a specific channel.</p>
<p>This method provides a convenient, chainable interface for controlling a
single oscilloscope channel.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>ch_num</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel number (1-based).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><a class="autorefs autorefs-internal" title="ScopeChannelFacade(scope, channel_num) (pytestlab.instruments.Oscilloscope.ScopeChannelFacade)" href="#pytestlab.instruments.Oscilloscope.ScopeChannelFacade">ScopeChannelFacade</a></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>A <code>ScopeChannelFacade</code> object for the specified channel.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the channel number is invalid.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
def channel(self, ch_num: int) -&gt; ScopeChannelFacade:
    """Returns a facade for interacting with a specific channel.

    This method provides a convenient, chainable interface for controlling a
    single oscilloscope channel.

    Args:
        ch_num: The channel number (1-based).

    Returns:
        A `ScopeChannelFacade` object for the specified channel.

    Raises:
        InstrumentParameterError: If the channel number is invalid.
    """
    if not self.config.channels or not (1 &lt;= ch_num &lt;= len(self.config.channels)):
        num_conf_ch = len(self.config.channels) if self.config.channels else 0
        raise InstrumentParameterError(
            parameter="ch_num",
            value=ch_num,
            valid_range=(1, num_conf_ch),
            message="Channel number is out of range.",
        )
    return ScopeChannelFacade(self, ch_num)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.configure_fft" class="doc doc-heading">
            <code class="highlight language-python">configure_fft(source_channel, scale=None, offset=None, span=None, window_type='HANNing', units='DECibel', display=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configure the oscilloscope to perform an FFT on the specified channel.</p>
<p>:param source_channel: The channel number to perform FFT on.
:param scale: The vertical scale of the FFT display. Instrument specific.
:param offset: The vertical offset of the FFT display. Instrument specific.
:param span: The frequency span for the FFT. Instrument specific.
:param window_type: The windowing function. Case-insensitive. From config.fft.window_types.
:param units: The unit for FFT magnitude. Case-insensitive. From config.fft.units.
:param display: True to turn FFT display ON, False for OFF.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("fft")
async def configure_fft(self, source_channel: int, scale: Optional[float] = None, offset: Optional[float] = None, span: Optional[float] = None,  window_type: str = 'HANNing', units: str = 'DECibel', display: bool = True) -&gt; None:
    """
    Configure the oscilloscope to perform an FFT on the specified channel.

    :param source_channel: The channel number to perform FFT on.
    :param scale: The vertical scale of the FFT display. Instrument specific.
    :param offset: The vertical offset of the FFT display. Instrument specific.
    :param span: The frequency span for the FFT. Instrument specific.
    :param window_type: The windowing function. Case-insensitive. From config.fft.window_types.
    :param units: The unit for FFT magnitude. Case-insensitive. From config.fft.units.
    :param display: True to turn FFT display ON, False for OFF.
    """
    if self.config.fft is None:
        raise InstrumentConfigurationError(
            self.config.model, "FFT not configured for this instrument."
        )
    if not (1 &lt;= source_channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="source_channel",
            value=source_channel,
            valid_range=(1, len(self.config.channels)),
            message="Source channel number is out of range.",
        )

    # Validate window_type against config.fft.window_types (List[str])
    # Assuming window_type parameter is the SCPI string itself
    if window_type.upper() not in [wt.upper() for wt in self.config.fft.window_types]:
        raise InstrumentParameterError(
            parameter="window_type",
            value=window_type,
            valid_range=self.config.fft.window_types,
            message="Unsupported FFT window type.",
        )
    scpi_window = window_type

    # Validate units against config.fft.units (List[str])
    if units.upper() not in [u.upper() for u in self.config.fft.units]:
        raise InstrumentParameterError(
            parameter="units",
            value=units,
            valid_range=self.config.fft.units,
            message="Unsupported FFT units.",
        )
    scpi_units = units

    await self._send_command(f':FFT:SOURce1 CHANnel{source_channel}')
    await self._send_command(f':FFT:WINDow {scpi_window}')

    if span is not None:
        await self._send_command(f':FFT:SPAn {span}')

    await self._send_command(f':FFT:VTYPe {scpi_units}')

    if scale is not None:
        await self._send_command(f':FFT:SCALe {scale}')

    if offset is not None:
        await self._send_command(f':FFT:OFFSet {offset}')

    scpi_display_state = SCPIOnOff.ON.value if display else SCPIOnOff.OFF.value
    await self._send_command(f':FFT:DISPlay {scpi_display_state}')

    self._logger.debug(f"FFT configured for channel {source_channel}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.configure_trigger" class="doc doc-heading">
            <code class="highlight language-python">configure_trigger(channel, level, source=None, trigger_type='HIGH', slope=TriggerSlope.POSITIVE, mode='EDGE')</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the trigger for the oscilloscope.</p>
<p>:param channel: The channel to set the trigger for (used if source is None or a channel itself)
:param level: The trigger level in volts
:param source: The source of the trigger. Default behaviour is to use the channel. Valid options CHANnel<n> | EXTernal | LINE | WGEN
:param trigger_type: The type of trigger. Default is 'HIGH' (Note: this param seems unused in current logic for level setting)
:param slope: The slope of the trigger. Default is TriggerSlope.POSITIVE
:param mode: The trigger mode. Default is 'EDGE'</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def configure_trigger(self, channel: int, level: float, source: Optional[str] = None, trigger_type: str = "HIGH", slope: TriggerSlope = TriggerSlope.POSITIVE, mode: str = "EDGE") -&gt; None:
    """
    Sets the trigger for the oscilloscope.

    :param channel: The channel to set the trigger for (used if source is None or a channel itself)
    :param level: The trigger level in volts
    :param source: The source of the trigger. Default behaviour is to use the channel. Valid options CHANnel&lt;n&gt; | EXTernal | LINE | WGEN
    :param trigger_type: The type of trigger. Default is 'HIGH' (Note: this param seems unused in current logic for level setting)
    :param slope: The slope of the trigger. Default is TriggerSlope.POSITIVE
    :param mode: The trigger mode. Default is 'EDGE'
    """

    if not (1 &lt;= channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="channel",
            value=channel,
            valid_range=(1, len(self.config.channels)),
            message="Primary channel number is out of range.",
        )

    actual_source: str
    if source is None:
        actual_source = f"CHANnel{channel}"
    else:
        actual_source = source.upper()
        # Check if source is a channel (handle CH1, CHAN1, CHANNEL1 formats)
        if actual_source.startswith("CH"):
            try:
                num_str = "".join(filter(str.isdigit, actual_source))
                if not num_str:
                    raise ValueError("No digits found in channel source string")
                source_channel_to_validate = int(num_str)
                if not (1 &lt;= source_channel_to_validate &lt;= len(self.config.channels)):
                    raise InstrumentParameterError(
                        parameter="source",
                        value=source,
                        valid_range=(1, len(self.config.channels)),
                        message="Source channel number is out of range.",
                    )
                # Normalize the channel source to CHANNEL format for SCPI command
                actual_source = f"CHANnel{source_channel_to_validate}"
            except (ValueError, IndexError) as e:
                raise InstrumentParameterError(
                    parameter="source",
                    value=source,
                    message="Invalid channel format in source.",
                ) from e
        elif actual_source not in ["EXTERNAL", "LINE", "WGEN"]:
            raise InstrumentParameterError(
                parameter="source",
                value=source,
                valid_range=["EXTernal", "LINE", "WGEN"],
                message="Invalid source.",
            )

    await self._send_command(f':TRIG:SOUR {actual_source}')
    await self._send_command(f':TRIGger:LEVel {level}, CHANnel{channel}')

    if slope.value not in self.config.trigger.slopes:
        raise InstrumentParameterError(
            parameter="slope",
            value=slope.value,
            valid_range=self.config.trigger.slopes,
            message="Unsupported trigger slope.",
        )
    scpi_slope = slope.value

    if mode.upper() not in [m.upper() for m in self.config.trigger.modes]: # Case-insensitive check
         self._logger.warning(f"Trigger mode '{mode}' not in configured supported modes: {self.config.trigger.modes}. Passing directly to instrument.")
    scpi_mode = mode

    await self._send_command(f':TRIGger:SLOPe {scpi_slope}')
    await self._send_command(f':TRIGger:MODE {scpi_mode}')
    await self._wait()

    self._logger.debug(f"""Trigger set with the following parameters:
              Trigger Source: {actual_source}
              Trigger Level for CHAN{channel}: {level}
              Trigger Slope: {scpi_slope}
              Trigger Mode: {scpi_mode}""")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.display_channel" class="doc doc-heading">
            <code class="highlight language-python">display_channel(channels, state=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Display or hide the specified channel(s) on the oscilloscope.</p>
<p>Args:
channels (Union[int, List[int]]): A single channel number or a list of channel numbers.
state (bool): True to display (ON), False to hide (OFF). Default is True.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def display_channel(self, channels: Union[int, List[int]], state: bool = True) -&gt; None:
    """
    Display or hide the specified channel(s) on the oscilloscope.

    Args:
    channels (Union[int, List[int]]): A single channel number or a list of channel numbers.
    state (bool): True to display (ON), False to hide (OFF). Default is True.
    """
    ch_list: List[int]
    if isinstance(channels, int):
        ch_list = [channels]
    elif isinstance(channels, list) and all(isinstance(ch, int) for ch in channels):
        ch_list = channels
    else:
        # validate_call should catch this if type hints are precise enough
        raise InstrumentParameterError(
            message="channels must be an int or a list of ints"
        )

    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value
    for ch_num in ch_list:
        if not (1 &lt;= ch_num &lt;= len(self.config.channels)):
            raise InstrumentParameterError(
                parameter="channels",
                value=ch_num,
                valid_range=(1, len(self.config.channels)),
                message="Channel number is out of range.",
            )
        await self._send_command(f"CHANnel{ch_num}:DISPlay {scpi_state}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.fft_display" class="doc doc-heading">
            <code class="highlight language-python">fft_display(state=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Switches on or off the FFT display.</p>
<p>:param state: True to enable FFT display, False to disable.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("fft")
async def fft_display(self, state: bool = True) -&gt; None:
    """
    Switches on or off the FFT display.

    :param state: True to enable FFT display, False to disable.
    """
    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value
    await self._send_command(f":FFT:DISPlay {scpi_state}")
    self._logger.debug(f"FFT display {'enabled' if state else 'disabled'}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.franalysis_sweep" class="doc doc-heading">
            <code class="highlight language-python">franalysis_sweep(input_channel, output_channel, start_freq, stop_freq, amplitude, points=10, trace='none', load='onemeg', disable_on_complete=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Perform a frequency response analysis sweep.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>FRanalysisResult</code>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>Containing the frequency response analysis data.</p>
              </div>
                <p>
                  <span class="doc-returns-annotation">
                    <b>TYPE:</b>
                      <code><a class="autorefs autorefs-internal" title="FRanalysisResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs) (pytestlab.instruments.Oscilloscope.FRanalysisResult)" href="#pytestlab.instruments.Oscilloscope.FRanalysisResult">FRanalysisResult</a></code>
                  </span>
                </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("franalysis")
#@ConfigRequires("function_generator")
async def franalysis_sweep(self, input_channel: int, output_channel: int, start_freq: float, stop_freq: float, amplitude: float, points: int = 10, trace: str = "none", load: str = "onemeg", disable_on_complete: bool = True) -&gt; FRanalysisResult:
    """
    Perform a frequency response analysis sweep.

    Returns:
        FRanalysisResult: Containing the frequency response analysis data.
    """
    if self.config.function_generator is None or self.config.franalysis is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator or FRANalysis not configured."
        )

    if not (1 &lt;= input_channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="input_channel",
            value=input_channel,
            valid_range=(1, len(self.config.channels)),
            message="Input channel is out of range.",
        )
    if not (1 &lt;= output_channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="output_channel",
            value=output_channel,
            valid_range=(1, len(self.config.channels)),
            message="Output channel is out of range.",
        )

    # Ensure points is at least 2 for a valid sweep
    if points &lt; 2:
        raise InstrumentParameterError(
            parameter="points",
            value=points,
            valid_range=(2, "inf"),
            message="Points for sweep must be at least 2.",
        )

    # SCPI commands for frequency response analysis sweep
    await self._send_command(f":FUNCtion:FRANalysis")
    await self._send_command(f":FREQuency:START {start_freq}")
    await self._send_command(f":FREQuency:STOP {stop_freq}")
    await self._send_command(f":AMPLitude {amplitude}")
    await self._send_command(f":POINTS {points}")
    await self._send_command(f":TRACe:FEED {trace}")
    await self._send_command(f":LOAD {load}")

    if disable_on_complete:
        await self._send_command(":DISABLE")

    # Optionally wait for completion or check status
    await self._wait()  # Ensure to wait for the command to complete

    # Assuming the result can be fetched with a common query, adjust as necessary
    result_data = await self._query(":FETCH:FRANalysis?")

    # Parse the result data into a structured format if needed
    # For now, let's assume it's a simple comma-separated value string
    parsed_results = [float(val) for val in result_data.split(',')]

    # Create a DataFrame or structured result object
    # Assuming two columns: Frequency and Magnitude
    freq_values = parsed_results[0::2]  # Extracting frequency values
    mag_values = parsed_results[1::2]   # Extracting magnitude values

    return FRanalysisResult(
        instrument=self.config.model,
        units="",
        measurement_type="FrequencyResponse",
        values=pl.DataFrame({
            "Frequency (Hz)": freq_values,
            "Magnitude": mag_values
        })
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.from_config" class="doc doc-heading">
            <code class="highlight language-python">from_config(config, debug_mode=False, **kwargs)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
def from_config(cls: Type['Oscilloscope'], config: OscilloscopeConfig, debug_mode: bool = False, **kwargs: Any) -&gt; 'Oscilloscope':
    # This method aligns with the new __init__ signature.
    return cls(config=config, debug_mode=debug_mode, **kwargs)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.function_display" class="doc doc-heading">
            <code class="highlight language-python">function_display(state=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Switches on or off the function display (e.g. Math or WGEN waveform).</p>
<p>:param state: True to enable display, False to disable.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def function_display(self, state: bool = True) -&gt; None:
    """
    Switches on or off the function display (e.g. Math or WGEN waveform).

    :param state: True to enable display, False to disable.
    """
    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value
    await self._send_command(f":FUNCtion:DISPlay {scpi_state}")
    self._logger.debug(f"Function display {'enabled' if state else 'disabled'}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.get_channel_axis" class="doc doc-heading">
            <code class="highlight language-python">get_channel_axis(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Gets the channel axis of the oscilloscope. (y-axis)</p>
<p>:param channel: The channel to get the axis for
:return: A list containing the channel axis scale and offset</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_channel_axis(self, channel: int) -&gt; List[float]:
    """
    Gets the channel axis of the oscilloscope. (y-axis)

    :param channel: The channel to get the axis for
    :return: A list containing the channel axis scale and offset
    """
    if not (1 &lt;= channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="channel",
            value=channel,
            valid_range=(1, len(self.config.channels)),
            message="Channel number is out of range.",
        )

    scale_str: str = await self._query(f":CHANnel{channel}:SCALe?")
    offset_str: str = await self._query(f":CHANnel{channel}:OFFSet?")
    return [np.float64(scale_str), np.float64(offset_str)]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.get_probe_attenuation" class="doc doc-heading">
            <code class="highlight language-python">get_probe_attenuation(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Gets the probe attenuation for a given channel.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The oscilloscope channel to get the probe attenuation for.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>str</code>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The probe attenuation value (e.g., '10:1', '1:1').</p>
              </div>
                <p>
                  <span class="doc-returns-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
                </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_probe_attenuation(self, channel: int) -&gt; str: # Returns string like "10:1"
    """
    Gets the probe attenuation for a given channel.

    Parameters:
        channel (int): The oscilloscope channel to get the probe attenuation for.

    Returns:
        str: The probe attenuation value (e.g., '10:1', '1:1').
    """
    if not (1 &lt;= channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="channel",
            value=channel,
            valid_range=(1, len(self.config.channels)),
            message="Channel number is out of range.",
        )
    response_str: str = (await self._query(f"CHANnel{channel}:PROBe?")).strip()
    # Assuming response is the numeric factor (e.g., "10", "1")
    try:
        # Ensure it's a number before formatting
        num_factor = float(response_str)
        if num_factor.is_integer():
            return f"{int(num_factor)}:1"
        return f"{num_factor}:1"
    except ValueError:
        self._logger.warning(f"Could not parse probe attenuation factor '{response_str}' as number. Returning raw.")
        return response_str # Or raise error</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.get_sampling_rate" class="doc doc-heading">
            <code class="highlight language-python">get_sampling_rate()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Get the current sampling rate of the oscilloscope.
Returns:
    float: The sampling rate in Hz.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_sampling_rate(self) -&gt; float:
    """
    Get the current sampling rate of the oscilloscope.
    Returns:
        float: The sampling rate in Hz.
    """
    response_str: str = await self._query(":ACQuire:SRATe?")
    sampling_rate_float: float = np.float64(response_str)
    return sampling_rate_float</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.get_time_axis" class="doc doc-heading">
            <code class="highlight language-python">get_time_axis()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Gets the time axis of the oscilloscope. (x-axis)</p>
<p>:return: A list containing the time axis scale and position</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_time_axis(self) -&gt; List[float]:
    """
    Gets the time axis of the oscilloscope. (x-axis)

    :return: A list containing the time axis scale and position
    """
    scale_str: str = await self._query(":TIMebase:SCALe?")
    position_str: str = await self._query(":TIMebase:POSition?")
    return [np.float64(scale_str), np.float64(position_str)]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.health_check" class="doc doc-heading">
            <code class="highlight language-python">health_check()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Performs a basic health check of the oscilloscope instrument.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>HealthReport</code>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>A report containing the instrument's health status,
          errors, warnings, and supported features.</p>
              </div>
                <p>
                  <span class="doc-returns-annotation">
                    <b>TYPE:</b>
                      <code><a class="autorefs autorefs-internal" title="HealthReport (pytestlab.common.health.HealthReport)" href="../common/#pytestlab.common.health.HealthReport">HealthReport</a></code>
                  </span>
                </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">async def health_check(self) -&gt; HealthReport:
    """
    Performs a basic health check of the oscilloscope instrument.

    Returns:
        HealthReport: A report containing the instrument's health status,
                      errors, warnings, and supported features.
    """
    report = HealthReport()

    try:
        # Get instrument identification
        report.instrument_idn = await self.id()

        # Check for stored errors
        instrument_errors = await self.get_all_errors()
        if instrument_errors:
            report.warnings.extend([f"Stored Error: {code} - {msg}" for code, msg in instrument_errors])

        # Set initial status based on errors
        if not report.errors and not report.warnings:
            report.status = HealthStatus.OK
        elif report.warnings and not report.errors:
            report.status = HealthStatus.WARNING
        else:
            report.status = HealthStatus.ERROR

    except Exception as e:
        report.status = HealthStatus.ERROR
        report.errors.append(f"Health check failed during IDN/Error Query: {str(e)}")

    try:
        # Test basic oscilloscope functionality
        _ = await self.get_time_axis()

        # Check supported features based on configuration
        if hasattr(self.config, 'fft') and self.config.fft:
            report.supported_features["fft"] = True
        else:
            report.supported_features["fft"] = False

        if hasattr(self.config, 'franalysis') and self.config.franalysis:
            report.supported_features["franalysis"] = True
        else:
            report.supported_features["franalysis"] = False

        if hasattr(self.config, 'function_generator') and self.config.function_generator:
            report.supported_features["function_generator"] = True
        else:
            report.supported_features["function_generator"] = False

    except Exception as e:
        report.errors.append(f"Oscilloscope-specific check failed: {str(e)}")

    # Determine backend status
    if hasattr(self, '_backend') and hasattr(self._backend, '__class__'):
        backend_name = self._backend.__class__.__name__
        if "SimBackend" in backend_name:
            report.backend_status = "Simulated"
        elif "VisaBackend" in backend_name:
            report.backend_status = "VISA Connection"
        elif "LambInstrument" in backend_name or "LambBackend" in backend_name:
            report.backend_status = "Lamb Connection"
        else:
            report.backend_status = f"Unknown backend: {backend_name}"
    else:
        report.backend_status = "Backend information unavailable"

    # Final status evaluation
    if report.errors and report.status != HealthStatus.ERROR:
        report.status = HealthStatus.ERROR
    elif report.warnings and report.status == HealthStatus.OK:
        report.status = HealthStatus.WARNING

    # If no errors or warnings after all checks, and status is still UNKNOWN, set to OK
    if report.status == HealthStatus.UNKNOWN and not report.errors and not report.warnings:
        report.status = HealthStatus.OK

    return report</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.lock_panel" class="doc doc-heading">
            <code class="highlight language-python">lock_panel(lock=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Locks the panel of the instrument</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>lock</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>True to lock the panel, False to unlock it</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="bool">bool</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>True</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def lock_panel(self, lock: bool = True) -&gt; None:
    """
    Locks the panel of the instrument

    Args:
        lock (bool): True to lock the panel, False to unlock it
    """
    scpi_state = SCPIOnOff.ON.value if lock else SCPIOnOff.OFF.value
    await self._send_command(f":SYSTem:LOCK {scpi_state}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.measure_rms_voltage" class="doc doc-heading">
            <code class="highlight language-python">measure_rms_voltage(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Measure the root-mean-square (RMS) voltage for a specified channel.</p>
<p>Args:
channel (int): The channel identifier.</p>
<p>Returns:
MeasurementResult: An object containing the RMS voltage measurement.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def measure_rms_voltage(self, channel: int) -&gt; MeasurementResult:
    """
    Measure the root-mean-square (RMS) voltage for a specified channel.

    Args:
    channel (int): The channel identifier.

    Returns:
    MeasurementResult: An object containing the RMS voltage measurement.
    """
    if not (1 &lt;= channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="channel",
            value=channel,
            valid_range=(1, len(self.config.channels)),
            message="Channel number is out of range.",
        )

    response_str: str = await self._query(f"MEAS:VRMS? CHAN{channel}")
    reading: float = float(response_str)

    value_to_return: float | UFloat = reading

    if self.config.measurement_accuracy:
        mode_key = f"vrms_ch{channel}"
        self._logger.debug(f"Attempting to find accuracy spec for Vrms on channel {channel} with key: '{mode_key}'")
        spec = self.config.measurement_accuracy.get(mode_key)
        if spec:
            sigma = spec.calculate_std_dev(reading, range_value=None)
            if sigma &gt; 0:
                value_to_return = ufloat(reading, sigma)
                self._logger.debug(f"Applied accuracy spec '{mode_key}', value: {value_to_return}")
            else:
                self._logger.debug(f"Accuracy spec '{mode_key}' resulted in sigma=0. Returning float.")
        else:
            self._logger.debug(f"No accuracy spec found for Vrms on channel {channel} with key '{mode_key}'. Returning float.")
    else:
        self._logger.debug(f"No measurement_accuracy configuration in instrument for Vrms on channel {channel}. Returning float.")

    self._logger.debug(f"RMS Voltage (Channel {channel}): {value_to_return}")

    measurement_result = MeasurementResult(
        values=value_to_return,
        instrument=self.config.model,
        units="V",
        measurement_type="rms_voltage"
    )
    return measurement_result</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.measure_voltage_peak_to_peak" class="doc doc-heading">
            <code class="highlight language-python">measure_voltage_peak_to_peak(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Measure the peak-to-peak voltage for a specified channel.</p>
<p>Args:
channel (int): The channel identifier.</p>
<p>Returns:
MeasurementResult: An object containing the peak-to-peak voltage measurement.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def measure_voltage_peak_to_peak(self, channel: int) -&gt; MeasurementResult:
    """
    Measure the peak-to-peak voltage for a specified channel.

    Args:
    channel (int): The channel identifier.

    Returns:
    MeasurementResult: An object containing the peak-to-peak voltage measurement.
    """
    if not (1 &lt;= channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="channel",
            value=channel,
            valid_range=(1, len(self.config.channels)),
            message="Channel number is out of range.",
        )

    response_str: str = await self._query(f"MEAS:VPP? CHAN{channel}")
    reading: float = float(response_str)

    value_to_return: float | UFloat = reading

    if self.config.measurement_accuracy:
        mode_key = f"vpp_ch{channel}"
        self._logger.debug(f"Attempting to find accuracy spec for Vpp on channel {channel} with key: '{mode_key}'")
        spec = self.config.measurement_accuracy.get(mode_key)
        if spec:
            sigma = spec.calculate_std_dev(reading, range_value=None)
            if sigma &gt; 0:
                value_to_return = ufloat(reading, sigma)
                self._logger.debug(f"Applied accuracy spec '{mode_key}', value: {value_to_return}")
            else:
                self._logger.debug(f"Accuracy spec '{mode_key}' resulted in sigma=0. Returning float.")
        else:
            self._logger.debug(f"No accuracy spec found for Vpp on channel {channel} with key '{mode_key}'. Returning float.")
    else:
        self._logger.debug(f"No measurement_accuracy configuration in instrument for Vpp on channel {channel}. Returning float.")

    measurement_result = MeasurementResult(
        values=value_to_return,
        units="V",
        instrument=self.config.model,
        measurement_type="P2PV"
    )

    self._logger.debug(f"Peak to Peak Voltage (Channel {channel}): {value_to_return}")

    return measurement_result</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.read_channels" class="doc doc-heading">
            <code class="highlight language-python">read_channels(*channels, points=None, run_after=True, timebase=None, **kwargs)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Reads and processes waveform data from one or more channels.</p>
<p>This is a primary data acquisition method. It triggers an acquisition,
reads the raw data for the specified channels, and uses the preamble
to convert the data into a <code>ChannelReadingResult</code> containing properly
scaled time and voltage values in a Polars DataFrame.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>*channels</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>A variable number of channel numbers (e.g., <code>read_channels(1, 2)</code>)
       or a single list/tuple of channels (e.g., <code>read_channels([1, 2])</code>).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="typing.List">List</span>[<span title="int">int</span>], <span title="typing.Tuple">Tuple</span>[<span title="int">int</span>, ...]]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>()</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>points</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>Deprecated. The number of points is determined by the timebase
    and instrument settings.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>run_after</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>This parameter is currently unused.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="bool">bool</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>True</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>timebase</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>If provided, sets the time-per-division for this acquisition.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><a class="autorefs autorefs-internal" title="ChannelReadingResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs) (pytestlab.instruments.Oscilloscope.ChannelReadingResult)" href="#pytestlab.instruments.Oscilloscope.ChannelReadingResult">ChannelReadingResult</a></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>A <code>ChannelReadingResult</code> containing the waveform data.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If channel numbers are invalid or not provided.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><span title="pytestlab.errors.InstrumentDataError">InstrumentDataError</span></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If time values cannot be generated.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def read_channels(self, *channels: Union[int, List[int], Tuple[int, ...]], points: Optional[int] = None, run_after: bool = True, timebase: Optional[float] = None, **kwargs) -&gt; ChannelReadingResult:
    """Reads and processes waveform data from one or more channels.

    This is a primary data acquisition method. It triggers an acquisition,
    reads the raw data for the specified channels, and uses the preamble
    to convert the data into a `ChannelReadingResult` containing properly
    scaled time and voltage values in a Polars DataFrame.

    Args:
        *channels: A variable number of channel numbers (e.g., `read_channels(1, 2)`)
                   or a single list/tuple of channels (e.g., `read_channels([1, 2])`).
        points: Deprecated. The number of points is determined by the timebase
                and instrument settings.
        run_after: This parameter is currently unused.
        timebase: If provided, sets the time-per-division for this acquisition.

    Returns:
        A `ChannelReadingResult` containing the waveform data.

    Raises:
        InstrumentParameterError: If channel numbers are invalid or not provided.
        InstrumentDataError: If time values cannot be generated.
    """
    if 'runAfter' in kwargs:
        warnings.warn(
            "'runAfter' is deprecated, use 'run_after' instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        run_after = kwargs['runAfter']

    processed_channels: List[int]
    if not channels:
        raise InstrumentParameterError(message="No channels specified.")

    first_arg = channels[0]
    if isinstance(first_arg, (list, tuple)) and len(channels) == 1:
        if not all(isinstance(ch_num, int) for ch_num in first_arg):
            raise InstrumentParameterError(
                message="All elements in channel list/tuple must be integers."
            )
        processed_channels = list(first_arg)
    elif all(isinstance(ch_num, int) for ch_num in channels): # type: ignore [arg-type]
        processed_channels = list(channels) # type: ignore [assignment]
    else:
        raise InstrumentParameterError(
            message="Invalid channel arguments. Must be integers or a single list/tuple of integers."
        )

    if not processed_channels:
        raise InstrumentParameterError(
            message="No channels specified in the list/tuple."
        )

    if timebase is not None:
        current_time_axis = await self.get_time_axis()
        await self.set_time_axis(scale=timebase, position=current_time_axis[1])

    if points is not None:
        self._logger.debug(f"Points argument is deprecated (value: {points}). Use set_time_axis instead.")


    self._logger.debug("starting channel read")

    for ch_num_val in processed_channels:
        if not (1 &lt;= ch_num_val &lt;= len(self.config.channels)):
            raise InstrumentParameterError(
                parameter="channels",
                value=ch_num_val,
                valid_range=(1, len(self.config.channels)),
                message="Channel number is out of range.",
            )


    sampling_rate_float: float = float(await self.get_sampling_rate())
    channel_commands_str: str = ', '.join(f"CHANnel{ch}" for ch in processed_channels)

    acq_type_enum_or_str = await self.acquisition.get_acquisition_type()

    is_average_mode = False
    if isinstance(acq_type_enum_or_str, AcquisitionType):
        is_average_mode = acq_type_enum_or_str == AcquisitionType.AVERAGE
    elif isinstance(acq_type_enum_or_str, str):
        is_average_mode = acq_type_enum_or_str.upper() == "AVERAGE"

    # Handle different acquisition modes. Averaging mode often requires a
    # special command sequence to ensure the requested number of averages
    # are acquired before the data is read.
    if is_average_mode:
        self._logger.debug("AVERAGE acquisition type detected - using special sequence")
        avg_count_int: int = await self.acquisition.get_acquisition_average_count()
        self._logger.debug(f"Current average count: {avg_count_int}")
        await self._send_command(":ACQuire:COMPlete 100") # Ensure all averages are processed
        await self._send_command(":STOP")
        await self._wait()

        # Force a new acquisition sequence for averaging
        sweep_orig_str: str = (await self._query(":TRIGger:SWEep?")).strip()
        await self._send_command(":TRIGger:SWEep AUTO")
        await self._send_command(f"DIGitize {channel_commands_str}", skip_check=True)
        await self._send_command(":TRIGger:FORCe", skip_check=True)
        await self._send_command("*OPC")
        self._logger.debug("Waiting for acquisition to complete …")
        await self._wait()
        await self._send_command(":TRIGger:FORCe", skip_check=True)
        self._logger.debug("Waiting for acquisition to complete …")
        await self._wait()
        await self._send_command(f":TRIGger:SWEep {sweep_orig_str}", skip_check=True)
        await self.clear_status()
    else:
        # For other modes, a simple DIGitize command is sufficient.
        await self._send_command(f"DIGitize {channel_commands_str}")

    await self._send_command(f':WAVeform:SOURce CHANnel{processed_channels[0]}')
    await self._send_command(':WAVeform:FORMat BYTE')
    await self._send_command(':WAVeform:POINts:MODE RAW')

    pream: Preamble = await self._read_preamble()

    time_values_np: Optional[np.ndarray] = None
    measurement_results_dict: Dict[str, np.ndarray] = {}

    # Loop through each requested channel to read its data
    for ch_num_loop in processed_channels:
        raw_wave_data = await self._read_wave_data(f"CHANnel{ch_num_loop}")
        # Convert raw ADC values to volts using the preamble data
        voltages_np: np.ndarray = (raw_wave_data - pream.yref) * pream.yinc + pream.yorg

        # Generate the corresponding time axis array, but only once.
        if time_values_np is None:
            n_pts_int: int = len(voltages_np)
            time_values_np = (np.arange(n_pts_int) - pream.xref) * pream.xinc + pream.xorg

        measurement_results_dict[f"Channel {ch_num_loop} (V)"] = voltages_np

    if time_values_np is None:
        raise InstrumentDataError(
            self.config.model, "Time values were not generated during channel read."
        )

    return ChannelReadingResult(
       instrument=self.config.model,
       units="V",
       measurement_type="ChannelVoltageTime",
       sampling_rate=sampling_rate_float,
       values=pl.DataFrame({
            "Time (s)": time_values_np,
            **measurement_results_dict
       })
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.read_fft_data" class="doc doc-heading">
            <code class="highlight language-python">read_fft_data(channel, window='hann')</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Acquires time-domain data for the specified channel and computes the FFT using
the analysis submodule.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel number to perform FFT on.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>window</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The windowing function to apply before FFT
                     (e.g., 'hann', 'hamming', None).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>&#39;hann&#39;</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>FFTResult</code>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>An object containing the computed FFT data (frequency and linear magnitude).</p>
              </div>
                <p>
                  <span class="doc-returns-annotation">
                    <b>TYPE:</b>
                      <code><a class="autorefs autorefs-internal" title="FFTResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs) (pytestlab.instruments.Oscilloscope.FFTResult)" href="#pytestlab.instruments.Oscilloscope.FFTResult">FFTResult</a></code>
                  </span>
                </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def read_fft_data(self, channel: int, window: Optional[str] = 'hann') -&gt; FFTResult:
    """
    Acquires time-domain data for the specified channel and computes the FFT using
    the analysis submodule.

    Args:
        channel (int): The channel number to perform FFT on.
        window (Optional[str]): The windowing function to apply before FFT
                                 (e.g., 'hann', 'hamming', None).

    Returns:
        FFTResult: An object containing the computed FFT data (frequency and linear magnitude).
    """
    self._logger.debug(f"Initiating FFT computation for channel {channel} using analysis module.")

    if not (1 &lt;= channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="channel",
            value=channel,
            valid_range=(1, len(self.config.channels)),
            message="Channel number is out of range.",
        )

    # 1. Acquire raw time-domain waveform data
    waveform_data: ChannelReadingResult = await self.read_channels(channel)

    if waveform_data.values is None or waveform_data.values.is_empty():
        self._logger.warning(f"No waveform data acquired for channel {channel}. Cannot compute FFT.")
        # Return an empty FFTResult or raise an error
        return FFTResult(
            instrument=self.config.model,
            units="Linear",
            measurement_type="FFT_computed_python",
            values=pl.DataFrame({
                "Frequency (Hz)": np.array([]),
                "Magnitude (Linear)": np.array([])
            })
        )

    time_array = waveform_data.values["Time (s)"].to_numpy()
    voltage_column_name = f"Channel {channel} (V)"
    if voltage_column_name not in waveform_data.values.columns:
        raise InstrumentDataError(
            self.config.model,
            f"Could not find voltage data for channel {channel} in waveform results.",
        )
    voltage_array = waveform_data.values[voltage_column_name].to_numpy()

    # 2. Call the appropriate function from pytestlab.analysis.fft
    frequency_array, magnitude_array = analysis_fft.compute_fft(
        time_array=time_array,
        voltage_array=voltage_array,
        window=window
    )

    # 3. Return or further process the results
    return FFTResult(
        instrument=self.config.model,
        units="Linear", # compute_fft returns linear magnitude
        measurement_type="FFT_computed_python",
        values=pl.DataFrame({
            "Frequency (Hz)": frequency_array,
            "Magnitude (Linear)": magnitude_array
        })
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.screenshot" class="doc doc-heading">
            <code class="highlight language-python">screenshot()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Capture a screenshot of the oscilloscope display.</p>
<p>:return Image: A PIL Image object containing the screenshot.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def screenshot(self) -&gt; Image.Image:
    """
    Capture a screenshot of the oscilloscope display.

    :return Image: A PIL Image object containing the screenshot.
    """
    binary_data_response: bytes = await self._query_raw(":DISPlay:DATA? PNG, COLor")

    if not binary_data_response.startswith(b'#'):
        raise InstrumentDataError(
            self.config.model, "Invalid screenshot data format: does not start with #"
        )

    length_of_length_field: int = int(chr(binary_data_response[1]))
    png_data_length_str: str = binary_data_response[2 : 2 + length_of_length_field].decode('ascii')
    png_data_length: int = int(png_data_length_str)
    png_data_start_index: int = 2 + length_of_length_field
    image_data_bytes: bytes = binary_data_response[png_data_start_index : png_data_start_index + png_data_length]

    return Image.open(BytesIO(image_data_bytes))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_acquisition_time" class="doc doc-heading">
            <code class="highlight language-python">set_acquisition_time(time)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Set the total acquisition time for the oscilloscope.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>time</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The total acquisition time in seconds.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_acquisition_time(self, time: float) -&gt; None:
    """
    Set the total acquisition time for the oscilloscope.

    Args:
        time (float): The total acquisition time in seconds.
    """
    await self._send_command(f":TIMebase:MAIN:RANGe {time}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_bandwidth_limit" class="doc doc-heading">
            <code class="highlight language-python">set_bandwidth_limit(channel, bandwidth)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the bandwidth limit for a specified channel.
Args:
    channel (int): The channel number.
    bandwidth (Union[str, float]): The bandwidth limit (e.g., "20M", 20e6, or "FULL").</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_bandwidth_limit(self, channel: int, bandwidth: Union[str, float]) -&gt; None:
    """
    Sets the bandwidth limit for a specified channel.
    Args:
        channel (int): The channel number.
        bandwidth (Union[str, float]): The bandwidth limit (e.g., "20M", 20e6, or "FULL").
    """
    if not (1 &lt;= channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="channel",
            value=channel,
            valid_range=(1, len(self.config.channels)),
            message="Channel number is out of range.",
        )
    await self._send_command(f"CHANnel{channel}:BANDwidth {bandwidth}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_channel_axis" class="doc doc-heading">
            <code class="highlight language-python">set_channel_axis(channel, scale, offset)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the channel axis of the oscilloscope. (y-axis)</p>
<p>:param channel: The channel to set
:param scale: The scale of the channel axis in volts
:param offset: The offset of the channel in volts</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_channel_axis(self, channel: int, scale: float, offset: float) -&gt; None:
    """
    Sets the channel axis of the oscilloscope. (y-axis)

    :param channel: The channel to set
    :param scale: The scale of the channel axis in volts
    :param offset: The offset of the channel in volts
    """
    if not (1 &lt;= channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="channel",
            value=channel,
            valid_range=(1, len(self.config.channels)),
            message="Channel number is out of range.",
        )

    await self._send_command(f':CHANnel{channel}:SCALe {scale}')
    await self._send_command(f':CHANnel{channel}:OFFSet {offset}')
    await self._wait()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_probe_attenuation" class="doc doc-heading">
            <code class="highlight language-python">set_probe_attenuation(channel, scale)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the probe scale for a given channel.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The oscilloscope channel to set the scale for.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>scale</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The probe scale value (e.g., 10 for 10:1, 1 for 1:1).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_probe_attenuation(self, channel: int, scale: int) -&gt; None:
    """
    Sets the probe scale for a given channel.

    Parameters:
        channel (int): The oscilloscope channel to set the scale for.
        scale (int): The probe scale value (e.g., 10 for 10:1, 1 for 1:1).
    """
    if not (1 &lt;= channel &lt;= len(self.config.channels)):
        raise InstrumentParameterError(
            parameter="channel",
            value=channel,
            valid_range=(1, len(self.config.channels)),
            message="Channel number is out of range.",
        )

    channel_model_config = self.config.channels[channel - 1]
    if scale not in channel_model_config.probe_attenuation: # probe_attenuation is List[int]
        raise InstrumentParameterError(
            parameter="scale",
            value=scale,
            valid_range=channel_model_config.probe_attenuation,
            message=f"Scale not in supported probe_attenuation list for channel {channel}.",
        )

    # SCPI command usually takes the numeric factor directly
    await self._send_command(f":CHANnel{channel}:PROBe {scale}")
    self._logger.debug(f"Set probe scale to {scale}:1 for channel {channel}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_sample_rate" class="doc doc-heading">
            <code class="highlight language-python">set_sample_rate(rate)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the sample rate for the oscilloscope.</p>
<p>Args:
rate (str): The desired sample rate. Valid values are 'MAX' and 'AUTO'. Case-insensitive.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_sample_rate(self, rate: str) -&gt; None:
    """
    Sets the sample rate for the oscilloscope.

    Args:
    rate (str): The desired sample rate. Valid values are 'MAX' and 'AUTO'. Case-insensitive.
    """
    rate_upper: str = rate.upper()
    valid_values: List[str] = ["MAX", "AUTO"] # These are common SCPI values
    if rate_upper not in valid_values:
        raise InstrumentParameterError(
            parameter="rate",
            value=rate,
            valid_range=valid_values,
            message="Invalid rate.",
        )
    await self._send_command(f"ACQuire:SRATe {rate_upper}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_time_axis" class="doc doc-heading">
            <code class="highlight language-python">set_time_axis(scale, position)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the time axis of the Oscilloscope. (x-axis)</p>
<p>:param scale: scale The scale of the axis in seconds
:param position: The position of the time axis from the trigger in seconds</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_time_axis(self, scale: float, position: float) -&gt; None:
    """
    Sets the time axis of the Oscilloscope. (x-axis)

    :param scale: scale The scale of the axis in seconds
    :param position: The position of the time axis from the trigger in seconds
    """

    await self._send_command(f':TIMebase:SCALe {scale}')
    await self._send_command(f':TIMebase:POSition {position}')
    await self._wait()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wave_gen_amp" class="doc doc-heading">
            <code class="highlight language-python">set_wave_gen_amp(amp)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Set the amplitude for the waveform generator.</p>
<p>Args:
amp (float): The desired amplitude for the waveform generator in volts.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def set_wave_gen_amp(self, amp: float) -&gt; None:
    """
    Set the amplitude for the waveform generator.

    Args:
    amp (float): The desired amplitude for the waveform generator in volts.
    """
    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )
    self.config.function_generator.amplitude.assert_in_range(amp, name="Waveform generator amplitude")
    await self._send_command(f"WGEN:VOLT {amp}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wave_gen_freq" class="doc doc-heading">
            <code class="highlight language-python">set_wave_gen_freq(freq)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Set the frequency for the waveform generator.</p>
<p>Args:
freq (float): The desired frequency for the waveform generator in Hz.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
##@ConfigRequires("function_generator")
async def set_wave_gen_freq(self, freq: float) -&gt; None:
    """
    Set the frequency for the waveform generator.

    Args:
    freq (float): The desired frequency for the waveform generator in Hz.
    """
    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )
    # Assuming RangeMixin's assert_in_range is preferred for validation
    self.config.function_generator.frequency.assert_in_range(freq, name="Waveform generator frequency")
    await self._send_command(f"WGEN:FREQ {freq}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wave_gen_func" class="doc doc-heading">
            <code class="highlight language-python">set_wave_gen_func(func_type)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Set the waveform function for the oscilloscope's waveform generator.</p>
<p>Args:
func_type (WaveformType): The desired function enum member.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def set_wave_gen_func(self, func_type: WaveformType) -&gt; None:
    """
    Set the waveform function for the oscilloscope's waveform generator.

    Args:
    func_type (WaveformType): The desired function enum member.
    """
    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )

    # Check if the SCPI value of the enum is in the list of supported waveform types from config
    if func_type.value not in self.config.function_generator.waveform_types:
        raise InstrumentParameterError(
            parameter="func_type",
            value=func_type.value,
            valid_range=self.config.function_generator.waveform_types,
            message="Unsupported waveform type.",
        )

    await self._send_command(f"WGEN:FUNC {func_type.value}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wave_gen_offset" class="doc doc-heading">
            <code class="highlight language-python">set_wave_gen_offset(offset)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Set the voltage offset for the waveform generator.</p>
<p>Args:
offset (float): The desired voltage offset for the waveform generator in volts.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def set_wave_gen_offset(self, offset: float) -&gt; None:
    """
    Set the voltage offset for the waveform generator.

    Args:
    offset (float): The desired voltage offset for the waveform generator in volts.
    """
    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )
    self.config.function_generator.offset.assert_in_range(offset, name="Waveform generator offset")
    await self._send_command(f"WGEN:VOLT:OFFSet {offset}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_dc" class="doc doc-heading">
            <code class="highlight language-python">set_wgen_dc(offset)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the waveform generator to a DC wave.</p>
<p>:param offset: The offset of the DC wave in volts</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def set_wgen_dc(self, offset: float) -&gt; None:
    """Sets the waveform generator to a DC wave.

    :param offset: The offset of the DC wave in volts
    """
    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )
    await self.set_wave_gen_func(WaveformType.DC)
    await self.set_wave_gen_offset(offset)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_noise" class="doc doc-heading">
            <code class="highlight language-python">set_wgen_noise(v0, v1, offset)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the waveform generator to a noise wave.</p>
<p>:param v0: The 'low' amplitude component or similar parameter for noise.
:param v1: The 'high' amplitude component or similar parameter for noise.
:param offset: The offset of the noise wave in volts.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def set_wgen_noise(self, v0: float, v1: float, offset: float) -&gt; None:
    """Sets the waveform generator to a noise wave.

    :param v0: The 'low' amplitude component or similar parameter for noise.
    :param v1: The 'high' amplitude component or similar parameter for noise.
    :param offset: The offset of the noise wave in volts.
    """
    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )
    await self.set_wave_gen_func(WaveformType.NOISE)
    await self._send_command(f':WGEN:VOLTage:LOW {v0}')
    await self._send_command(f':WGEN:VOLTage:HIGH {v1}')
    await self.set_wave_gen_offset(offset)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_pulse" class="doc doc-heading">
            <code class="highlight language-python">set_wgen_pulse(v0, v1, period, pulse_width=None, **kwargs)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the waveform generator to a pulse wave.</p>
<p>:param v0: The voltage of the low state in volts
:param v1: The voltage of the high state in volts
:param period: The period of the pulse wave in seconds.
:param pulse_width: The pulse width in seconds.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def set_wgen_pulse(self, v0: float, v1: float, period: float, pulse_width: Optional[float] = None, **kwargs) -&gt; None:
    """Sets the waveform generator to a pulse wave.

    :param v0: The voltage of the low state in volts
    :param v1: The voltage of the high state in volts
    :param period: The period of the pulse wave in seconds.
    :param pulse_width: The pulse width in seconds.
    """
    if 'pulseWidth' in kwargs:
        warnings.warn(
            "'pulseWidth' is deprecated, use 'pulse_width' instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        pulse_width = kwargs['pulseWidth']

    if pulse_width is None:
        raise InstrumentParameterError(message="pulse_width is required.")

    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )
    await self.set_wave_gen_func(WaveformType.PULSE)

    await self._send_command(f':WGEN:VOLTage:LOW {v0}')
    await self._send_command(f':WGEN:VOLTage:HIGH {v1}')
    await self._send_command(f':WGEN:PERiod {period}')
    await self._send_command(f':WGEN:FUNCtion:PULSe:WIDTh {pulse_width}')</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_ramp" class="doc doc-heading">
            <code class="highlight language-python">set_wgen_ramp(v0, v1, freq, symmetry)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the waveform generator to a ramp wave.</p>
<p>:param v0: The voltage of the low state in volts
:param v1: The voltage of the high state in volts
:param freq: The frequency of the ramp wave in Hz.
:param symmetry: Symmetry (0% to 100%).</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def set_wgen_ramp(self, v0: float, v1: float, freq: float, symmetry: int) -&gt; None:
    """Sets the waveform generator to a ramp wave.

    :param v0: The voltage of the low state in volts
    :param v1: The voltage of the high state in volts
    :param freq: The frequency of the ramp wave in Hz.
    :param symmetry: Symmetry (0% to 100%).
    """
    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )
    await self.set_wave_gen_func(WaveformType.RAMP)
    def clamp_symmetry(number: int) -&gt; int:
        return max(0, min(number, 100))

    await self._send_command(f':WGEN:VOLTage:LOW {v0}')
    await self._send_command(f':WGEN:VOLTage:HIGH {v1}')
    await self._send_command(f':WGEN:FREQuency {freq}')
    await self._send_command(f':WGEN:FUNCtion:RAMP:SYMMetry {clamp_symmetry(symmetry)}')</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_sin" class="doc doc-heading">
            <code class="highlight language-python">set_wgen_sin(amp, offset, freq)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the waveform generator to a sine wave.</p>
<p>:param amp: The amplitude of the sine wave in volts
:param offset: The offset of the sine wave in volts
:param freq: The frequency of the sine wave in Hz.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def set_wgen_sin(self, amp: float, offset: float, freq: float) -&gt; None:
    """Sets the waveform generator to a sine wave.

    :param amp: The amplitude of the sine wave in volts
    :param offset: The offset of the sine wave in volts
    :param freq: The frequency of the sine wave in Hz.
    """
    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )
    await self.set_wave_gen_func(WaveformType.SINE)
    await self.set_wave_gen_amp(amp)
    await self.set_wave_gen_offset(offset)
    await self.set_wave_gen_freq(freq)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.set_wgen_square" class="doc doc-heading">
            <code class="highlight language-python">set_wgen_square(v0, v1, freq, duty_cycle=None, **kwargs)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the waveform generator to a square wave.</p>
<p>:param v0: The voltage of the low state in volts
:param v1: The voltage of the high state in volts
:param freq: The frequency of the square wave in Hz.
:param duty_cycle: The duty cycle (1% to 99%).</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def set_wgen_square(self, v0: float, v1: float, freq: float, duty_cycle: Optional[int] = None, **kwargs) -&gt; None:
    """Sets the waveform generator to a square wave.

    :param v0: The voltage of the low state in volts
    :param v1: The voltage of the high state in volts
    :param freq: The frequency of the square wave in Hz.
    :param duty_cycle: The duty cycle (1% to 99%).
    """
    if 'dutyCycle' in kwargs:
        warnings.warn(
            "'dutyCycle' is deprecated, use 'duty_cycle' instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        duty_cycle = kwargs['dutyCycle']

    if duty_cycle is None:
        duty_cycle = 50

    if self.config.function_generator is None:
        raise InstrumentConfigurationError(
            self.config.model, "Function generator not configured."
        )

    await self.set_wave_gen_func(WaveformType.SQUARE)

    def clamp_duty(number: int) -&gt; int:
        return max(1, min(number, 99))

    await self._send_command(f':WGEN:VOLTage:LOW {v0}')
    await self._send_command(f':WGEN:VOLTage:HIGH {v1}')
    await self._send_command(f':WGEN:FREQuency {freq}')
    await self._send_command(f':WGEN:FUNCtion:SQUare:DCYCle {clamp_duty(duty_cycle)}')</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.Oscilloscope.wave_gen" class="doc doc-heading">
            <code class="highlight language-python">wave_gen(state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Enable or disable the waveform generator of the oscilloscope.</p>
<p>Args:
state (bool): True to enable ('ON'), False to disable ('OFF').</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
#@ConfigRequires("function_generator")
async def wave_gen(self, state: bool) -&gt; None:
    """
    Enable or disable the waveform generator of the oscilloscope.

    Args:
    state (bool): True to enable ('ON'), False to disable ('OFF').
    """
    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value
    await self._send_command(f"WGEN:OUTP {scpi_state}")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Oscilloscope.Preamble" class="doc doc-heading">
              <code class="highlight language-python">Preamble(format, type, points, xinc, xorg, xref, yinc, yorg, yref)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">


        <p>Holds the waveform preamble data from the oscilloscope.</p>
<p>The preamble contains all the necessary metadata to convert the raw, digitized
ADC values from the oscilloscope into meaningful time and voltage arrays. It
describes the scaling and offset factors for both the X (time) and Y (voltage)
axes.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="format

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Preamble.format)" href="#pytestlab.instruments.Oscilloscope.Preamble.format">format</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>Data format (e.g., 'BYTE', 'WORD').</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="type

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Preamble.type)" href="#pytestlab.instruments.Oscilloscope.Preamble.type">type</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>Acquisition type (e.g., 'NORMal', 'AVERage').</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="points

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Preamble.points)" href="#pytestlab.instruments.Oscilloscope.Preamble.points">points</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The number of data points in the waveform.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="xinc

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Preamble.xinc)" href="#pytestlab.instruments.Oscilloscope.Preamble.xinc">xinc</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The time difference between adjacent data points (sampling interval).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="xorg

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Preamble.xorg)" href="#pytestlab.instruments.Oscilloscope.Preamble.xorg">xorg</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The time value of the first data point.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="xref

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Preamble.xref)" href="#pytestlab.instruments.Oscilloscope.Preamble.xref">xref</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The reference time point (usually the trigger point).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="yinc

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Preamble.yinc)" href="#pytestlab.instruments.Oscilloscope.Preamble.yinc">yinc</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The voltage difference for each ADC level (voltage resolution).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="yorg

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Preamble.yorg)" href="#pytestlab.instruments.Oscilloscope.Preamble.yorg">yorg</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The voltage value at the vertical center of the screen.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="yref

  
      instance-attribute
   (pytestlab.instruments.Oscilloscope.Preamble.yref)" href="#pytestlab.instruments.Oscilloscope.Preamble.yref">yref</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The ADC level corresponding to the vertical center.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>










  <div class="doc doc-children">





<h5 id="pytestlab.instruments.Oscilloscope.Preamble-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Preamble.format" class="doc doc-heading">
            <code class="highlight language-python">format</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Preamble.points" class="doc doc-heading">
            <code class="highlight language-python">points</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Preamble.type" class="doc doc-heading">
            <code class="highlight language-python">type</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Preamble.xinc" class="doc doc-heading">
            <code class="highlight language-python">xinc</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Preamble.xorg" class="doc doc-heading">
            <code class="highlight language-python">xorg</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Preamble.xref" class="doc doc-heading">
            <code class="highlight language-python">xref</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Preamble.yinc" class="doc doc-heading">
            <code class="highlight language-python">yinc</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Preamble.yorg" class="doc doc-heading">
            <code class="highlight language-python">yorg</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Oscilloscope.Preamble.yref" class="doc doc-heading">
            <code class="highlight language-python">yref</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.Oscilloscope.Preamble-functions">Functions</h5>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade" class="doc doc-heading">
              <code class="highlight language-python">ScopeAcquisitionFacade(scope)</code>

</h4>


    <div class="doc doc-contents ">


        <p>Provides a simplified interface for the oscilloscope's acquisition system.</p>
<p>This facade manages settings related to how the oscilloscope digitizes
signals, including acquisition type (e.g., Normal, Averaging), memory mode
(Real-time vs. Segmented), and sample rates.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade._scope">_scope</span></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The parent <code>Oscilloscope</code> instance.</p>
              </div>
              <p>
              </p>
            </td>
          </tr>
      </tbody>
    </table>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, scope: 'Oscilloscope'):
    self._scope = scope</code></pre>
                  </details>



  <div class="doc doc-children">







<h5 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.analyze_all_segments" class="doc doc-heading">
            <code class="highlight language-python">analyze_all_segments()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Execute the scope's <em>Analyze Segments</em> soft-key.
Requires scope to be stopped and in SEGMENTED mode.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def analyze_all_segments(self) -&gt; None:
    """
    Execute the scope's *Analyze Segments* soft-key.
    Requires scope to be stopped and in SEGMENTED mode.
    """
    if await self.get_acquisition_mode() != "SEGMENTED":
        raise InstrumentParameterError(
            message="Segment analysis requires SEGMENTED mode."
        )
    await self._scope._send_command(":ACQuire:SEGMented:ANALyze")
    await self._scope._wait()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquire_points" class="doc doc-heading">
            <code class="highlight language-python">get_acquire_points()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Hardware points actually <em>acquired</em> for the next waveform transfer.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_acquire_points(self) -&gt; int:
    """
    Hardware points actually *acquired* for the next waveform transfer.
    """
    return int(await self._scope._query(":ACQuire:POINts?"))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquire_setup" class="doc doc-heading">
            <code class="highlight language-python">get_acquire_setup()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Return a parsed dictionary of the scope's :ACQuire? status string.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_acquire_setup(self) -&gt; Dict[str, str]:
    """
    Return a parsed dictionary of the scope's :ACQuire? status string.
    """
    raw_str: str = (await self._scope._query(":ACQuire?")).strip()
    parts: List[str] = [p.strip() for p in raw_str.split(';')]
    setup_dict: Dict[str, str] = {}
    for part in parts:
        kv = part.split(maxsplit=1)
        if len(kv) == 2:
            setup_dict[kv[0]] = kv[1]
    return setup_dict</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquisition_average_count" class="doc doc-heading">
            <code class="highlight language-python">get_acquisition_average_count()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Integer average count (valid only when acquisition type == AVERAGE).</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_acquisition_average_count(self) -&gt; int:
    """Integer average count (valid only when acquisition type == AVERAGE)."""
    return int(await self._scope._query(":ACQuire:COUNt?"))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquisition_mode" class="doc doc-heading">
            <code class="highlight language-python">get_acquisition_mode()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Return "REAL_TIME" or "SEGMENTED".</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_acquisition_mode(self) -&gt; str:
    """Return "REAL_TIME" or "SEGMENTED"."""
    resp_str_raw: str = (await self._scope._query(":ACQuire:MODE?")).strip()
    for friendly_name, scpi_command_str in _ACQ_MODE_MAP.items():
        if resp_str_raw.upper().startswith(scpi_command_str.upper()[:4]):
            return friendly_name
    self._scope._logger.warning(f"Could not map SCPI response '{resp_str_raw}' to a known AcquisitionMode. Returning raw response.")
    return resp_str_raw</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquisition_sample_rate" class="doc doc-heading">
            <code class="highlight language-python">get_acquisition_sample_rate()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Current sample rate of acquisition. Equivalent to get_sampling_rate().</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_acquisition_sample_rate(self) -&gt; float:
    """
    Current sample rate of acquisition. Equivalent to get_sampling_rate().
    """
    return float(await self._scope._query(":ACQuire:SRATe?"))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_acquisition_type" class="doc doc-heading">
            <code class="highlight language-python">get_acquisition_type()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Returns current acquisition type (e.g., "NORMAL", "AVERAGE").</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_acquisition_type(self) -&gt; str:
    """
    Returns current acquisition type (e.g., "NORMAL", "AVERAGE").
    """
    # Invert _ACQ_TYPE_MAP for lookup: SCPI response -&gt; Enum member name
    # SCPI responses can be short forms (e.g., "NORM" for "NORMal")
    # We need to match based on how the instrument actually responds.
    # A common way is that instrument responds with the short form.
    # Let's assume the instrument responds with a value that can be mapped back.
    resp_str_raw: str = (await self._scope._query(":ACQuire:TYPE?")).strip()

    for enum_member, scpi_command_str in _ACQ_TYPE_MAP.items():
        # Check if the response starts with the typical short SCPI command part
        # e.g. "NORM" from "NORMal"
        # This matching logic might need to be more robust based on actual instrument behavior
        if resp_str_raw.upper().startswith(scpi_command_str.upper()[:4]): # Compare first 4 chars
            return enum_member.name # Return the string name of the enum member

    self._scope._logger.warning(f"Could not map SCPI response '{resp_str_raw}' to a known AcquisitionType. Returning raw response.")
    return resp_str_raw # Fallback to raw response if no match</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_segment_index" class="doc doc-heading">
            <code class="highlight language-python">get_segment_index()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Index (1-based) of the currently selected memory segment.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_segment_index(self) -&gt; int:
    """Index (1-based) of the currently selected memory segment."""
    return int(await self._scope._query(":ACQuire:SEGMented:INDex?"))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.get_segmented_count" class="doc doc-heading">
            <code class="highlight language-python">get_segmented_count()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Number of segments currently configured (SEGMENTED mode only).</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_segmented_count(self) -&gt; int:
    """Number of segments currently configured (SEGMENTED mode only)."""
    return int(await self._scope._query(":ACQuire:SEGMented:COUNt?"))</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_acquisition_average_count" class="doc doc-heading">
            <code class="highlight language-python">set_acquisition_average_count(count)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Set the running-average length for AVERAGE mode.
2 &lt;= count &lt;= 65536 (Keysight limit).</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_acquisition_average_count(self, count: int) -&gt; None:
    """
    Set the running-average length for AVERAGE mode.
    2 &lt;= count &lt;= 65536 (Keysight limit).
    """
    await _validate_range(count, 2, 65_536, "Average count") # Sync

    current_acq_type_str = await self.get_acquisition_type()
    if current_acq_type_str != AcquisitionType.AVERAGE.name:
        raise InstrumentParameterError(
            parameter="count",
            message=f"Average count can only be set when acquisition type is AVERAGE, not {current_acq_type_str}.",
        )
    await self._scope._send_command(f":ACQuire:COUNt {count}")
    await self._scope._wait()
    self._scope._logger.debug(f"AVERAGE count set → {count}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_acquisition_mode" class="doc doc-heading">
            <code class="highlight language-python">set_acquisition_mode(mode)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Select real-time or segmented memory acquisition.
(Case-insensitive for mode).</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_acquisition_mode(self, mode: str) -&gt; None:
    """
    Select real-time or segmented memory acquisition.
    (Case-insensitive for mode).
    """
    mode_upper: str = mode.upper()
    scpi_mode_val = _ACQ_MODE_MAP.get(mode_upper)
    if not scpi_mode_val:
        raise InstrumentParameterError(
            parameter="mode",
            value=mode,
            valid_range=list(_ACQ_MODE_MAP.keys()),
            message="Unknown acquisition mode.",
        )

    await self._scope._send_command(f":ACQuire:MODE {scpi_mode_val}")
    await self._scope._wait()
    self._scope._logger.debug(f"Acquisition MODE set → {mode_upper}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_acquisition_type" class="doc doc-heading">
            <code class="highlight language-python">set_acquisition_type(acq_type)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Select the oscilloscope acquisition algorithm.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_acquisition_type(self, acq_type: AcquisitionType) -&gt; None:
    """
    Select the oscilloscope acquisition algorithm.
    """
    scpi_val = _ACQ_TYPE_MAP.get(acq_type)
    if not scpi_val:
        raise InstrumentParameterError(
            parameter="acq_type",
            value=acq_type,
            message="Unsupported acquisition type enum member.",
        )

    current_mode_query: str = (await self._scope._query(":ACQuire:MODE?")).strip().upper()
    if acq_type == AcquisitionType.AVERAGE and current_mode_query == _ACQ_MODE_MAP["SEGMENTED"].upper()[:4]:
        raise InstrumentParameterError(
            parameter="acq_type",
            value="AVERAGE",
            message="AVERAGE mode is unavailable in SEGMENTED acquisition.",
        )

    await self._scope._send_command(f":ACQuire:TYPE {scpi_val}")
    await self._scope._wait()
    self._scope._logger.debug(f"Acquisition TYPE set → {acq_type.name}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_segment_index" class="doc doc-heading">
            <code class="highlight language-python">set_segment_index(index)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Select which memory segment is active for readback.
1 &lt;= index &lt;= get_segmented_count()</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_segment_index(self, index: int) -&gt; None:
    """
    Select which memory segment is active for readback.
    1 &lt;= index &lt;= get_segmented_count()
    """
    total_segments: int = await self.get_segmented_count()
    await _validate_range(index, 1, total_segments, "Segment index") # Sync
    await self._scope._send_command(f":ACQuire:SEGMented:INDex {index}")
    await self._scope._wait()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeAcquisitionFacade.set_segmented_count" class="doc doc-heading">
            <code class="highlight language-python">set_segmented_count(count)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configure number of memory segments for SEGMENTED acquisitions.
Default Keysight limit: 2 &lt;= count &lt;= 500 (check instrument specs)</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_segmented_count(self, count: int) -&gt; None:
    """
    Configure number of memory segments for SEGMENTED acquisitions.
    Default Keysight limit: 2 &lt;= count &lt;= 500 (check instrument specs)
    """
    if await self.get_acquisition_mode() != "SEGMENTED":
        raise InstrumentParameterError(
            parameter="count",
            message="Segmented count can only be set while in SEGMENTED acquisition mode.",
        )
    await _validate_range(count, 2, 500, "Segmented count") # Sync
    await self._scope._send_command(f":ACQuire:SEGMented:COUNt {count}")
    await self._scope._wait()
    self._scope._logger.debug(f"Segmented COUNT set → {count}")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Oscilloscope.ScopeChannelFacade" class="doc doc-heading">
              <code class="highlight language-python">ScopeChannelFacade(scope, channel_num)</code>

</h4>


    <div class="doc doc-contents ">


        <p>Provides a simplified, chainable interface for a single oscilloscope channel.</p>
<p>This facade abstracts the underlying SCPI commands for common channel
operations, allowing for more readable and fluent test scripts. For example:
<code>await scope.channel(1).setup(scale=0.5, offset=0).enable()</code></p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="pytestlab.instruments.Oscilloscope.ScopeChannelFacade._scope">_scope</span></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The parent <code>Oscilloscope</code> instance.</p>
              </div>
              <p>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="pytestlab.instruments.Oscilloscope.ScopeChannelFacade._channel">_channel</span></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The channel number this facade controls.</p>
              </div>
              <p>
              </p>
            </td>
          </tr>
      </tbody>
    </table>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, scope: 'Oscilloscope', channel_num: int):
    self._scope = scope
    self._channel = channel_num</code></pre>
                  </details>



  <div class="doc doc-children">







<h5 id="pytestlab.instruments.Oscilloscope.ScopeChannelFacade-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeChannelFacade.disable" class="doc doc-heading">
            <code class="highlight language-python">disable()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Disables the channel display.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">async def disable(self) -&gt; Self:
    """Disables the channel display."""
    await self._scope.display_channel(self._channel, False)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeChannelFacade.enable" class="doc doc-heading">
            <code class="highlight language-python">enable()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Enables the channel display.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">async def enable(self) -&gt; Self:
    """Enables the channel display."""
    await self._scope.display_channel(self._channel, True)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeChannelFacade.measure_peak_to_peak" class="doc doc-heading">
            <code class="highlight language-python">measure_peak_to_peak()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Performs a peak-to-peak voltage measurement on this channel.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">async def measure_peak_to_peak(self) -&gt; MeasurementResult:
    """Performs a peak-to-peak voltage measurement on this channel."""
    return await self._scope.measure_voltage_peak_to_peak(self._channel)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeChannelFacade.measure_rms" class="doc doc-heading">
            <code class="highlight language-python">measure_rms()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Performs an RMS voltage measurement on this channel.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">async def measure_rms(self) -&gt; MeasurementResult:
    """Performs an RMS voltage measurement on this channel."""
    return await self._scope.measure_rms_voltage(self._channel)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeChannelFacade.setup" class="doc doc-heading">
            <code class="highlight language-python">setup(scale=None, position=None, offset=None, coupling=None, probe_attenuation=None, bandwidth_limit=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configures multiple settings for the channel in a single call.</p>
<p>This method allows setting the vertical scale, position/offset, coupling,
probe attenuation, and bandwidth limit. Any parameter left as <code>None</code> will
not be changed.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>scale</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The vertical scale in volts per division.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>position</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The vertical position in divisions from the center.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>offset</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The vertical offset in volts. 'offset' is often preferred
    over 'position' as it's independent of the scale.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>coupling</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The input coupling ("AC" or "DC").</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>probe_attenuation</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The attenuation factor of the probe (e.g., 10 for 10:1).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>bandwidth_limit</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The bandwidth limit to apply (e.g., "20M" or 20e6).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="float">float</span>]]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="typing.Self">Self</span></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The <code>ScopeChannelFacade</code> instance for method chaining.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def setup(self, scale: Optional[float] = None, position: Optional[float] = None, offset: Optional[float] = None, coupling: Optional[str] = None, probe_attenuation: Optional[int] = None, bandwidth_limit: Optional[Union[str, float]] = None) -&gt; Self:
    """Configures multiple settings for the channel in a single call.

    This method allows setting the vertical scale, position/offset, coupling,
    probe attenuation, and bandwidth limit. Any parameter left as `None` will
    not be changed.

    Args:
        scale: The vertical scale in volts per division.
        position: The vertical position in divisions from the center.
        offset: The vertical offset in volts. 'offset' is often preferred
                over 'position' as it's independent of the scale.
        coupling: The input coupling ("AC" or "DC").
        probe_attenuation: The attenuation factor of the probe (e.g., 10 for 10:1).
        bandwidth_limit: The bandwidth limit to apply (e.g., "20M" or 20e6).

    Returns:
        The `ScopeChannelFacade` instance for method chaining.
    """
    if scale is not None:
        current_offset_val = (await self._scope.get_channel_axis(self._channel))[1] if offset is None and position is None else (offset or position or 0.0)
        await self._scope.set_channel_axis(self._channel, scale, current_offset_val)
    elif position is not None or offset is not None: # only position/offset is set
        val_to_set = position if position is not None else offset
        current_scale_val = (await self._scope.get_channel_axis(self._channel))[0]
        await self._scope.set_channel_axis(self._channel, current_scale_val, val_to_set)

    if coupling is not None:
        await self._scope._send_command(f":CHANnel{self._channel}:COUPling {coupling.upper()}")
        self._scope._logger.debug(f"Channel {self._channel} coupling set to {coupling.upper()}")

    if probe_attenuation is not None:
        await self._scope.set_probe_attenuation(self._channel, probe_attenuation)

    if bandwidth_limit is not None:
        await self._scope.set_bandwidth_limit(self._channel, bandwidth_limit)

    return self</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Oscilloscope.ScopeTriggerFacade" class="doc doc-heading">
              <code class="highlight language-python">ScopeTriggerFacade(scope)</code>

</h4>


    <div class="doc doc-contents ">


        <p>Provides a simplified, chainable interface for the oscilloscope's trigger system.</p>
<p>This facade abstracts the underlying SCPI commands for trigger operations,
focusing on common use cases like setting up an edge trigger.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="pytestlab.instruments.Oscilloscope.ScopeTriggerFacade._scope">_scope</span></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The parent <code>Oscilloscope</code> instance.</p>
              </div>
              <p>
              </p>
            </td>
          </tr>
      </tbody>
    </table>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, scope: 'Oscilloscope'):
    self._scope = scope</code></pre>
                  </details>



  <div class="doc doc-children">







<h5 id="pytestlab.instruments.Oscilloscope.ScopeTriggerFacade-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Oscilloscope.ScopeTriggerFacade.setup_edge" class="doc doc-heading">
            <code class="highlight language-python">setup_edge(source, level, slope=TriggerSlope.POSITIVE, coupling=None, mode='EDGE')</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configures a standard edge trigger.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>source</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The trigger source (e.g., "CH1", "CH2", "EXT", "LINE").</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>level</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The trigger level in volts.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>slope</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The trigger slope (<code>TriggerSlope.POSITIVE</code>, <code>NEGATIVE</code>, or <code>EITHER</code>).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><a class="autorefs autorefs-internal" title="TriggerSlope (pytestlab.common.enums.TriggerSlope)" href="../common/#pytestlab.common.enums.TriggerSlope">TriggerSlope</a></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code><a class="autorefs autorefs-internal" title="POSITIVE = 'POS'

  
      class-attribute
      instance-attribute
   (pytestlab.common.enums.TriggerSlope.POSITIVE)" href="../common/#pytestlab.common.enums.TriggerSlope.POSITIVE">POSITIVE</a></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>coupling</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The trigger coupling (e.g., "AC", "DC"). Can be instrument-specific.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>mode</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The trigger mode, defaults to "EDGE".</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>&#39;EDGE&#39;</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="typing.Self">Self</span></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The <code>ScopeTriggerFacade</code> instance for method chaining.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Oscilloscope.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def setup_edge(self, source: str, level: float, slope: TriggerSlope = TriggerSlope.POSITIVE, coupling: Optional[str] = None, mode: str = "EDGE") -&gt; Self:
    """Configures a standard edge trigger.

    Args:
        source: The trigger source (e.g., "CH1", "CH2", "EXT", "LINE").
        level: The trigger level in volts.
        slope: The trigger slope (`TriggerSlope.POSITIVE`, `NEGATIVE`, or `EITHER`).
        coupling: The trigger coupling (e.g., "AC", "DC"). Can be instrument-specific.
        mode: The trigger mode, defaults to "EDGE".

    Returns:
        The `ScopeTriggerFacade` instance for method chaining.
    """
    # Determine channel number if source is like 'CH1' for the level command
    trigger_channel_for_level = 1 # Default or fallback
    if source.upper().startswith("CHAN"):
        try:
            trigger_channel_for_level = int(source[len("CHAN"):])
        except ValueError:
            raise InstrumentParameterError(
                parameter="source",
                value=source,
                message="Invalid trigger source format for channel.",
            )
    elif source.upper().startswith("CH"):
        try:
            trigger_channel_for_level = int(source[len("CH"):])
        except ValueError:
            raise InstrumentParameterError(
                parameter="source",
                value=source,
                message="Invalid trigger source format for channel.",
            )

    # The main configure_trigger method handles source validation and mapping.
    await self._scope.configure_trigger(
        channel=trigger_channel_for_level, # This is for the :TRIGger:LEVel CHANnel&lt;n&gt; part
        level=level,
        source=source, # This is for :TRIGger:SOURce part
        slope=slope,
        mode=mode
    )
    # Coupling for trigger is often separate, e.g., :TRIGger:COUPling
    if coupling is not None:
        await self._scope._send_command(f":TRIGger:{mode.upper()}:COUPling {coupling.upper()}") # Assuming edge trigger coupling
        self._scope._logger.debug(f"Trigger coupling set to {coupling.upper()}")
    return self</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="power-supply">Power Supply</h3>


<div class="doc doc-object doc-module">



<h2 id="pytestlab.instruments.PowerSupply" class="doc doc-heading">
            <code>pytestlab.instruments.PowerSupply</code>


</h2>

    <div class="doc doc-contents first">









  <div class="doc doc-children">






<h3 id="pytestlab.instruments.PowerSupply-classes">Classes</h3>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.PowerSupply.PSUChannelConfig" class="doc doc-heading">
              <code class="highlight language-python">PSUChannelConfig(voltage, current, state)</code>

</h4>


    <div class="doc doc-contents ">


        <p>A data class to hold the measured configuration of a single PSU channel.</p>
<p>This class is used to structure the data returned by <code>get_configuration</code>,
providing a snapshot of a channel's state. It is not a Pydantic model for
loading configurations from files.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="voltage = voltage

  
      instance-attribute
   (pytestlab.instruments.PowerSupply.PSUChannelConfig.voltage)" href="#pytestlab.instruments.PowerSupply.PSUChannelConfig.voltage">voltage</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The measured voltage of the channel.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span> | <span title="uncertainties.core.UFloat">UFloat</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="current = current

  
      instance-attribute
   (pytestlab.instruments.PowerSupply.PSUChannelConfig.current)" href="#pytestlab.instruments.PowerSupply.PSUChannelConfig.current">current</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The measured current of the channel.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span> | <span title="uncertainties.core.UFloat">UFloat</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="state

  
      instance-attribute
   (pytestlab.instruments.PowerSupply.PSUChannelConfig.state)" href="#pytestlab.instruments.PowerSupply.PSUChannelConfig.state">state</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The output state of the channel ("ON" or "OFF").</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>

        <p>Initializes the PSUChannelConfig.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>voltage</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The voltage value for the channel.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span> | <span title="uncertainties.core.UFloat">UFloat</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>current</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The current value for the channel.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span> | <span title="uncertainties.core.UFloat">UFloat</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>state</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The state of the channel (e.g., 0, 1, "ON", "OFF").</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="str">str</span>]</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, voltage: float | UFloat, current: float | UFloat, state: Union[int, str]) -&gt; None:
    """Initializes the PSUChannelConfig.

    Args:
        voltage: The voltage value for the channel.
        current: The current value for the channel.
        state: The state of the channel (e.g., 0, 1, "ON", "OFF").
    """
    self.voltage: float | UFloat = voltage
    self.current: float | UFloat = current
    self.state: str # Store state as string "ON" or "OFF" for consistency
    if isinstance(state, str):
        # Normalize state from various string inputs like "1", "0", "ON", "OFF"
        state_upper = state.upper().strip()
        if state_upper == SCPIOnOff.ON.value or state_upper == "1":
            self.state = SCPIOnOff.ON.value
        elif state_upper == SCPIOnOff.OFF.value or state_upper == "0":
            self.state = SCPIOnOff.OFF.value
        else:
            raise ValueError(f"Invalid string state value: {state}")
    elif isinstance(state, (int, float)): # float for query results that might be like 1.0
         self.state = SCPIOnOff.ON.value if int(state) == 1 else SCPIOnOff.OFF.value
    else:
        raise ValueError(f"Invalid state value type: {type(state)}, value: {state}")</code></pre>
                  </details>



  <div class="doc doc-children">





<h5 id="pytestlab.instruments.PowerSupply.PSUChannelConfig-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.PowerSupply.PSUChannelConfig.current" class="doc doc-heading">
            <code class="highlight language-python">current = current</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.PowerSupply.PSUChannelConfig.state" class="doc doc-heading">
            <code class="highlight language-python">state</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.PowerSupply.PSUChannelConfig.voltage" class="doc doc-heading">
            <code class="highlight language-python">voltage = voltage</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.PowerSupply.PSUChannelConfig-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PSUChannelConfig.__repr__" class="doc doc-heading">
            <code class="highlight language-python">__repr__()</code>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">def __repr__(self) -&gt; str:
    return f"PSUChannelConfig(voltage={self.voltage!r}, current={self.current!r}, state='{self.state}')"</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.PowerSupply.PSUChannelFacade" class="doc doc-heading">
              <code class="highlight language-python">PSUChannelFacade(psu, channel_num)</code>

</h4>


    <div class="doc doc-contents ">


        <p>Provides a simplified, chainable interface for a single PSU channel.</p>
<p>This facade abstracts the underlying SCPI commands for common channel
operations, allowing for more readable and fluent test scripts. For example:
<code>await psu.channel(1).set(voltage=5.0, current_limit=0.1).on()</code></p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="pytestlab.instruments.PowerSupply.PSUChannelFacade._psu">_psu</span></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The parent <code>PowerSupply</code> instance.</p>
              </div>
              <p>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="pytestlab.instruments.PowerSupply.PSUChannelFacade._channel">_channel</span></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The channel number (1-based) this facade controls.</p>
              </div>
              <p>
              </p>
            </td>
          </tr>
      </tbody>
    </table>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, psu: 'PowerSupply', channel_num: int):
    self._psu = psu
    self._channel = channel_num</code></pre>
                  </details>



  <div class="doc doc-children">







<h5 id="pytestlab.instruments.PowerSupply.PSUChannelFacade-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PSUChannelFacade.get_current" class="doc doc-heading">
            <code class="highlight language-python">get_current()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Reads the measured current from this channel.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_current(self) -&gt; float | UFloat:
    """Reads the measured current from this channel."""
    return await self._psu.read_current(self._channel)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PSUChannelFacade.get_output_state" class="doc doc-heading">
            <code class="highlight language-python">get_output_state()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Checks if the channel output is enabled (ON).</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="bool">bool</span></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>True if the output is on, False otherwise.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the instrument returns an unexpected state.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_output_state(self) -&gt; bool:
    """Checks if the channel output is enabled (ON).

    Returns:
        True if the output is on, False otherwise.

    Raises:
        InstrumentParameterError: If the instrument returns an unexpected state.
    """
    command = f"{self._psu.SCPI_MAP.OUTPUT_STATE_QUERY_BASE} (@{self._channel})"
    state_str = (await self._psu._query(command)).strip().upper()
    if state_str in ("1", "ON"):
        return True
    elif state_str in ("0", "OFF"):
        return False
    raise InstrumentParameterError(f"Unexpected output state '{state_str}' for channel {self._channel}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PSUChannelFacade.get_voltage" class="doc doc-heading">
            <code class="highlight language-python">get_voltage()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Reads the measured voltage from this channel.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_voltage(self) -&gt; float | UFloat:
    """Reads the measured voltage from this channel."""
    return await self._psu.read_voltage(self._channel)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PSUChannelFacade.off" class="doc doc-heading">
            <code class="highlight language-python">off()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Disables the output of this channel.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">async def off(self) -&gt; Self:
    """Disables the output of this channel."""
    await self._psu.output(self._channel, False)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PSUChannelFacade.on" class="doc doc-heading">
            <code class="highlight language-python">on()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Enables the output of this channel.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">async def on(self) -&gt; Self:
    """Enables the output of this channel."""
    await self._psu.output(self._channel, True)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PSUChannelFacade.set" class="doc doc-heading">
            <code class="highlight language-python">set(voltage=None, current_limit=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the voltage and/or current limit for this channel.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>voltage</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The target voltage in Volts.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>current_limit</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The current limit in Amperes.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="typing.Self">Self</span></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The <code>PSUChannelFacade</code> instance for method chaining.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set(self, voltage: Optional[float] = None, current_limit: Optional[float] = None) -&gt; Self:
    """Sets the voltage and/or current limit for this channel.

    Args:
        voltage: The target voltage in Volts.
        current_limit: The current limit in Amperes.

    Returns:
        The `PSUChannelFacade` instance for method chaining.
    """
    if voltage is not None:
        await self._psu.set_voltage(self._channel, voltage)
    if current_limit is not None:
        await self._psu.set_current(self._channel, current_limit)
    return self</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.PowerSupply.PowerSupply" class="doc doc-heading">
              <code class="highlight language-python">PowerSupply(config, backend, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a>[<a class="autorefs autorefs-internal" title="pytestlab.config.power_supply_config.PowerSupplyConfig (pytestlab.config.PowerSupplyConfig)" href="../config/#pytestlab.config.power_supply_config.PowerSupplyConfig">PowerSupplyConfig</a>]</code></p>


        <p>Drives a multi-channel Power Supply Unit (PSU).</p>
<p>This class provides a high-level interface for controlling a programmable
power supply. It builds upon the base <code>Instrument</code> class and adds methods
for setting and reading voltage and current on a per-channel basis. It also
supports incorporating measurement uncertainty if configured.</p>
<p>A key feature is the <code>channel()</code> method, which returns a <code>PSUChannelFacade</code>
for a simplified, chainable programming experience.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="config

  
      instance-attribute
   (pytestlab.instruments.PowerSupply.PowerSupply.config)" href="#pytestlab.instruments.PowerSupply.PowerSupply.config">config</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The Pydantic configuration object (<code>PowerSupplyConfig</code>)
    containing settings specific to this PSU.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><a class="autorefs autorefs-internal" title="pytestlab.config.power_supply_config.PowerSupplyConfig (pytestlab.config.PowerSupplyConfig)" href="../config/#pytestlab.config.power_supply_config.PowerSupplyConfig">PowerSupplyConfig</a></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="SCPI_MAP = KeysightEDU36311APSU_SCPI()

  
      class-attribute
      instance-attribute
   (pytestlab.instruments.PowerSupply.PowerSupply.SCPI_MAP)" href="#pytestlab.instruments.PowerSupply.PowerSupply.SCPI_MAP">SCPI_MAP</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>An object that maps generic functions to model-specific SCPI commands.</p>
              </div>
              <p>
              </p>
            </td>
          </tr>
      </tbody>
    </table>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO
    """
    Initialize the Instrument class.

    Args:
        config (ConfigType): Configuration for the instrument.
        backend (AsyncInstrumentIO): The communication backend instance.
        **kwargs: Additional keyword arguments.
    """
    if not isinstance(config, InstrumentConfig): # Check against the bound base
        raise InstrumentConfigurationError(
            self.__class__.__name__,
            f"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.",
        )

    self.config = config
    self._backend = backend # This will be an AsyncInstrumentIO instance
    self._command_log = []

    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__
    self._logger = get_logger(logger_name)

    self._logger.info(f"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.")</code></pre>
                  </details>



  <div class="doc doc-children">





<h5 id="pytestlab.instruments.PowerSupply.PowerSupply-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.SCPI_MAP" class="doc doc-heading">
            <code class="highlight language-python">SCPI_MAP = KeysightEDU36311APSU_SCPI()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.config" class="doc doc-heading">
            <code class="highlight language-python">config</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.model_config" class="doc doc-heading">
            <code class="highlight language-python">model_config = {'arbitrary_types_allowed': True}</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.PowerSupply.PowerSupply-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.channel" class="doc doc-heading">
            <code class="highlight language-python">channel(ch_num)</code>

</h6>


    <div class="doc doc-contents ">

        <p>Returns a facade for interacting with a specific channel.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>ch_num</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel number (1-based).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>PSUChannelFacade</code>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>A facade object for the specified channel.</p>
              </div>
                <p>
                  <span class="doc-returns-annotation">
                    <b>TYPE:</b>
                      <code><a class="autorefs autorefs-internal" title="PSUChannelFacade(psu, channel_num) (pytestlab.instruments.PowerSupply.PSUChannelFacade)" href="#pytestlab.instruments.PowerSupply.PSUChannelFacade">PSUChannelFacade</a></code>
                  </span>
                </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If channel number is invalid.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
def channel(self, ch_num: int) -&gt; PSUChannelFacade:
    """
    Returns a facade for interacting with a specific channel.

    Args:
        ch_num (int): The channel number (1-based).

    Returns:
        PSUChannelFacade: A facade object for the specified channel.

    Raises:
        InstrumentParameterError: If channel number is invalid.
    """
    if not self.config.channels or not (1 &lt;= ch_num &lt;= len(self.config.channels)):
        num_ch = len(self.config.channels) if self.config.channels else 0
        raise InstrumentParameterError(f"Channel number {ch_num} is out of range (1-{num_ch}).")
    return PSUChannelFacade(self, ch_num)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.display" class="doc doc-heading">
            <code class="highlight language-python">display(state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Enables or disables the instrument's front panel display.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>state</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>True to turn the display on, False to turn it off.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="bool">bool</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def display(self, state: bool) -&gt; None:
    """Enables or disables the instrument's front panel display.

    Args:
        state: True to turn the display on, False to turn it off.
    """
    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value
    await self._send_command(f"DISP {scpi_state}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.from_config" class="doc doc-heading">
            <code class="highlight language-python">from_config(config, **kwargs)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
def from_config(cls: Type['PowerSupply'], config: PowerSupplyConfig, **kwargs: Any) -&gt; 'PowerSupply':
    return cls(config=config, **kwargs)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.get_configuration" class="doc doc-heading">
            <code class="highlight language-python">get_configuration()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Reads the live state of all configured PSU channels.</p>
<p>This method iterates through all channels defined in the configuration,
queries their current voltage, current, and output state, and returns
the collected data.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="typing.Dict">Dict</span>[<span title="int">int</span>, <a class="autorefs autorefs-internal" title="PSUChannelConfig(voltage, current, state) (pytestlab.instruments.PowerSupply.PSUChannelConfig)" href="#pytestlab.instruments.PowerSupply.PSUChannelConfig">PSUChannelConfig</a>]</code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>A dictionary where keys are channel numbers (1-based) and values are</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="typing.Dict">Dict</span>[<span title="int">int</span>, <a class="autorefs autorefs-internal" title="PSUChannelConfig(voltage, current, state) (pytestlab.instruments.PowerSupply.PSUChannelConfig)" href="#pytestlab.instruments.PowerSupply.PSUChannelConfig">PSUChannelConfig</a>]</code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p><code>PSUChannelConfig</code> objects representing the state of each channel.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_configuration(self) -&gt; Dict[int, PSUChannelConfig]:
    """Reads the live state of all configured PSU channels.

    This method iterates through all channels defined in the configuration,
    queries their current voltage, current, and output state, and returns
    the collected data.

    Returns:
        A dictionary where keys are channel numbers (1-based) and values are
        `PSUChannelConfig` objects representing the state of each channel.
    """
    results: Dict[int, PSUChannelConfig] = {}
    if not self.config.channels:
        self._logger.warning("No channels defined in the PowerSupplyConfig. Cannot get configuration.")
        return results

    num_channels = len(self.config.channels)

    for channel_num in range(1, num_channels + 1): # Iterate 1-indexed channel numbers
        voltage_val: float | UFloat = await self.read_voltage(channel_num) # Already uses @validate_call
        current_val: float | UFloat = await self.read_current(channel_num) # Already uses @validate_call
        # Query output state using SCPI_MAP
        output_state_command = f"{self.SCPI_MAP.OUTPUT_STATE_QUERY_BASE} (@{channel_num})"
        state_str: str = await self._query(output_state_command)

        results[channel_num] = PSUChannelConfig(
            voltage=voltage_val,
            current=current_val,
            state=state_str.strip()
        )
    return results</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.id" class="doc doc-heading">
            <code class="highlight language-python">id()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Queries the instrument identification string.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>str</code>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The instrument identification string.</p>
              </div>
                <p>
                  <span class="doc-returns-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
                </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">async def id(self) -&gt; str:
    """
    Queries the instrument identification string.

    Returns:
        str: The instrument identification string.
    """
    return await self._query(self.SCPI_MAP.IDN)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.output" class="doc doc-heading">
            <code class="highlight language-python">output(channel, state=True)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Enables or disables the output for one or more channels.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>A single channel number (1-based) or a list of channel numbers.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="typing.List">List</span>[<span title="int">int</span>]]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>state</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>True to enable the output (ON), False to disable (OFF).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="bool">bool</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>True</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If any channel number is invalid.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><span title="ValueError">ValueError</span></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the <code>channel</code> argument is not an int or a list of ints.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def output(self, channel: Union[int, List[int]], state: bool = True) -&gt; None:
    """Enables or disables the output for one or more channels.

    Args:
        channel: A single channel number (1-based) or a list of channel numbers.
        state: True to enable the output (ON), False to disable (OFF).

    Raises:
        InstrumentParameterError: If any channel number is invalid.
        ValueError: If the `channel` argument is not an int or a list of ints.
    """
    channels_to_process: List[int]
    if isinstance(channel, int):
        channels_to_process = [channel]
    elif isinstance(channel, list):
        # Ensure all elements in the list are integers
        if not all(isinstance(ch, int) for ch in channel):
            raise ValueError("All elements in channel list must be integers.")
        channels_to_process = channel
    else:
        # This case should ideally be caught by validate_call if type hints are precise enough,
        # but an explicit check remains good practice.
        raise ValueError(f"Invalid channel type: {type(channel)}. Expected int or List[int].")

    num_configured_channels = len(self.config.channels) if self.config.channels else 0
    for ch_num in channels_to_process:
        if not (1 &lt;= ch_num &lt;= num_configured_channels):
            raise InstrumentParameterError(f"Channel number {ch_num} is out of range (1-{num_configured_channels}).")

    argument = ",".join(map(str, channels_to_process))
    scpi_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value
    command = f"{self.SCPI_MAP.OUTPUT_STATE_SET_BASE} {scpi_state}, (@{argument})"
    await self._send_command(command)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.read_current" class="doc doc-heading">
            <code class="highlight language-python">read_current(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Reads the measured output current from a specific channel.</p>
<p>If measurement accuracy is defined in the configuration, this method
will return a <code>UFloat</code> object containing the value and its uncertainty.
Otherwise, it returns a standard float.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel number to measure (1-based).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="float">float</span> | <span title="uncertainties.core.UFloat">UFloat</span></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The measured current as a float or <code>UFloat</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the channel number is invalid.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def read_current(self, channel: int) -&gt; float | UFloat:
    """Reads the measured output current from a specific channel.

    If measurement accuracy is defined in the configuration, this method
    will return a `UFloat` object containing the value and its uncertainty.
    Otherwise, it returns a standard float.

    Args:
        channel: The channel number to measure (1-based).

    Returns:
        The measured current as a float or `UFloat`.

    Raises:
        InstrumentParameterError: If the channel number is invalid.
    """
    if not self.config.channels or not (1 &lt;= channel &lt;= len(self.config.channels)):
        num_ch = len(self.config.channels) if self.config.channels else 0
        raise InstrumentParameterError(f"Channel number {channel} is out of range (1-{num_ch}).")
    command = f"{self.SCPI_MAP.MEAS_CURRENT_QUERY_BASE} (@{channel})"
    response_str: str = await self._query(command)
    reading: float = float(response_str)

    value_to_return: float | UFloat = reading

    if self.config.measurement_accuracy:
        mode_key = f"read_current_ch{channel}"
        self._logger.debug(f"Attempting to find accuracy spec for read_current on channel {channel} with key: '{mode_key}'")
        spec = self.config.measurement_accuracy.get(mode_key)

        if spec:
            sigma = spec.calculate_std_dev(reading, range_value=None)
            if sigma &gt; 0:
                value_to_return = ufloat(reading, sigma)
                self._logger.debug(f"Applied accuracy spec '{mode_key}', value: {value_to_return}")
            else:
                self._logger.debug(f"Accuracy spec '{mode_key}' resulted in sigma=0. Returning float.")
        else:
            self._logger.debug(f"No accuracy spec found for read_current on channel {channel} with key '{mode_key}'. Returning float.")
    else:
        self._logger.debug(f"No measurement_accuracy configuration in instrument for read_current on channel {channel}. Returning float.")

    return value_to_return</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.read_voltage" class="doc doc-heading">
            <code class="highlight language-python">read_voltage(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Reads the measured output voltage from a specific channel.</p>
<p>If measurement accuracy is defined in the configuration, this method
will return a <code>UFloat</code> object containing the value and its uncertainty.
Otherwise, it returns a standard float.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel number to measure (1-based).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="float">float</span> | <span title="uncertainties.core.UFloat">UFloat</span></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The measured voltage as a float or <code>UFloat</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the channel number is invalid.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def read_voltage(self, channel: int) -&gt; float | UFloat:
    """Reads the measured output voltage from a specific channel.

    If measurement accuracy is defined in the configuration, this method
    will return a `UFloat` object containing the value and its uncertainty.
    Otherwise, it returns a standard float.

    Args:
        channel: The channel number to measure (1-based).

    Returns:
        The measured voltage as a float or `UFloat`.

    Raises:
        InstrumentParameterError: If the channel number is invalid.
    """
    if not self.config.channels or not (1 &lt;= channel &lt;= len(self.config.channels)):
        num_ch = len(self.config.channels) if self.config.channels else 0
        raise InstrumentParameterError(f"Channel number {channel} is out of range (1-{num_ch}).")
    command = f"{self.SCPI_MAP.MEAS_VOLTAGE_QUERY_BASE} (@{channel})"
    response_str: str = await self._query(command)
    reading: float = float(response_str)

    value_to_return: float | UFloat = reading

    if self.config.measurement_accuracy:
        mode_key = f"read_voltage_ch{channel}"
        self._logger.debug(f"Attempting to find accuracy spec for read_voltage on channel {channel} with key: '{mode_key}'")
        spec = self.config.measurement_accuracy.get(mode_key)

        if spec:
            sigma = spec.calculate_std_dev(reading, range_value=None)
            if sigma &gt; 0:
                value_to_return = ufloat(reading, sigma)
                self._logger.debug(f"Applied accuracy spec '{mode_key}', value: {value_to_return}")
            else:
                self._logger.debug(f"Accuracy spec '{mode_key}' resulted in sigma=0. Returning float.")
        else:
            self._logger.debug(f"No accuracy spec found for read_voltage on channel {channel} with key '{mode_key}'. Returning float.")
    else:
        self._logger.debug(f"No measurement_accuracy configuration in instrument for read_voltage on channel {channel}. Returning float.")

    return value_to_return</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.reset" class="doc doc-heading">
            <code class="highlight language-python">reset()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Resets the instrument to its factory default settings.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">async def reset(self) -&gt; None:
    """
    Resets the instrument to its factory default settings.
    """
    await self._send_command(self.SCPI_MAP.RESET)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.set_current" class="doc doc-heading">
            <code class="highlight language-python">set_current(channel, current)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the current limit for a specific channel.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel number (1-based).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>current</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The current limit in Amperes.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the channel number is invalid or the
                      current is outside the configured range for
                      that channel.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_current(self, channel: int, current: float) -&gt; None:
    """Sets the current limit for a specific channel.

    Args:
        channel: The channel number (1-based).
        current: The current limit in Amperes.

    Raises:
        InstrumentParameterError: If the channel number is invalid or the
                                  current is outside the configured range for
                                  that channel.
    """
    if not self.config.channels or not (1 &lt;= channel &lt;= len(self.config.channels)):
        num_ch = len(self.config.channels) if self.config.channels else 0
        raise InstrumentParameterError(f"Channel number {channel} is out of range (1-{num_ch}).")

    channel_config = self.config.channels[channel - 1] # channel is 1-based
    channel_config.current_limit_range.assert_in_range(current, name=f"Current for channel {channel}") # Assuming current_limit_range from example
    command = f"{self.SCPI_MAP.CURRENT_SET_BASE} {current}, (@{channel})"
    await self._send_command(command)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerSupply.PowerSupply.set_voltage" class="doc doc-heading">
            <code class="highlight language-python">set_voltage(channel, voltage)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the output voltage for a specific channel.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel number (1-based).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>voltage</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The target voltage in Volts.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the channel number is invalid or the
                      voltage is outside the configured range for
                      that channel.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerSupply.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_voltage(self, channel: int, voltage: float) -&gt; None:
    """Sets the output voltage for a specific channel.

    Args:
        channel: The channel number (1-based).
        voltage: The target voltage in Volts.

    Raises:
        InstrumentParameterError: If the channel number is invalid or the
                                  voltage is outside the configured range for
                                  that channel.
    """
    # Validate that the channel number is within the configured range
    if not self.config.channels or not (1 &lt;= channel &lt;= len(self.config.channels)):
        num_ch = len(self.config.channels) if self.config.channels else 0
        raise InstrumentParameterError(f"Channel number {channel} is out of range (1-{num_ch}).")

    # Validate the voltage against the limits defined in the configuration
    channel_config = self.config.channels[channel - 1]
    channel_config.voltage_range.assert_in_range(voltage, name=f"Voltage for channel {channel}")

    # Construct and send the SCPI command
    command = f"{self.SCPI_MAP.VOLTAGE_SET_BASE} {voltage}, (@{channel})"
    await self._send_command(command)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="waveform-generator">Waveform Generator</h3>


<div class="doc doc-object doc-module">



<h2 id="pytestlab.instruments.WaveformGenerator" class="doc doc-heading">
            <code>pytestlab.instruments.WaveformGenerator</code>


</h2>

    <div class="doc doc-contents first">









  <div class="doc doc-children">





<h3 id="pytestlab.instruments.WaveformGenerator-attributes">Attributes</h3>

<div class="doc doc-object doc-attribute">



<h4 id="pytestlab.instruments.WaveformGenerator.WAVEFORM_PARAM_COMMANDS" class="doc doc-heading">
            <code class="highlight language-python">WAVEFORM_PARAM_COMMANDS = {WaveformType.PULSE: {'duty_cycle': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:DCYCle {v_float}', 'period': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:PERiod {v_float}', 'width': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:WIDTh {v_float}', 'transition_both': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:TRANsition:BOTH {v_float}', 'transition_leading': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:TRANsition:LEADing {v_float}', 'transition_trailing': lambda ch, v_float: f'SOUR{ch}:FUNC:PULS:TRANsition:TRAiling {v_float}', 'hold_mode': lambda ch, v_str_hold: f'SOUR{ch}:FUNC:PULS:HOLD {v_str_hold.upper()}'}, WaveformType.SQUARE: {'duty_cycle': lambda ch, v_float: f'SOUR{ch}:FUNC:SQUare:DCYCle {v_float}', 'period': lambda ch, v_float: f'SOUR{ch}:FUNC:SQUare:PERiod {v_float}'}, WaveformType.RAMP: {'symmetry': lambda ch, v_float: f'SOUR{ch}:FUNC:RAMP:SYMMetry {v_float}'}, WaveformType.SINE: {}, WaveformType.NOISE: {'bandwidth': lambda ch, v_float: f'SOUR{ch}:FUNC:NOISe:BANDwidth {v_float}'}, WaveformType.ARB: {'sample_rate': lambda ch, v_float: f'SOUR{ch}:FUNC:ARB:SRATe {v_float}', 'filter': lambda ch, arb_filter_enum_val: f'SOUR{ch}:FUNC:ARB:FILTer {arb_filter_enum_val}', 'advance_mode': lambda ch, arb_adv_enum_val: f'SOUR{ch}:FUNC:ARB:ADVance {arb_adv_enum_val}', 'frequency': lambda ch, v_float: f'SOUR{ch}:FUNC:ARB:FREQ {v_float}', 'period': lambda ch, v_float: f'SOUR{ch}:FUNC:ARB:PER {v_float}', 'ptpeak_voltage': lambda ch, v_float: f'SOUR{ch}:FUNC:ARB:PTP {v_float}'}, WaveformType.DC: {}}</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

    </div>

</div>
<h3 id="pytestlab.instruments.WaveformGenerator-classes">Classes</h3>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.WaveformGenerator.FileSystemInfo" class="doc doc-heading">
              <code class="highlight language-python">FileSystemInfo(bytes_used, bytes_free, files=list())</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">


        <p>Data class representing the results of a directory listing query (<code>list_directory</code>).</p>
<p>Contains information about memory usage and the files/folders found in the queried path.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="bytes_used

  
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.FileSystemInfo.bytes_used)" href="#pytestlab.instruments.WaveformGenerator.FileSystemInfo.bytes_used">bytes_used</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>Total bytes used on the specified memory volume (INT or USB).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="bytes_free

  
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.FileSystemInfo.bytes_free)" href="#pytestlab.instruments.WaveformGenerator.FileSystemInfo.bytes_free">bytes_free</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>Total bytes free on the specified memory volume.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="files = field(default_factory=list)

  
      class-attribute
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.FileSystemInfo.files)" href="#pytestlab.instruments.WaveformGenerator.FileSystemInfo.files">files</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>A list of dictionaries, each representing a file or folder.
                          Example entry: <code>{'name': 'f.txt', 'type': 'FILE', 'size': 1024}</code>.
                          Type might be 'FILE', 'FOLDER', 'ARB', 'STAT', etc., depending on the file
                          extension and instrument response. Size is in bytes.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]]</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>










  <div class="doc doc-children">





<h5 id="pytestlab.instruments.WaveformGenerator.FileSystemInfo-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.FileSystemInfo.bytes_free" class="doc doc-heading">
            <code class="highlight language-python">bytes_free</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.FileSystemInfo.bytes_used" class="doc doc-heading">
            <code class="highlight language-python">bytes_used</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.FileSystemInfo.files" class="doc doc-heading">
            <code class="highlight language-python">files = field(default_factory=list)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.WaveformGenerator.FileSystemInfo-functions">Functions</h5>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade" class="doc doc-heading">
              <code class="highlight language-python">WGChannelFacade(wg, channel_num)</code>

</h4>


    <div class="doc doc-contents ">








                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, wg: 'WaveformGenerator', channel_num: int):
    self._wg = wg
    self._channel = channel_num</code></pre>
                  </details>



  <div class="doc doc-children">







<h5 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.disable" class="doc doc-heading">
            <code class="highlight language-python">disable()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def disable(self) -&gt; Self:
    await self._wg.set_output_state(self._channel, SCPIOnOff.OFF)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.enable" class="doc doc-heading">
            <code class="highlight language-python">enable()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def enable(self) -&gt; Self:
    await self._wg.set_output_state(self._channel, SCPIOnOff.ON)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.set_load_impedance" class="doc doc-heading">
            <code class="highlight language-python">set_load_impedance(impedance)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_load_impedance(self, impedance: Union[float, OutputLoadImpedance, str]) -&gt; Self:
    await self._wg.set_output_load_impedance(self._channel, impedance)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.set_voltage_unit" class="doc doc-heading">
            <code class="highlight language-python">set_voltage_unit(unit)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_voltage_unit(self, unit: VoltageUnit) -&gt; Self:
    await self._wg.set_voltage_unit(self._channel, unit)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_arbitrary" class="doc doc-heading">
            <code class="highlight language-python">setup_arbitrary(arb_name, sample_rate, amplitude, offset=0.0, phase=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def setup_arbitrary(self, arb_name: str, sample_rate: float, amplitude: float, offset: float = 0.0, phase: Optional[float] = None) -&gt; Self:
    await self._wg.set_function(self._channel, WaveformType.ARB)
    await self._wg.select_arbitrary_waveform(self._channel, arb_name)
    await self._wg.set_arbitrary_waveform_sample_rate(self._channel, sample_rate)
    await self._wg.set_amplitude(self._channel, amplitude)
    await self._wg.set_offset(self._channel, offset)
    if phase is not None:
        await self._wg.set_phase(self._channel, phase)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_dc" class="doc doc-heading">
            <code class="highlight language-python">setup_dc(offset)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def setup_dc(self, offset: float) -&gt; Self:
    await self._wg.set_function(self._channel, WaveformType.DC)
    await self._wg.set_offset(self._channel, offset)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_pulse" class="doc doc-heading">
            <code class="highlight language-python">setup_pulse(frequency, amplitude, offset=0.0, width=None, duty_cycle=None, transition_both=None, phase=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def setup_pulse(self, frequency: float, amplitude: float, offset: float = 0.0, width: Optional[float] = None, duty_cycle: Optional[float] = None, transition_both: Optional[float] = None, phase: Optional[float] = None) -&gt; Self:
    period = 1.0 / frequency if frequency &gt; 0 else OutputLoadImpedance.MAXIMUM

    pulse_params = {"period": period}
    if width is not None:
        pulse_params["width"] = width
    elif duty_cycle is not None:
        pulse_params["duty_cycle"] = duty_cycle
    else:
        pulse_params["duty_cycle"] = 50.0

    if transition_both is not None:
        pulse_params["transition_both"] = transition_both

    await self._wg.set_function(self._channel, WaveformType.PULSE, **pulse_params)
    await self._wg.set_amplitude(self._channel, amplitude)
    await self._wg.set_offset(self._channel, offset)
    if phase is not None:
        await self._wg.set_phase(self._channel, phase)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_ramp" class="doc doc-heading">
            <code class="highlight language-python">setup_ramp(frequency, amplitude, offset=0.0, symmetry=50.0, phase=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def setup_ramp(self, frequency: float, amplitude: float, offset: float = 0.0, symmetry: float = 50.0, phase: Optional[float] = None) -&gt; Self:
    await self._wg.set_function(self._channel, WaveformType.RAMP, symmetry=symmetry)
    await self._wg.set_frequency(self._channel, frequency)
    await self._wg.set_amplitude(self._channel, amplitude)
    await self._wg.set_offset(self._channel, offset)
    if phase is not None:
        await self._wg.set_phase(self._channel, phase)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_sine" class="doc doc-heading">
            <code class="highlight language-python">setup_sine(frequency, amplitude, offset=0.0, phase=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def setup_sine(self, frequency: float, amplitude: float, offset: float = 0.0, phase: Optional[float] = None) -&gt; Self:
    await self._wg.set_function(self._channel, WaveformType.SINE)
    await self._wg.set_frequency(self._channel, frequency)
    await self._wg.set_amplitude(self._channel, amplitude)
    await self._wg.set_offset(self._channel, offset)
    if phase is not None:
        await self._wg.set_phase(self._channel, phase)
    return self</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WGChannelFacade.setup_square" class="doc doc-heading">
            <code class="highlight language-python">setup_square(frequency, amplitude, offset=0.0, duty_cycle=50.0, phase=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def setup_square(self, frequency: float, amplitude: float, offset: float = 0.0, duty_cycle: float = 50.0, phase: Optional[float] = None) -&gt; Self:
    await self._wg.set_function(self._channel, WaveformType.SQUARE, duty_cycle=duty_cycle)
    await self._wg.set_frequency(self._channel, frequency)
    await self._wg.set_amplitude(self._channel, amplitude)
    await self._wg.set_offset(self._channel, offset)
    if phase is not None:
        await self._wg.set_phase(self._channel, phase)
    return self</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult" class="doc doc-heading">
              <code class="highlight language-python">WaveformConfigResult(channel, function, frequency, amplitude, offset, phase=None, symmetry=None, duty_cycle=None, output_state=None, load_impedance=None, voltage_unit=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">


        <p>Data class storing the retrieved waveform configuration of a channel.</p>
<p>Provides a structured way to access key parameters of the channel's current state,
obtained by querying multiple SCPI commands.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="channel

  
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.channel)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.channel">channel</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The channel number (1 or 2).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="function

  
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.function)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.function">function</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The short SCPI name of the active waveform function (e.g., "SIN", "RAMP").</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="frequency

  
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.frequency)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.frequency">frequency</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The current frequency in Hz (or sample rate in Sa/s for ARB).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="amplitude

  
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.amplitude)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.amplitude">amplitude</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The current amplitude in the configured voltage units.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="offset

  
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.offset)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.offset">offset</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The current DC offset voltage in Volts.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="phase = None

  
      class-attribute
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.phase)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.phase">phase</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The current phase offset in the configured angle units (None if not applicable).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="symmetry = None

  
      class-attribute
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.symmetry)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.symmetry">symmetry</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The current symmetry percentage for RAMP/TRIANGLE (None otherwise).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="duty_cycle = None

  
      class-attribute
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.duty_cycle)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.duty_cycle">duty_cycle</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The current duty cycle percentage for SQUARE/PULSE (None otherwise).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="output_state = None

  
      class-attribute
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.output_state)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.output_state">output_state</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The current state of the main output (True=ON, False=OFF).</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="bool">bool</span>]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="load_impedance = None

  
      class-attribute
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.load_impedance)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.load_impedance">load_impedance</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The configured load impedance (Ohms or "INFinity").</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<span title="float">float</span>, <span title="str">str</span>]]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="voltage_unit = None

  
      class-attribute
      instance-attribute
   (pytestlab.instruments.WaveformGenerator.WaveformConfigResult.voltage_unit)" href="#pytestlab.instruments.WaveformGenerator.WaveformConfigResult.voltage_unit">voltage_unit</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The currently configured voltage unit ("VPP", "VRMS", "DBM").</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>










  <div class="doc doc-children">





<h5 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.amplitude" class="doc doc-heading">
            <code class="highlight language-python">amplitude</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.channel" class="doc doc-heading">
            <code class="highlight language-python">channel</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.duty_cycle" class="doc doc-heading">
            <code class="highlight language-python">duty_cycle = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.frequency" class="doc doc-heading">
            <code class="highlight language-python">frequency</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.function" class="doc doc-heading">
            <code class="highlight language-python">function</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.load_impedance" class="doc doc-heading">
            <code class="highlight language-python">load_impedance = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.offset" class="doc doc-heading">
            <code class="highlight language-python">offset</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.output_state" class="doc doc-heading">
            <code class="highlight language-python">output_state = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.phase" class="doc doc-heading">
            <code class="highlight language-python">phase = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.symmetry" class="doc doc-heading">
            <code class="highlight language-python">symmetry = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult.voltage_unit" class="doc doc-heading">
            <code class="highlight language-python">voltage_unit = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.WaveformGenerator.WaveformConfigResult-functions">Functions</h5>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator" class="doc doc-heading">
              <code class="highlight language-python">WaveformGenerator(config, debug_mode=False, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a>[<a class="autorefs autorefs-internal" title="pytestlab.config.waveform_generator_config.WaveformGeneratorConfig (pytestlab.config.WaveformGeneratorConfig)" href="../config/#pytestlab.config.waveform_generator_config.WaveformGeneratorConfig">WaveformGeneratorConfig</a>]</code></p>


        <p>Provides a high-level Python interface for controlling Keysight EDU33210
Series Trueform Arbitrary Waveform Generators via SCPI commands.</p>

        <p>Initializes the WaveformGenerator instance.</p>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, config: WaveformGeneratorConfig, debug_mode: bool = False, **kwargs: Any) -&gt; None:
    """
    Initializes the WaveformGenerator instance.
    """
    super().__init__(config=config, debug_mode=debug_mode, **kwargs) # Pass kwargs to base
    # self.config is already set by base Instrument's __init__ due to Generic type

    # Determine channel count from the length of the channels list in the config
    if hasattr(self.config, 'channels') and isinstance(self.config.channels, list):
        self._channel_count = len(self.config.channels)
    else:
        # This case should ideally be caught by Pydantic validation of WaveformGeneratorConfig
        self._logger.warning("config.channels is not a list. Defaulting channel count to 0.")
        self._channel_count = 0

    if self._channel_count &lt;= 0:
        self._logger.warning(f"Channel count determined as {self._channel_count}. Check instrument configuration.")
        # Consider if raising an error is more appropriate if channel_count is essential and expected to be &gt; 0
        # For now, logging a warning to allow flexibility if some AWGs might be configured with 0 channels initially.

    self._logger.debug(f"Detected {self._channel_count} channels from configuration.")</code></pre>
                  </details>



  <div class="doc doc-children">





<h5 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.channel_count" class="doc doc-heading">
            <code class="highlight language-python">channel_count</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Returns the number of output channels supported by this instrument, based on configuration.</p>

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.config" class="doc doc-heading">
            <code class="highlight language-python">config</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.model_config" class="doc doc-heading">
            <code class="highlight language-python">model_config = {'arbitrary_types_allowed': True}</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.apply_waveform_settings" class="doc doc-heading">
            <code class="highlight language-python">apply_waveform_settings(channel, function_type, frequency=OutputLoadImpedance.DEFAULT, amplitude=OutputLoadImpedance.DEFAULT, offset=OutputLoadImpedance.DEFAULT)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def apply_waveform_settings(self, channel: Union[int, str], function_type: Union[WaveformType, str], frequency: Union[float, OutputLoadImpedance, str] = OutputLoadImpedance.DEFAULT, amplitude: Union[float, OutputLoadImpedance, str] = OutputLoadImpedance.DEFAULT, offset: Union[float, OutputLoadImpedance, str] = OutputLoadImpedance.DEFAULT) -&gt; None:
    ch = self._validate_channel(channel)
    scpi_short_name = self._get_scpi_function_name(function_type)
    apply_suffix_map: Dict[str, str] = { WaveformType.SINE.value: "SINusoid", WaveformType.SQUARE.value: "SQUare", WaveformType.RAMP.value: "RAMP", WaveformType.PULSE.value: "PULSe", WaveformType.NOISE.value: "NOISe", WaveformType.ARB.value: "ARBitrary", WaveformType.DC.value: "DC",}
    if scpi_short_name == "TRI" and "TRI" not in apply_suffix_map: apply_suffix_map["TRI"] = "TRIangle"
    apply_suffix = apply_suffix_map.get(scpi_short_name)
    if not apply_suffix:
        if scpi_short_name in apply_suffix_map:
            apply_suffix = apply_suffix_map[scpi_short_name]
        else:
            raise InstrumentParameterError(
                parameter="function_type",
                value=function_type,
                message=f"Waveform function (SCPI: {scpi_short_name}) not supported by APPLy.",
            )
    params: List[str] = [self._format_value_min_max_def(frequency), self._format_value_min_max_def(amplitude), self._format_value_min_max_def(offset)]
    param_str = ",".join(params)
    cmd = f"SOUR{ch}:APPLy:{apply_suffix} {param_str}"
    await self._send_command(cmd)
    self._logger.debug(f"Channel {ch}: Applied {apply_suffix} with params: Freq/SR={frequency}, Ampl={amplitude}, Offs={offset}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.channel" class="doc doc-heading">
            <code class="highlight language-python">channel(ch_num)</code>

</h6>


    <div class="doc doc-contents ">

        <p>Returns a facade for interacting with a specific channel.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>ch_num</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel number (1-based) or string identifier (e.g. "CH1").</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="str">str</span>]</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>WGChannelFacade</code>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>A facade object for the specified channel.</p>
              </div>
                <p>
                  <span class="doc-returns-annotation">
                    <b>TYPE:</b>
                      <code><a class="autorefs autorefs-internal" title="WGChannelFacade(wg, channel_num) (pytestlab.instruments.WaveformGenerator.WGChannelFacade)" href="#pytestlab.instruments.WaveformGenerator.WGChannelFacade">WGChannelFacade</a></code>
                  </span>
                </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If channel number is invalid.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
def channel(self, ch_num: Union[int,str]) -&gt; WGChannelFacade:
    """
    Returns a facade for interacting with a specific channel.

    Args:
        ch_num (Union[int,str]): The channel number (1-based) or string identifier (e.g. "CH1").

    Returns:
        WGChannelFacade: A facade object for the specified channel.

    Raises:
        InstrumentParameterError: If channel number is invalid.
    """
    validated_ch_num = self._validate_channel(ch_num) # _validate_channel returns int
    return WGChannelFacade(self, validated_ch_num)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.clear_volatile_arbitrary_waveforms" class="doc doc-heading">
            <code class="highlight language-python">clear_volatile_arbitrary_waveforms(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def clear_volatile_arbitrary_waveforms(self, channel: Union[int, str]) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"SOUR{ch}:DATA:VOLatile:CLEar")
    self._logger.debug(f"Channel {ch}: Cleared volatile arbitrary waveform memory.")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.delete_file_or_folder" class="doc doc-heading">
            <code class="highlight language-python">delete_file_or_folder(path)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def delete_file_or_folder(self, path: str) -&gt; None:
    if not path:
        raise InstrumentParameterError(
            parameter="path", message="Path cannot be empty for deletion."
        )
    path_scpi = f'"{path}"'
    cmd = f"MMEMory:DELete {path_scpi}"
    try:
        await self._send_command(cmd)
        self._logger.log(f"Attempted to delete file/folder: '{path}' using MMEM:DELete")
        await self._error_check()
    except InstrumentCommunicationError as e:
        code, msg = await self.get_error()
        if code != 0:
            if "Directory not empty" in msg or "folder" in msg.lower():
                raise InstrumentCommunicationError(
                    instrument=self.config.model,
                    command=cmd,
                    message=f"Failed to delete '{path}'. Non-empty folder? Inst Err {code}: {msg}",
                ) from e
            else:
                raise InstrumentCommunicationError(
                    instrument=self.config.model,
                    command=cmd,
                    message=f"Failed to delete '{path}'. Inst Err {code}: {msg}",
                ) from e
        else:
            raise e</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.download_arbitrary_waveform_data" class="doc doc-heading">
            <code class="highlight language-python">download_arbitrary_waveform_data(channel, arb_name, data_points, data_type='DAC', use_binary=True, is_dual_channel_data=False, dual_data_format=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def download_arbitrary_waveform_data(self, channel: Union[int, str], arb_name: str, data_points: Union[List[int], List[float], np.ndarray], data_type: str = "DAC", use_binary: bool = True, is_dual_channel_data: bool = False, dual_data_format: Optional[str] = None) -&gt; None:
    if use_binary:
        await self.download_arbitrary_waveform_data_binary(channel, arb_name, data_points, data_type, is_dual_channel_data=is_dual_channel_data, dual_data_format=dual_data_format)
    else:
        await self.download_arbitrary_waveform_data_csv(channel, arb_name, data_points, data_type)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.download_arbitrary_waveform_data_binary" class="doc doc-heading">
            <code class="highlight language-python">download_arbitrary_waveform_data_binary(channel, arb_name, data_points, data_type='DAC', is_dual_channel_data=False, dual_data_format=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def download_arbitrary_waveform_data_binary(self, channel: Union[int, str], arb_name: str, data_points: Union[List[int], List[float], np.ndarray], data_type: str = "DAC", is_dual_channel_data: bool = False, dual_data_format: Optional[str] = None) -&gt; None:
    ch = self._validate_channel(channel)
    if not re.match(r"^[a-zA-Z0-9_]{1,12}$", arb_name):
        raise InstrumentParameterError(
            parameter="arb_name",
            value=arb_name,
            message="Arbitrary waveform name is invalid.",
        )
    data_type_upper = data_type.upper().strip()
    if data_type_upper not in ["DAC", "NORM"]:
        raise InstrumentParameterError(
            parameter="data_type",
            value=data_type,
            valid_range=["DAC", "NORM"],
            message="Invalid data_type.",
        )
    np_data = np.asarray(data_points)
    if np_data.ndim != 1 or np_data.size == 0:
        raise InstrumentParameterError(
            parameter="data_points", message="data_points must be a non-empty 1D sequence."
        )
    num_points_total = np_data.size
    num_points_per_channel = num_points_total
    arb_cmd_node = "ARBitrary"
    if is_dual_channel_data:
        if self.channel_count &lt; 2:
            raise InstrumentConfigurationError(
                self.config.model,
                "Dual channel download requires 2-channel instrument.",
            )
        arb_cmd_node = "ARBitrary2"
        if num_points_total % 2 != 0:
            raise InstrumentParameterError(
                parameter="data_points",
                message="Total data_points must be even for dual channel.",
            )
        num_points_per_channel = num_points_total // 2
        if dual_data_format:
            fmt_upper = dual_data_format.upper().strip()
            if fmt_upper not in ["AABB", "ABAB"]:
                raise InstrumentParameterError(
                    parameter="dual_data_format",
                    value=dual_data_format,
                    valid_range=["AABB", "ABAB"],
                    message="Invalid dual_data_format.",
                )
            await self._send_command(f"SOUR{ch}:DATA:{arb_cmd_node}:FORMat {fmt_upper}")
            await self._error_check()
            self._logger.debug(f"Channel {ch}: Dual arb data format set to {fmt_upper}")
    binary_data: bytes
    scpi_suffix: str
    transfer_type_log_msg: str = "Binary Block"
    if data_type_upper == "DAC":
        scpi_suffix = ":DAC"
        if not np.issubdtype(np_data.dtype, np.integer):
            self._logger.warning("Warning: DAC data not integer, converting to int16.")
            try:
                np_data = np_data.astype(np.int16)
            except ValueError as e:
                raise InstrumentParameterError(
                    parameter="data_points",
                    message="Cannot convert DAC data to int16.",
                ) from e
        dac_min, dac_max = getattr(self.config.waveforms, 'arbitrary_dac_range', (-32768, 32767))
        if np.any(np_data &lt; dac_min) or np.any(np_data &gt; dac_max):
            raise InstrumentParameterError(
                parameter="data_points",
                message=f"DAC data out of range [{dac_min}, {dac_max}].",
            )
        binary_data = np_data.astype('&lt;h').tobytes()
    else: # NORM
        scpi_suffix = ""
        if not np.issubdtype(np_data.dtype, np.floating):
            self._logger.warning("Warning: Normalized data not float, converting to float32.")
            try:
                np_data = np_data.astype(np.float32)
            except ValueError as e:
                raise InstrumentParameterError(
                    parameter="data_points",
                    message="Cannot convert Normalized data to float32.",
                ) from e
        norm_min, norm_max = -1.0, 1.0
        tolerance = 1e-6
        if np.any(np_data &lt; norm_min - tolerance) or np.any(
            np_data &gt; norm_max + tolerance
        ):
            raise InstrumentParameterError(
                parameter="data_points",
                message=f"Normalized data out of range [{norm_min}, {norm_max}].",
            )
        np_data = np.clip(np_data, norm_min, norm_max)
        binary_data = np_data.astype('&lt;f').tobytes()
    cmd_prefix = f"SOUR{ch}:DATA:{arb_cmd_node}{scpi_suffix} {arb_name},"
    try:
        await self._write_binary(cmd_prefix, binary_data) # Assumed async
        transfer_type_log_msg = "IEEE 488.2 Binary Block via _write_binary"
        self._logger.debug(f"Channel {ch}: Downloaded arb '{arb_name}' via {transfer_type_log_msg} ({num_points_per_channel} pts/ch, {len(binary_data)} bytes, type: {data_type_upper})")
        await self._error_check()
    except InstrumentCommunicationError as e:
        self._logger.error(f"Error during {transfer_type_log_msg} arb download for '{arb_name}'.")
        code, msg = await self.get_error()
        if code == 786:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd_prefix,
                message=f"Arb Name Conflict (786) for '{arb_name}'.",
            ) from e
        elif code == 781:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd_prefix,
                message=f"Out of Memory (781) for '{arb_name}'.",
            ) from e
        elif code == -113:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd_prefix,
                message=f"SCPI Syntax Error (-113) for '{arb_name}'.",
            ) from e
        elif code != 0:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd_prefix,
                message=f"Arb download for '{arb_name}' failed. Inst Err {code}: {msg}",
            ) from e
        else:
            raise e
    except Exception as e:
        self._logger.error(f"Unexpected error during binary arb download for '{arb_name}': {e}")
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd_prefix,
            message=f"Unexpected failure downloading arb '{arb_name}'",
        ) from e</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.download_arbitrary_waveform_data_csv" class="doc doc-heading">
            <code class="highlight language-python">download_arbitrary_waveform_data_csv(channel, arb_name, data_points, data_type='DAC')</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def download_arbitrary_waveform_data_csv(self, channel: Union[int, str], arb_name: str, data_points: Union[List[int], List[float], np.ndarray], data_type: str = "DAC") -&gt; None:
    ch = self._validate_channel(channel)
    if not re.match(r"^[a-zA-Z0-9_]{1,12}$", arb_name):
        raise InstrumentParameterError(
            parameter="arb_name",
            value=arb_name,
            message="Arbitrary waveform name is invalid.",
        )
    data_type_upper = data_type.upper().strip()
    if data_type_upper not in ["DAC", "NORM"]:
        raise InstrumentParameterError(
            parameter="data_type",
            value=data_type,
            valid_range=["DAC", "NORM"],
            message="Invalid data_type.",
        )
    np_data = np.asarray(data_points)
    if np_data.ndim != 1 or np_data.size == 0:
        raise InstrumentParameterError(
            parameter="data_points", message="data_points must be a non-empty 1D sequence."
        )
    if 0 &lt;= (ch - 1) &lt; len(self.config.channels):
        channel_conf = self.config.channels[ch-1]
        if hasattr(channel_conf, 'arbitrary') and hasattr(channel_conf.arbitrary, 'max_points') and np_data.size &gt; channel_conf.arbitrary.max_points:
            self._logger.warning(f"Number of data points ({np_data.size}) exceeds configured max_points ({channel_conf.arbitrary.max_points}) for CH{ch}.")
    formatted_data: str
    scpi_suffix: str
    if data_type_upper == "DAC":
        if not np.issubdtype(np_data.dtype, np.integer):
            self._logger.warning("DAC data not integer, converting to int16.")
            try:
                np_data = np_data.astype(np.int16)
            except ValueError as e:
                raise InstrumentParameterError(
                    parameter="data_points",
                    message="Cannot convert DAC data to int16.",
                ) from e
        dac_min, dac_max = getattr(self.config.waveforms, 'arbitrary_dac_range', (-32768, 32767))
        if np.any(np_data &lt; dac_min) or np.any(np_data &gt; dac_max):
            raise InstrumentParameterError(
                parameter="data_points",
                message=f"DAC data out of range [{dac_min}, {dac_max}].",
            )
        formatted_data = ','.join(map(str, np_data))
        scpi_suffix = ":DAC"
    else: # NORM
        if not np.issubdtype(np_data.dtype, np.floating):
            self._logger.warning("Normalized data not float, converting to float32.")
            try:
                np_data = np_data.astype(np.float32)
            except ValueError as e:
                raise InstrumentParameterError(
                    parameter="data_points",
                    message="Cannot convert Normalized data to floats.",
                ) from e
        norm_min, norm_max = -1.0, 1.0
        tolerance = 1e-9
        if np.any(np_data &lt; norm_min - tolerance) or np.any(
            np_data &gt; norm_max + tolerance
        ):
            raise InstrumentParameterError(
                parameter="data_points",
                message=f"Normalized data out of range [{norm_min}, {norm_max}].",
            )
        np_data = np.clip(np_data, norm_min, norm_max)
        formatted_data = ','.join(map(lambda x: f"{x:.8G}", np_data))
        scpi_suffix = ""
    cmd = f"SOUR{ch}:DATA:ARBitrary{scpi_suffix} {arb_name},{formatted_data}"
    max_cmd_len = getattr(self.config, 'max_scpi_command_length', 10000)
    if len(cmd) &gt; max_cmd_len: self._logger.warning(f"SCPI command length ({len(cmd)}) large. Consider binary transfer.")
    try:
        await self._send_command(cmd)
        self._logger.debug(f"Channel {ch}: Downloaded arb '{arb_name}' via CSV ({np_data.size} points, type: {data_type_upper})")
        await self._error_check()
    except InstrumentCommunicationError as e:
        self._logger.error(f"Error during CSV arb download for '{arb_name}'.")
        code, msg = await self.get_error()
        if code == -113:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd,
                message=f"SCPI Syntax Error (-113) for '{arb_name}'.",
            ) from e
        elif code == 786:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd,
                message=f"Arb Name Conflict (786) for '{arb_name}'.",
            ) from e
        elif code == 781:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd,
                message=f"Out of Memory (781) for '{arb_name}'.",
            ) from e
        elif code == -102:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd,
                message=f"SCPI Syntax Error (-102) for '{arb_name}'.",
            ) from e
        elif code != 0:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd,
                message=f"Arb download for '{arb_name}' failed. Inst Err {code}: {msg}",
            ) from e
        else:
            raise e</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.enable_burst" class="doc doc-heading">
            <code class="highlight language-python">enable_burst(channel, state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def enable_burst(self, channel: Union[int, str], state: bool) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value
    await self._send_command(f"SOUR{ch}:BURSt:STATe {cmd_state}")
    self._logger.log(f"Channel {ch}: Burst state set to {cmd_state}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.enable_modulation" class="doc doc-heading">
            <code class="highlight language-python">enable_modulation(channel, mod_type, state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def enable_modulation(self, channel: Union[int, str], mod_type: str, state: bool) -&gt; None:
    ch = self._validate_channel(channel)
    mod_upper = mod_type.upper().strip()
    valid_mods = {"AM", "FM", "PM", "PWM", "FSK", "BPSK", "SUM"}
    if mod_upper not in valid_mods:
        raise InstrumentParameterError(
            parameter="mod_type",
            value=mod_type,
            valid_range=valid_mods,
            message="Invalid modulation type.",
        )
    cmd_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value
    await self._send_command(f"SOUR{ch}:{mod_upper}:STATe {cmd_state}")
    self._logger.log(f"Channel {ch}: {mod_upper} modulation state set to {cmd_state}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.enable_sweep" class="doc doc-heading">
            <code class="highlight language-python">enable_sweep(channel, state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def enable_sweep(self, channel: Union[int, str], state: bool) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_state = SCPIOnOff.ON.value if state else SCPIOnOff.OFF.value
    await self._send_command(f"SOUR{ch}:SWEep:STATe {cmd_state}")
    self._logger.log(f"Channel {ch}: Sweep state set to {cmd_state}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.from_config" class="doc doc-heading">
            <code class="highlight language-python">from_config(config, debug_mode=False, **kwargs)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
@validate_call
def from_config(cls: Type['WaveformGenerator'], config: WaveformGeneratorConfig, debug_mode: bool = False, **kwargs: Any) -&gt; 'WaveformGenerator':
    return cls(config=config, debug_mode=debug_mode, **kwargs)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_amplitude" class="doc doc-heading">
            <code class="highlight language-python">get_amplitude(channel, query_type=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_amplitude(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:
    ch = self._validate_channel(channel)
    cmd = f"SOUR{ch}:VOLTage?"
    type_str = ""
    if query_type: cmd += f" {query_type.value}"; type_str = f" ({query_type.name} limit)"
    response = (await self._query(cmd)).strip()
    try:
        amp = float(response)
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd,
            message=f"Failed to parse amplitude float from response: '{response}'",
        )
    unit = await self.get_voltage_unit(ch)
    self._logger.debug(f"Channel {ch}: Amplitude{type_str} is {amp} {unit.value}")
    return amp</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_angle_unit" class="doc doc-heading">
            <code class="highlight language-python">get_angle_unit()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_angle_unit(self) -&gt; str:
    response = (await self._query("UNIT:ANGLe?")).strip().upper()
    if response not in ["DEG", "RAD", "SEC"]: self._logger.warning(f"Warning: Unexpected angle unit response '{response}'.")
    self._logger.debug(f"Current global angle unit is {response}")
    return response</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_arbitrary_waveform_points" class="doc doc-heading">
            <code class="highlight language-python">get_arbitrary_waveform_points(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_arbitrary_waveform_points(self, channel: Union[int, str]) -&gt; int:
    ch = self._validate_channel(channel)
    try:
        response = (await self._query(f"SOUR{ch}:FUNC:ARB:POINts?")).strip()
        points = int(response)
        self._logger.debug(f"Channel {ch}: Currently selected arbitrary waveform has {points} points")
        return points
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=f"SOUR{ch}:FUNC:ARB:POINts?",
            message=f"Failed to parse integer points from response: '{response}'",
        )
    except InstrumentCommunicationError as e:
        code, msg = await self.get_error()
        if code != 0:
            self._logger.warning(f"Query SOUR{ch}:FUNC:ARB:POINts? failed. Inst Err {code}: {msg}. Returning 0.")
            return 0
        else:
            raise e</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_arbitrary_waveform_sample_rate" class="doc doc-heading">
            <code class="highlight language-python">get_arbitrary_waveform_sample_rate(channel, query_type=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_arbitrary_waveform_sample_rate(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:
    ch = self._validate_channel(channel)
    cmd = f"SOUR{ch}:FUNC:ARB:SRATe?"
    type_str = ""
    if query_type: cmd += f" {query_type.value}"; type_str = f" ({query_type.name} limit)"
    response = (await self._query(cmd)).strip()
    try:
        sr = float(response)
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd,
            message=f"Failed to parse sample rate float from response: '{response}'",
        )
    self._logger.debug(f"Channel {ch}: Arbitrary waveform sample rate{type_str} is {sr} Sa/s")
    return sr</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_channel_configuration_summary" class="doc doc-heading">
            <code class="highlight language-python">get_channel_configuration_summary(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_channel_configuration_summary(self, channel: Union[int, str]) -&gt; str:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:APPLy?")).strip()
    self._logger.debug(f"Channel {ch}: Configuration summary (APPLy?) returned: {response}")
    if response.startswith('"') and response.endswith('"') and response.count('"') == 2 : return response[1:-1]
    return response</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_complete_config" class="doc doc-heading">
            <code class="highlight language-python">get_complete_config(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_complete_config(self, channel: Union[int, str]) -&gt; WaveformConfigResult:
    ch_num = self._validate_channel(channel)
    self._logger.debug(f"Getting complete configuration snapshot for channel {ch_num}...")
    func_scpi_str = await self.get_function(ch_num)
    freq = await self.get_frequency(ch_num)
    ampl = await self.get_amplitude(ch_num)
    offs = await self.get_offset(ch_num)
    output_state_enum = await self.get_output_state(ch_num)
    output_state_bool = True if output_state_enum == SCPIOnOff.ON else False
    load_impedance_val = await self.get_output_load_impedance(ch_num)
    load_impedance_str: Union[str, float]
    if isinstance(load_impedance_val, OutputLoadImpedance) and load_impedance_val == OutputLoadImpedance.INFINITY:
        load_impedance_str = "INFinity"
    else:
        load_impedance_str = float(load_impedance_val)
    voltage_unit_enum = await self.get_voltage_unit(ch_num)
    voltage_unit_str = voltage_unit_enum.value
    phase: Optional[float] = None
    if func_scpi_str not in [WaveformType.DC.value, WaveformType.NOISE.value]:
        try:
            phase = await self.get_phase(ch_num)
        except InstrumentCommunicationError as e:
            self._log(f"Note: Phase query failed for CH{ch_num} (function: {func_scpi_str}): {e}", level="info")
    symmetry: Optional[float] = None
    duty_cycle: Optional[float] = None
    try:
        if func_scpi_str == WaveformType.RAMP.value:
            symmetry = await self.get_ramp_symmetry(ch_num)
        elif func_scpi_str == WaveformType.SQUARE.value:
            duty_cycle = await self.get_square_duty_cycle(ch_num)
        elif func_scpi_str == WaveformType.PULSE.value:
            duty_cycle = await self.get_pulse_duty_cycle(ch_num)
    except InstrumentCommunicationError as e:
        self._log(f"Note: Query failed for function-specific parameter for CH{ch_num} func {func_scpi_str}: {e}", level="info")
    return WaveformConfigResult(channel=ch_num, function=func_scpi_str, frequency=freq, amplitude=ampl, offset=offs, phase=phase, symmetry=symmetry, duty_cycle=duty_cycle, output_state=output_state_bool, load_impedance=load_impedance_str, voltage_unit=voltage_unit_str)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_free_volatile_arbitrary_memory" class="doc doc-heading">
            <code class="highlight language-python">get_free_volatile_arbitrary_memory(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_free_volatile_arbitrary_memory(self, channel: Union[int, str]) -&gt; int:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:DATA:VOLatile:FREE?")).strip()
    try:
        free_points = int(response)
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=f"SOUR{ch}:DATA:VOLatile:FREE?",
            message=f"Unexpected non-integer response: {response}",
        )
    self._logger.debug(f"Channel {ch}: Free volatile arbitrary memory: {free_points} points")
    return free_points</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_frequency" class="doc doc-heading">
            <code class="highlight language-python">get_frequency(channel, query_type=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_frequency(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:
    ch = self._validate_channel(channel)
    cmd = f"SOUR{ch}:FREQ?"
    type_str = ""
    if query_type: cmd += f" {query_type.value}"; type_str = f" ({query_type.name} limit)"
    response = (await self._query(cmd)).strip()
    try:
        freq = float(response)
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd,
            message=f"Failed to parse frequency float from response: '{response}'",
        )
    self._logger.debug(f"Channel {ch}: Frequency{type_str} is {freq} Hz")
    return freq</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_function" class="doc doc-heading">
            <code class="highlight language-python">get_function(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_function(self, channel: Union[int, str]) -&gt; str:
    ch = self._validate_channel(channel)
    scpi_func = (await self._query(f"SOUR{ch}:FUNC?")).strip()
    self._logger.debug(f"Channel {ch}: Current function is {scpi_func}")
    return scpi_func</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_offset" class="doc doc-heading">
            <code class="highlight language-python">get_offset(channel, query_type=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_offset(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:
    ch = self._validate_channel(channel)
    cmd = f"SOUR{ch}:VOLTage:OFFSet?"
    type_str = ""
    if query_type: cmd += f" {query_type.value}"; type_str = f" ({query_type.name} limit)"
    response = (await self._query(cmd)).strip()
    try:
        offs = float(response)
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd,
            message=f"Failed to parse offset float from response: '{response}'",
        )
    self._logger.debug(f"Channel {ch}: Offset{type_str} is {offs} V")
    return offs</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_output_load_impedance" class="doc doc-heading">
            <code class="highlight language-python">get_output_load_impedance(channel, query_type=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_output_load_impedance(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; Union[float, OutputLoadImpedance]:
    ch = self._validate_channel(channel)
    cmd = f"OUTPut{ch}:LOAD?"
    type_str = ""
    if query_type: cmd += f" {query_type.value}"; type_str = f" ({query_type.name} limit)"
    response = (await self._query(cmd)).strip()
    self._logger.debug(f"Channel {ch}: Raw impedance response{type_str} is '{response}'")
    try:
        numeric_response = float(response)
        if abs(numeric_response - 9.9e37) &lt; 1e30: return OutputLoadImpedance.INFINITY
        else: return numeric_response
    except ValueError:
        if response.upper() == OutputLoadImpedance.INFINITY.value.upper(): return OutputLoadImpedance.INFINITY
        for enum_member in OutputLoadImpedance:
            if response.upper() == enum_member.value.upper(): return enum_member
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd,
            message=f"Could not parse impedance response: '{response}'",
        )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_output_polarity" class="doc doc-heading">
            <code class="highlight language-python">get_output_polarity(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_output_polarity(self, channel: Union[int, str]) -&gt; OutputPolarity:
    ch = self._validate_channel(channel)
    response = (await self._query(f"OUTPut{ch}:POLarity?")).strip().upper()
    try:
        return OutputPolarity(response)
    except ValueError:
        if response == "NORM": return OutputPolarity.NORMAL
        if response == "INV": return OutputPolarity.INVERTED
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=f"OUTPut{ch}:POLarity?",
            message=f"Unexpected polarity response from instrument: {response}",
        )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_output_state" class="doc doc-heading">
            <code class="highlight language-python">get_output_state(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_output_state(self, channel: Union[int, str]) -&gt; SCPIOnOff:
    ch = self._validate_channel(channel)
    response = (await self._query(f"OUTPut{ch}:STATe?")).strip()
    state = SCPIOnOff.ON if response == "1" else SCPIOnOff.OFF
    self._logger.debug(f"Channel {ch}: Output state is {state.value}")
    return state</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_phase" class="doc doc-heading">
            <code class="highlight language-python">get_phase(channel, query_type=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_phase(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:
    ch = self._validate_channel(channel)
    cmd = f"SOUR{ch}:PHASe?"
    type_str = ""
    if query_type: cmd += f" {query_type.value}"; type_str = f" ({query_type.name} limit)"
    response = (await self._query(cmd)).strip()
    try:
        ph = float(response)
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd,
            message=f"Failed to parse phase float from response: '{response}'",
        )
    unit = await self.get_angle_unit()
    self._logger.debug(f"Channel {ch}: Phase{type_str} is {ph} {unit}")
    return ph</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_phase_unlock_error_state" class="doc doc-heading">
            <code class="highlight language-python">get_phase_unlock_error_state()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_phase_unlock_error_state(self) -&gt; SCPIOnOff:
    response = (await self._query("SOUR1:PHASe:UNLock:ERRor:STATe?")).strip()
    state = SCPIOnOff.ON if response == "1" else SCPIOnOff.OFF
    self._logger.debug(f"Phase unlock error state is {state.value}")
    return state</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_duty_cycle" class="doc doc-heading">
            <code class="highlight language-python">get_pulse_duty_cycle(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_pulse_duty_cycle(self, channel: Union[int, str]) -&gt; float:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:PULS:DCYCle?")).strip()
    return float(response)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_hold_mode" class="doc doc-heading">
            <code class="highlight language-python">get_pulse_hold_mode(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_pulse_hold_mode(self, channel: Union[int, str]) -&gt; str:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:PULS:HOLD?")).strip().upper()
    return response</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_period" class="doc doc-heading">
            <code class="highlight language-python">get_pulse_period(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_pulse_period(self, channel: Union[int, str]) -&gt; float:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:PULS:PERiod?")).strip()
    return float(response)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_transition_both" class="doc doc-heading">
            <code class="highlight language-python">get_pulse_transition_both(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_pulse_transition_both(self, channel: Union[int, str]) -&gt; float:
    warnings.warn("Querying PULS:TRAN:BOTH; specific query may not exist or might return leading edge time.", UserWarning, stacklevel=2)
    return await self.get_pulse_transition_leading(channel)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_transition_leading" class="doc doc-heading">
            <code class="highlight language-python">get_pulse_transition_leading(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_pulse_transition_leading(self, channel: Union[int, str]) -&gt; float:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:PULS:TRANsition:LEADing?")).strip()
    return float(response)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_transition_trailing" class="doc doc-heading">
            <code class="highlight language-python">get_pulse_transition_trailing(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_pulse_transition_trailing(self, channel: Union[int, str]) -&gt; float:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:PULS:TRANsition:TRAiling?")).strip()
    return float(response)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_pulse_width" class="doc doc-heading">
            <code class="highlight language-python">get_pulse_width(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_pulse_width(self, channel: Union[int, str]) -&gt; float:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:PULS:WIDTh?")).strip()
    return float(response)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_ramp_symmetry" class="doc doc-heading">
            <code class="highlight language-python">get_ramp_symmetry(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_ramp_symmetry(self, channel: Union[int, str]) -&gt; float:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:RAMP:SYMMetry?")).strip()
    return float(response)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_selected_arbitrary_waveform_name" class="doc doc-heading">
            <code class="highlight language-python">get_selected_arbitrary_waveform_name(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_selected_arbitrary_waveform_name(self, channel: Union[int, str]) -&gt; str:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:ARBitrary?")).strip()
    if response.startswith('"') and response.endswith('"'): response = response[1:-1]
    self._logger.debug(f"Channel {ch}: Currently selected arbitrary waveform is '{response}'")
    return response</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_square_duty_cycle" class="doc doc-heading">
            <code class="highlight language-python">get_square_duty_cycle(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_square_duty_cycle(self, channel: Union[int, str]) -&gt; float:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:SQUare:DCYCle?")).strip()
    return float(response)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_square_period" class="doc doc-heading">
            <code class="highlight language-python">get_square_period(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_square_period(self, channel: Union[int, str]) -&gt; float:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:FUNC:SQUare:PERiod?")).strip()
    return float(response)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_sync_output_mode" class="doc doc-heading">
            <code class="highlight language-python">get_sync_output_mode(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_sync_output_mode(self, channel: Union[int, str]) -&gt; SyncMode:
    ch = self._validate_channel(channel)
    response = (await self._query(f"OUTPut{ch}:SYNC:MODE?")).strip().upper()
    try:
        return SyncMode(response)
    except ValueError:
        if response == "NORM": return SyncMode.NORMAL
        if response == "CARR": return SyncMode.CARRIER
        if response == "MARK": return SyncMode.MARKER
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=f"OUTPut{ch}:SYNC:MODE?",
            message=f"Unexpected sync mode response from instrument: {response}",
        )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_sync_output_polarity" class="doc doc-heading">
            <code class="highlight language-python">get_sync_output_polarity(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_sync_output_polarity(self, channel: Union[int, str]) -&gt; OutputPolarity:
    ch = self._validate_channel(channel)
    response = (await self._query(f"OUTPut{ch}:SYNC:POLarity?")).strip().upper()
    try:
        return OutputPolarity(response)
    except ValueError:
        if response == "NORM": return OutputPolarity.NORMAL
        if response == "INV": return OutputPolarity.INVERTED
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=f"OUTPut{ch}:SYNC:POLarity?",
            message=f"Unexpected sync polarity response from instrument: {response}",
        )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_sync_output_source" class="doc doc-heading">
            <code class="highlight language-python">get_sync_output_source()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_sync_output_source(self) -&gt; int:
    response = (await self._query("OUTPut:SYNC:SOURce?")).strip().upper()
    match = re.match(r"CH(\d+)", response)
    if match:
        src_ch = int(match.group(1))
        self._logger.debug(f"Sync output source is CH{src_ch}")
        return src_ch
    else:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command="OUTPut:SYNC:SOURce?",
            message=f"Unexpected response querying Sync source: '{response}'",
        )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_sync_output_state" class="doc doc-heading">
            <code class="highlight language-python">get_sync_output_state()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_sync_output_state(self) -&gt; SCPIOnOff:
    response = (await self._query("OUTPut:SYNC:STATe?")).strip()
    state = SCPIOnOff.ON if response == "1" else SCPIOnOff.OFF
    self._logger.debug(f"Sync output state is {state.value}")
    return state</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_autorange_state" class="doc doc-heading">
            <code class="highlight language-python">get_voltage_autorange_state(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_voltage_autorange_state(self, channel: Union[int, str]) -&gt; SCPIOnOff:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:VOLTage:RANGe:AUTO?")).strip()
    state = SCPIOnOff.ON if response == "1" else SCPIOnOff.OFF
    self._logger.debug(f"Channel {ch}: Voltage autorange state is {state.value} (Query response: {response})")
    return state</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_limit_high" class="doc doc-heading">
            <code class="highlight language-python">get_voltage_limit_high(channel, query_type=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_voltage_limit_high(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:
    ch = self._validate_channel(channel)
    cmd = f"SOUR{ch}:VOLTage:LIMit:HIGH?"
    type_str = ""
    if query_type: cmd += f" {query_type.value}"; type_str = f" ({query_type.name} possible)"
    response = (await self._query(cmd)).strip()
    try:
        val = float(response)
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd,
            message=f"Failed to parse high limit float from response: '{response}'",
        )
    self._logger.debug(f"Channel {ch}: Voltage high limit{type_str} is {val} V")
    return val</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_limit_low" class="doc doc-heading">
            <code class="highlight language-python">get_voltage_limit_low(channel, query_type=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_voltage_limit_low(self, channel: Union[int, str], query_type: Optional[OutputLoadImpedance] = None) -&gt; float:
    ch = self._validate_channel(channel)
    cmd = f"SOUR{ch}:VOLTage:LIMit:LOW?"
    type_str = ""
    if query_type: cmd += f" {query_type.value}"; type_str = f" ({query_type.name} possible)"
    response = (await self._query(cmd)).strip()
    try:
        val = float(response)
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd,
            message=f"Failed to parse low limit float from response: '{response}'",
        )
    self._logger.debug(f"Channel {ch}: Voltage low limit{type_str} is {val} V")
    return val</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_limits_state" class="doc doc-heading">
            <code class="highlight language-python">get_voltage_limits_state(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_voltage_limits_state(self, channel: Union[int, str]) -&gt; SCPIOnOff:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:VOLTage:LIMit:STATe?")).strip()
    state = SCPIOnOff.ON if response == "1" else SCPIOnOff.OFF
    self._logger.debug(f"Channel {ch}: Voltage limits state is {state.value}")
    return state</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.get_voltage_unit" class="doc doc-heading">
            <code class="highlight language-python">get_voltage_unit(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def get_voltage_unit(self, channel: Union[int, str]) -&gt; VoltageUnit:
    ch = self._validate_channel(channel)
    response = (await self._query(f"SOUR{ch}:VOLTage:UNIT?")).strip().upper()
    try:
        return VoltageUnit(response)
    except ValueError:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=f"SOUR{ch}:VOLTage:UNIT?",
            message=f"Unexpected voltage unit response from instrument: {response}",
        )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.list_directory" class="doc doc-heading">
            <code class="highlight language-python">list_directory(path='')</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def list_directory(self, path: str = "") -&gt; FileSystemInfo:
    path_scpi = f' "{path}"' if path else ""
    cmd = f"MMEMory:CATalog:ALL?{path_scpi}"
    response = (await self._query(cmd)).strip()
    try:
        parts = response.split(',', 2)
        if len(parts) &lt; 2:
            raise InstrumentCommunicationError(
                instrument=self.config.model,
                command=cmd,
                message=f"Unexpected response format from MMEM:CAT?: {response}",
            )
        bytes_used = int(parts[0])
        bytes_free = int(parts[1])
        info = FileSystemInfo(bytes_used=bytes_used, bytes_free=bytes_free)
        if len(parts) &gt; 2 and parts[2]:
            file_pattern = r'"([^"]+),([^"]*),(\d+)"'
            listings = re.findall(file_pattern, parts[2])
            for name, ftype, size_str in listings:
                file_type = ftype if ftype else 'FILE'
                try:
                    size = int(size_str)
                except ValueError:
                    self._log(f"Warning: Could not parse size '{size_str}' for file '{name}'.", level="warning")
                    continue
                info.files.append({'name': name, 'type': file_type.upper(), 'size': size})
        self._logger.log(f"Directory listing for '{path or 'current dir'}': Used={info.bytes_used}, Free={info.bytes_free}, Items={len(info.files)}")
        return info
    except (ValueError, IndexError) as e:
        raise InstrumentCommunicationError(
            instrument=self.config.model,
            command=cmd,
            message=f"Failed to parse MMEM:CAT? response: '{response}'. Error: {e}",
        ) from e</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.select_arbitrary_waveform" class="doc doc-heading">
            <code class="highlight language-python">select_arbitrary_waveform(channel, arb_name)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def select_arbitrary_waveform(self, channel: Union[int, str], arb_name: str) -&gt; None:
    ch = self._validate_channel(channel)
    if not arb_name:
        raise InstrumentParameterError(
            parameter="arb_name", message="Arbitrary waveform name cannot be empty."
        )
    if '"' in arb_name or "'" in arb_name:
        raise InstrumentParameterError(
            parameter="arb_name",
            value=arb_name,
            message="Arbitrary waveform name cannot contain quotes.",
        )
    quoted_arb_name = f'"{arb_name}"'
    await self._send_command(f"SOUR{ch}:FUNC:ARBitrary {quoted_arb_name}")
    self._logger.debug(f"Channel {ch}: Active arbitrary waveform selection set to '{arb_name}'")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_am_depth" class="doc doc-heading">
            <code class="highlight language-python">set_am_depth(channel, depth_percent)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_am_depth(self, channel: Union[int, str], depth_percent: Union[float, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val = self._format_value_min_max_def(depth_percent)
    if isinstance(depth_percent, (int, float)) and not (0 &lt;= float(depth_percent) &lt;= 120):
        self._log(f"Warning: AM depth {depth_percent}% is outside typical 0-120 range.", level="warning")
    await self._send_command(f"SOUR{ch}:AM:DEPTh {cmd_val}")
    self._logger.log(f"Channel {ch}: AM depth set to {depth_percent}%")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_am_source" class="doc doc-heading">
            <code class="highlight language-python">set_am_source(channel, source)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_am_source(self, channel: Union[int, str], source: ModulationSource) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_src = source.value
    if cmd_src == f"CH{ch}":
        raise InstrumentParameterError(
            parameter="source",
            value=source,
            message=f"Channel {ch} cannot be its own AM source.",
        )
    if cmd_src == ModulationSource.CH2.value and self.channel_count &lt; 2:
        raise InstrumentParameterError(
            parameter="source",
            value=source,
            message="CH2 source invalid for 1-channel instrument.",
        )
    await self._send_command(f"SOUR{ch}:AM:SOURce {cmd_src}")
    self._logger.log(f"Channel {ch}: AM source set to {cmd_src}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_amplitude" class="doc doc-heading">
            <code class="highlight language-python">set_amplitude(channel, amplitude)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_amplitude(self, channel: Union[int, str], amplitude: Union[float, OutputLoadImpedance, str]) -&gt; None:
    ch = self._validate_channel(channel)
    amp_cmd_val = self._format_value_min_max_def(amplitude)
    if isinstance(amplitude, (int, float)):
        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):
            channel_config_model = self.config.channels[ch-1]
            channel_config_model.amplitude.assert_in_range(float(amplitude), name=f"Amplitude for CH{ch}")
    await self._send_command(f"SOUR{ch}:VOLTage {amp_cmd_val}")
    unit = await self.get_voltage_unit(ch)
    self._logger.debug(f"Channel {ch}: Amplitude set to {amplitude} (in current unit: {unit.value}, using SCPI value: {amp_cmd_val})")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_angle_unit" class="doc doc-heading">
            <code class="highlight language-python">set_angle_unit(unit)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_angle_unit(self, unit: str) -&gt; None:
    unit_upper = unit.upper().strip()
    valid_scpi_units = {"DEGREE", "RADIAN", "SECOND", "DEG", "RAD", "SEC"}
    map_to_scpi_preferred = {"DEG": "DEGREE", "DEGREES": "DEGREE", "RAD": "RADIAN", "RADIANS": "RADIAN", "SEC": "SECOND", "SECONDS": "SECOND"}
    scpi_to_send = map_to_scpi_preferred.get(unit_upper, unit_upper)
    if scpi_to_send not in valid_scpi_units and unit_upper not in valid_scpi_units :
        raise InstrumentParameterError(
            parameter="unit",
            value=unit,
            valid_range=["DEGREE", "RADIAN", "SECONd"],
            message="Invalid angle unit.",
        )
    await self._send_command(f"UNIT:ANGLe {scpi_to_send}")
    self._logger.debug(f"Global angle unit set to {scpi_to_send}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_arbitrary_waveform_sample_rate" class="doc doc-heading">
            <code class="highlight language-python">set_arbitrary_waveform_sample_rate(channel, sample_rate)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_arbitrary_waveform_sample_rate(self, channel: Union[int, str], sample_rate: Union[float, OutputLoadImpedance, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val = self._format_value_min_max_def(sample_rate)
    if isinstance(sample_rate, (int, float)):
        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):
            channel_config_model = self.config.channels[ch-1]
            if hasattr(channel_config_model, 'arbitrary') and hasattr(channel_config_model.arbitrary, 'sampling_rate'):
                channel_config_model.arbitrary.sampling_rate.assert_in_range(float(sample_rate), name=f"Arbitrary sample rate for CH{ch}")
    await self._send_command(f"SOUR{ch}:FUNC:ARB:SRATe {cmd_val}")
    self._logger.debug(f"Channel {ch}: Arbitrary waveform sample rate set to {sample_rate} Sa/s (using SCPI value: {cmd_val})")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_burst_cycles" class="doc doc-heading">
            <code class="highlight language-python">set_burst_cycles(channel, n_cycles)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_burst_cycles(self, channel: Union[int, str], n_cycles: Union[int, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val: str
    log_val: Union[int, str] = n_cycles
    if isinstance(n_cycles, str):
        nc_upper = n_cycles.upper().strip()
        if nc_upper in {"MIN", "MINIMUM"}:
            cmd_val = OutputLoadImpedance.MINIMUM.value
        elif nc_upper in {"MAX", "MAXIMUM"}:
            cmd_val = OutputLoadImpedance.MAXIMUM.value
        elif nc_upper in {"INF", "INFINITY"}:
            cmd_val = "INFinity"
        else:
            raise InstrumentParameterError(
                parameter="n_cycles",
                value=n_cycles,
                message="Invalid string for burst cycles.",
            )
    elif isinstance(n_cycles, int):
        if n_cycles &lt; 1:
            raise InstrumentParameterError(
                parameter="n_cycles",
                value=n_cycles,
                message="Burst cycle count must be positive.",
            )
        inst_max_cycles = 100_000_000
        if n_cycles &gt; inst_max_cycles:
            self._log(f"Warning: Burst cycles {n_cycles} &gt; typical max ({inst_max_cycles}).", level="warning")
        cmd_val = str(n_cycles)
    else:
        raise InstrumentParameterError(
            parameter="n_cycles",
            value=n_cycles,
            message=f"Invalid type '{type(n_cycles)}' for burst cycles.",
        )
    await self._send_command(f"SOUR{ch}:BURSt:NCYCles {cmd_val}")
    self._logger.log(f"Channel {ch}: Burst cycles set to {log_val}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_burst_mode" class="doc doc-heading">
            <code class="highlight language-python">set_burst_mode(channel, mode)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_burst_mode(self, channel: Union[int, str], mode: BurstMode) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"SOUR{ch}:BURSt:MODE {mode.value}")
    self._logger.log(f"Channel {ch}: Burst mode set to {mode.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_burst_period" class="doc doc-heading">
            <code class="highlight language-python">set_burst_period(channel, period_sec)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_burst_period(self, channel: Union[int, str], period_sec: Union[float, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val = self._format_value_min_max_def(period_sec)
    await self._send_command(f"SOUR{ch}:BURSt:INTernal:PERiod {cmd_val}")
    self._logger.log(f"Channel {ch}: Internal burst period set to {period_sec} s")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_fm_deviation" class="doc doc-heading">
            <code class="highlight language-python">set_fm_deviation(channel, deviation_hz)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_fm_deviation(self, channel: Union[int, str], deviation_hz: Union[float, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val = self._format_value_min_max_def(deviation_hz)
    await self._send_command(f"SOUR{ch}:FM:DEViation {cmd_val}")
    self._logger.log(f"Channel {ch}: FM deviation set to {deviation_hz} Hz")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_frequency" class="doc doc-heading">
            <code class="highlight language-python">set_frequency(channel, frequency)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_frequency(self, channel: Union[int, str], frequency: Union[float, OutputLoadImpedance, str]) -&gt; None:
    ch = self._validate_channel(channel)
    freq_cmd_val = self._format_value_min_max_def(frequency)
    if isinstance(frequency, (int, float)):
        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):
            channel_config_model = self.config.channels[ch - 1]
            channel_config_model.frequency.assert_in_range(float(frequency), name=f"Frequency for CH{ch}")
    await self._send_command(f"SOUR{ch}:FREQ {freq_cmd_val}")
    self._logger.debug(f"Channel {ch}: Frequency set to {frequency} Hz (using SCPI value: {freq_cmd_val})")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_function" class="doc doc-heading">
            <code class="highlight language-python">set_function(channel, function_type, **kwargs)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the primary waveform function and associated parameters for a channel.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_function(self, channel: Union[int, str], function_type: Union[WaveformType, str], **kwargs: Any) -&gt; None:
    """
    Sets the primary waveform function and associated parameters for a channel.
    """
    ch = self._validate_channel(channel)
    scpi_func_short = self._get_scpi_function_name(function_type)

    standard_params_set: Dict[str, bool] = {}
    # Assuming FUNC_ARB should be WaveformType.ARB.value
    if 'frequency' in kwargs and scpi_func_short != WaveformType.ARB.value:
        await self.set_frequency(ch, kwargs.pop('frequency'))
        standard_params_set['frequency'] = True
    if 'amplitude' in kwargs:
        await self.set_amplitude(ch, kwargs.pop('amplitude'))
        standard_params_set['amplitude'] = True
    if 'offset' in kwargs:
        await self.set_offset(ch, kwargs.pop('offset'))
        standard_params_set['offset'] = True

    await self._send_command(f"SOUR{ch}:FUNC {scpi_func_short}")
    self._logger.debug(f"Channel {ch}: Function set to {function_type} (SCPI: {scpi_func_short})")
    await self._error_check()

    if kwargs:
        # Ensure WAVEFORM_PARAM_COMMANDS keys are WaveformType enum members
        # And scpi_func_short is mapped to its corresponding WaveformType enum member if it's a string
        func_enum_key: Optional[WaveformType] = None
        if isinstance(function_type, WaveformType):
            func_enum_key = function_type
        elif isinstance(function_type, str):
            try:
                # First try to convert SCPI string directly to enum member
                func_enum_key = WaveformType(scpi_func_short)
            except ValueError:
                # If that fails, try to map profile config values to enum members
                scpi_to_enum_map = {
                    "SINUSOID": WaveformType.SINE,
                    "SQUARE": WaveformType.SQUARE,
                    "RAMP": WaveformType.RAMP,
                    "PULSE": WaveformType.PULSE,
                    "NOISE": WaveformType.NOISE,
                    "DC": WaveformType.DC,
                    "ARB": WaveformType.ARB,
                    "ARBITRARY": WaveformType.ARB,
                    # Add enum values as fallback
                    "SIN": WaveformType.SINE,
                    "SQU": WaveformType.SQUARE,
                    "PULS": WaveformType.PULSE,
                    "NOIS": WaveformType.NOISE,
                }
                func_enum_key = scpi_to_enum_map.get(scpi_func_short.upper())
                if func_enum_key is None:
                    self._logger.warning(f"SCPI function '{scpi_func_short}' not mappable to WaveformType enum for parameter lookup.")

        param_cmds_for_func = WAVEFORM_PARAM_COMMANDS.get(func_enum_key) if func_enum_key else None

        if not param_cmds_for_func:
            self._logger.warning(f"No specific parameters defined for function '{function_type}' (SCPI: {scpi_func_short}). "
                      f"Ignoring remaining kwargs: {kwargs}")
            if any(k not in standard_params_set for k in kwargs):
                raise InstrumentParameterError(
                    message=f"Unknown parameters {list(kwargs.keys())} passed for function {function_type}."
                )
            return

        for param_name, value in kwargs.items():
            if param_name in param_cmds_for_func:
                try:
                    if param_name in ["duty_cycle", "symmetry"] and isinstance(value, (int, float)):
                        if not (0 &lt;= float(value) &lt;= 100):
                            self._logger.warning(f"Parameter '{param_name}' value {value}% is outside the "
                                      f"typical 0-100 range. Instrument validation will apply.")

                    value_to_format = value
                    if isinstance(value, (ArbFilterType, ArbAdvanceMode)): # Pass enum value for formatting
                        value_to_format = value.value

                    formatted_value = self._format_value_min_max_def(value_to_format)
                    cmd_lambda = param_cmds_for_func[param_name]
                    cmd = cmd_lambda(ch, formatted_value)

                    await self._send_command(cmd)
                    self._logger.debug(f"Channel {ch}: Parameter '{param_name}' set to {value}")
                    await self._error_check()
                except InstrumentParameterError as ipe:
                    raise InstrumentParameterError(
                        parameter=param_name,
                        value=value,
                        message=f"Invalid value for function '{function_type}'. Cause: {ipe}",
                    ) from ipe
                except InstrumentCommunicationError:
                    raise
                except Exception as e:
                    self._logger.error(f"Error setting parameter '{param_name}' for function '{scpi_func_short}': {e}")
                    raise InstrumentCommunicationError(
                        instrument=self.config.model,
                        command=cmd,
                        message=f"Failed to set parameter {param_name}",
                    ) from e
            else:
                raise InstrumentParameterError(
                    parameter=param_name,
                    message=f"Parameter is not supported for function '{function_type}' ({scpi_func_short}). Supported: {list(param_cmds_for_func.keys())}",
                )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_offset" class="doc doc-heading">
            <code class="highlight language-python">set_offset(channel, offset)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_offset(self, channel: Union[int, str], offset: Union[float, OutputLoadImpedance, str]) -&gt; None:
    ch = self._validate_channel(channel)
    offset_cmd_val = self._format_value_min_max_def(offset)
    await self._send_command(f"SOUR{ch}:VOLTage:OFFSet {offset_cmd_val}")
    self._logger.debug(f"Channel {ch}: Offset set to {offset} V")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_output_load_impedance" class="doc doc-heading">
            <code class="highlight language-python">set_output_load_impedance(channel, impedance)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_output_load_impedance(self, channel: Union[int, str], impedance: Union[float, OutputLoadImpedance, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_impedance = self._format_value_min_max_def(impedance)
    if isinstance(impedance, (int, float)):
        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):
            channel_config_model = self.config.channels[ch-1]
            if hasattr(channel_config_model, 'output') and hasattr(channel_config_model.output, 'load_impedance'):
                channel_config_model.output.load_impedance.assert_in_range(float(impedance), name=f"Load impedance for CH{ch}")
    await self._send_command(f"OUTPut{ch}:LOAD {cmd_impedance}")
    self._logger.debug(f"Channel {ch}: Output load impedance setting updated to {impedance} (using SCPI value: {cmd_impedance})")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_output_polarity" class="doc doc-heading">
            <code class="highlight language-python">set_output_polarity(channel, polarity)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_output_polarity(self, channel: Union[int, str], polarity: OutputPolarity) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"OUTPut{ch}:POLarity {polarity.value}")
    self._logger.debug(f"Channel {ch}: Output polarity set to {polarity.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_output_state" class="doc doc-heading">
            <code class="highlight language-python">set_output_state(channel, state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call # Duplicated @validate_call removed
async def set_output_state(self, channel: Union[int, str], state: SCPIOnOff) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"OUTPut{ch}:STATe {state.value}")
    self._logger.debug(f"Channel {ch}: Output state set to {state.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_phase" class="doc doc-heading">
            <code class="highlight language-python">set_phase(channel, phase)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_phase(self, channel: Union[int, str], phase: Union[float, OutputLoadImpedance, str]) -&gt; None:
    ch = self._validate_channel(channel)
    phase_cmd_val = self._format_value_min_max_def(phase)
    if isinstance(phase, (int, float)):
        if 0 &lt;= (ch - 1) &lt; len(self.config.channels):
            channel_config_model = self.config.channels[ch-1]
            channel_config_model.phase.assert_in_range(float(phase), name=f"Phase for CH{ch}")
    await self._send_command(f"SOUR{ch}:PHASe {phase_cmd_val}")
    unit = await self.get_angle_unit()
    self._logger.debug(f"Channel {ch}: Phase set to {phase} (in current unit: {unit}, using SCPI value: {phase_cmd_val})")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_phase_reference" class="doc doc-heading">
            <code class="highlight language-python">set_phase_reference(channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_phase_reference(self, channel: Union[int, str]) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"SOUR{ch}:PHASe:REFerence")
    self._logger.debug(f"Channel {ch}: Phase reference reset (current phase defined as 0).")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_phase_unlock_error_state" class="doc doc-heading">
            <code class="highlight language-python">set_phase_unlock_error_state(state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_phase_unlock_error_state(self, state: SCPIOnOff) -&gt; None:
    await self._send_command(f"SOUR1:PHASe:UNLock:ERRor:STATe {state.value}")
    self._logger.debug(f"Phase unlock error state set to {state.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sweep_spacing" class="doc doc-heading">
            <code class="highlight language-python">set_sweep_spacing(channel, spacing)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_sweep_spacing(self, channel: Union[int, str], spacing: SweepSpacing) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"SOUR{ch}:SWEep:SPACing {spacing.value}")
    self._logger.debug(f"Channel {ch}: Sweep spacing set to {spacing.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sweep_start_frequency" class="doc doc-heading">
            <code class="highlight language-python">set_sweep_start_frequency(channel, freq_hz)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_sweep_start_frequency(self, channel: Union[int, str], freq_hz: Union[float, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val = self._format_value_min_max_def(freq_hz)
    await self._send_command(f"SOUR{ch}:FREQuency:STARt {cmd_val}")
    self._logger.debug(f"Channel {ch}: Sweep start frequency set to {freq_hz} Hz")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sweep_stop_frequency" class="doc doc-heading">
            <code class="highlight language-python">set_sweep_stop_frequency(channel, freq_hz)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_sweep_stop_frequency(self, channel: Union[int, str], freq_hz: Union[float, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val = self._format_value_min_max_def(freq_hz)
    await self._send_command(f"SOUR{ch}:FREQuency:STOP {cmd_val}")
    self._logger.debug(f"Channel {ch}: Sweep stop frequency set to {freq_hz} Hz")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sweep_time" class="doc doc-heading">
            <code class="highlight language-python">set_sweep_time(channel, sweep_time_sec)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_sweep_time(self, channel: Union[int, str], sweep_time_sec: Union[float, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val = self._format_value_min_max_def(sweep_time_sec)
    await self._send_command(f"SOUR{ch}:SWEep:TIME {cmd_val}")
    self._logger.log(f"Channel {ch}: Sweep time set to {sweep_time_sec} s")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sync_output_mode" class="doc doc-heading">
            <code class="highlight language-python">set_sync_output_mode(channel, mode)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_sync_output_mode(self, channel: Union[int, str], mode: SyncMode) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"OUTPut{ch}:SYNC:MODE {mode.value}")
    self._logger.debug(f"Channel {ch}: Sync output mode set to {mode.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sync_output_polarity" class="doc doc-heading">
            <code class="highlight language-python">set_sync_output_polarity(channel, polarity)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_sync_output_polarity(self, channel: Union[int, str], polarity: OutputPolarity) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"OUTPut{ch}:SYNC:POLarity {polarity.value}")
    self._logger.debug(f"Channel {ch}: Sync output polarity set to {polarity.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sync_output_source" class="doc doc-heading">
            <code class="highlight language-python">set_sync_output_source(source_channel)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_sync_output_source(self, source_channel: int) -&gt; None:
    ch_to_set = self._validate_channel(source_channel)
    await self._send_command(f"OUTPut:SYNC:SOURce CH{ch_to_set}")
    self._logger.debug(f"Sync output source set to CH{ch_to_set}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_sync_output_state" class="doc doc-heading">
            <code class="highlight language-python">set_sync_output_state(state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_sync_output_state(self, state: SCPIOnOff) -&gt; None:
    await self._send_command(f"OUTPut:SYNC:STATe {state.value}")
    self._logger.debug(f"Sync output state set to {state.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_trigger_slope" class="doc doc-heading">
            <code class="highlight language-python">set_trigger_slope(channel, slope)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_trigger_slope(self, channel: Union[int, str], slope: TriggerSlope) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"TRIGger{ch}:SLOPe {slope.value}")
    self._logger.log(f"Channel {ch}: Trigger slope set to {slope.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_trigger_source" class="doc doc-heading">
            <code class="highlight language-python">set_trigger_source(channel, source)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_trigger_source(self, channel: Union[int, str], source: TriggerSource) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"TRIGger{ch}:SOURce {source.value}")
    self._logger.log(f"Channel {ch}: Trigger source set to {source.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_autorange_state" class="doc doc-heading">
            <code class="highlight language-python">set_voltage_autorange_state(channel, state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_voltage_autorange_state(self, channel: Union[int, str], state: SCPIOnOff) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"SOUR{ch}:VOLTage:RANGe:AUTO {state.value}")
    self._logger.debug(f"Channel {ch}: Voltage autorange state set to {state.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_limit_high" class="doc doc-heading">
            <code class="highlight language-python">set_voltage_limit_high(channel, voltage)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_voltage_limit_high(self, channel: Union[int, str], voltage: Union[float, OutputLoadImpedance, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val = self._format_value_min_max_def(voltage)
    await self._send_command(f"SOUR{ch}:VOLTage:LIMit:HIGH {cmd_val}")
    self._logger.debug(f"Channel {ch}: Voltage high limit set to {voltage} V (using SCPI value: {cmd_val})")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_limit_low" class="doc doc-heading">
            <code class="highlight language-python">set_voltage_limit_low(channel, voltage)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_voltage_limit_low(self, channel: Union[int, str], voltage: Union[float, OutputLoadImpedance, str]) -&gt; None:
    ch = self._validate_channel(channel)
    cmd_val = self._format_value_min_max_def(voltage)
    await self._send_command(f"SOUR{ch}:VOLTage:LIMit:LOW {cmd_val}")
    self._logger.debug(f"Channel {ch}: Voltage low limit set to {voltage} V (using SCPI value: {cmd_val})")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_limits_state" class="doc doc-heading">
            <code class="highlight language-python">set_voltage_limits_state(channel, state)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_voltage_limits_state(self, channel: Union[int, str], state: SCPIOnOff) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"SOUR{ch}:VOLTage:LIMit:STATe {state.value}")
    self._logger.debug(f"Channel {ch}: Voltage limits state set to {state.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.set_voltage_unit" class="doc doc-heading">
            <code class="highlight language-python">set_voltage_unit(channel, unit)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def set_voltage_unit(self, channel: Union[int, str], unit: VoltageUnit) -&gt; None:
    ch = self._validate_channel(channel)
    await self._send_command(f"SOUR{ch}:VOLTage:UNIT {unit.value}")
    self._logger.debug(f"Channel {ch}: Voltage unit set to {unit.value}")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.synchronize_phase_all_channels" class="doc doc-heading">
            <code class="highlight language-python">synchronize_phase_all_channels()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">@validate_call
async def synchronize_phase_all_channels(self) -&gt; None:
    if self.channel_count &lt; 2:
        self._logger.warning("Warning: Phase synchronization command sent, but primarily intended for multi-channel instruments.")
    await self._send_command("PHASe:SYNChronize")
    self._logger.debug("All channels/internal phase generators synchronized.")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.WaveformGenerator.WaveformGenerator.trigger_now" class="doc doc-heading">
            <code class="highlight language-python">trigger_now(channel=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/WaveformGenerator.py</code></summary>
              <pre class="highlight"><code class="language-python">async def trigger_now(self, channel: Optional[Union[int, str]] = None) -&gt; None:
    if channel is not None:
        ch = self._validate_channel(channel)
        await self._send_command(f"TRIGger{ch}")
        self._logger.log(f"Sent immediate channel-specific trigger command TRIGger{ch}")
    else:
        await self._send_command("*TRG")
        self._logger.log("Sent general bus trigger command *TRG")
    await self._error_check()</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="multimeter">Multimeter</h3>


<div class="doc doc-object doc-module">



<h2 id="pytestlab.instruments.Multimeter" class="doc doc-heading">
            <code>pytestlab.instruments.Multimeter</code>


</h2>

    <div class="doc doc-contents first">









  <div class="doc doc-children">





<h3 id="pytestlab.instruments.Multimeter-attributes">Attributes</h3>

<div class="doc doc-object doc-attribute">



<h4 id="pytestlab.instruments.Multimeter.logger" class="doc doc-heading">
            <code class="highlight language-python">logger = get_logger(__name__)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-module-attribute"><code>module-attribute</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

    </div>

</div>
<h3 id="pytestlab.instruments.Multimeter-classes">Classes</h3>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Multimeter.Multimeter" class="doc doc-heading">
              <code class="highlight language-python">Multimeter(config, backend, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a>[<a class="autorefs autorefs-internal" title="pytestlab.config.multimeter_config.MultimeterConfig" href="../config/#pytestlab.config.multimeter_config.MultimeterConfig">MultimeterConfig</a>]</code></p>


        <p>Drives a Digital Multimeter (DMM) for various measurements.</p>
<p>This class provides a high-level interface for controlling a DMM, building
upon the base <code>Instrument</code> class. It includes methods for common DMM
operations such as measuring voltage, current, resistance, and frequency.
It also handles instrument-specific configurations and can incorporate
measurement uncertainty based on the provided configuration.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="config

  
      instance-attribute
   (pytestlab.instruments.Multimeter.Multimeter.config)" href="#pytestlab.instruments.Multimeter.Multimeter.config">config</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The Pydantic configuration object (<code>MultimeterConfig</code>)
    containing settings specific to this DMM.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><a class="autorefs autorefs-internal" title="pytestlab.config.multimeter_config.MultimeterConfig" href="../config/#pytestlab.config.multimeter_config.MultimeterConfig">MultimeterConfig</a></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO
    """
    Initialize the Instrument class.

    Args:
        config (ConfigType): Configuration for the instrument.
        backend (AsyncInstrumentIO): The communication backend instance.
        **kwargs: Additional keyword arguments.
    """
    if not isinstance(config, InstrumentConfig): # Check against the bound base
        raise InstrumentConfigurationError(
            self.__class__.__name__,
            f"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.",
        )

    self.config = config
    self._backend = backend # This will be an AsyncInstrumentIO instance
    self._command_log = []

    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__
    self._logger = get_logger(logger_name)

    self._logger.info(f"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.")</code></pre>
                  </details>



  <div class="doc doc-children">





<h5 id="pytestlab.instruments.Multimeter.Multimeter-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Multimeter.Multimeter.config" class="doc doc-heading">
            <code class="highlight language-python">config</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.Multimeter.Multimeter-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Multimeter.Multimeter.configure_measurement" class="doc doc-heading">
            <code class="highlight language-python">configure_measurement(function, range_val=None, resolution=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configures the instrument for a measurement without triggering it.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Multimeter.py</code></summary>
              <pre class="highlight"><code class="language-python">async def configure_measurement(self, function: DMMFunction, range_val: Optional[str] = None, resolution: Optional[str] = None):
    """Configures the instrument for a measurement without triggering it."""
    scpi_function_val = function.value
    range_for_query = range_val.upper() if range_val is not None else "AUTO"
    resolution_for_query = resolution.upper() if resolution is not None else "DEF"
    # Using CONFigure command as per programming guide page 44
    cmd = f"CONFigure:{scpi_function_val} {range_for_query},{resolution_for_query}"
    await self._send_command(cmd)
    self._logger.info(f"Configured DMM for {function.name} with range={range_for_query}, resolution={resolution_for_query}")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Multimeter.Multimeter.from_config" class="doc doc-heading">
            <code class="highlight language-python">from_config(config, debug_mode=False)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Multimeter.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
def from_config(cls: Type["Multimeter"], config: MultimeterConfig, debug_mode: bool = False) -&gt; "Multimeter":
    # This method is generally handled by the `AutoInstrument` factory.
    # It's provided here for completeness but direct instantiation is preferred
    # when not using the factory.
    # If config is a dict that needs to be passed to MultimeterConfig constructor:
    # return cls(config=MultimeterConfig(**config), debug_mode=debug_mode)
    # If config is already a MultimeterConfig instance:
    raise NotImplementedError("Please use AutoInstrument.from_config() to create instrument instances.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Multimeter.Multimeter.get_config" class="doc doc-heading">
            <code class="highlight language-python">get_config()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Retrieves the current measurement configuration from the DMM.</p>
<p>This method queries the instrument to determine its current settings,
such as the active measurement function, range, and resolution. It then
parses this information into a structured <code>MultimeterConfigResult</code> object.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><a class="autorefs autorefs-internal" title="MultimeterConfigResult(measurement_mode, range_value, resolution, units='')

  
      dataclass
   (pytestlab.instruments.Multimeter.MultimeterConfigResult)" href="#pytestlab.instruments.Multimeter.MultimeterConfigResult">MultimeterConfigResult</a></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>A <code>MultimeterConfigResult</code> dataclass instance with the DMM's current</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><a class="autorefs autorefs-internal" title="MultimeterConfigResult(measurement_mode, range_value, resolution, units='')

  
      dataclass
   (pytestlab.instruments.Multimeter.MultimeterConfigResult)" href="#pytestlab.instruments.Multimeter.MultimeterConfigResult">MultimeterConfigResult</a></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>configuration.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><span title="pytestlab.errors.InstrumentDataError">InstrumentDataError</span></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the configuration string from the DMM
                 cannot be parsed.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Multimeter.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_config(self) -&gt; MultimeterConfigResult:
    """Retrieves the current measurement configuration from the DMM.

    This method queries the instrument to determine its current settings,
    such as the active measurement function, range, and resolution. It then
    parses this information into a structured `MultimeterConfigResult` object.

    Returns:
        A `MultimeterConfigResult` dataclass instance with the DMM's current
        configuration.

    Raises:
        InstrumentDataError: If the configuration string from the DMM
                             cannot be parsed.
    """
    # Query the instrument for its current configuration. The response is typically
    # a string like '"VOLT:DC 10,0.0001"'.
    config_str: str = (await self._query("CONFigure?")).replace('"', '').strip()
    try:
        # Handle cases where resolution is not returned, e.g., "FRES 1.000000E+02"
        parts = config_str.split()
        mode_part = parts[0]

        # Settings part can be complex, find first comma
        settings_part = " ".join(parts[1:])
        if ',' in settings_part:
            range_str, resolution_str = settings_part.split(",", 1)
        else:
            range_str = settings_part
            resolution_str = "N/A" # Resolution not specified in query response

        # Parse the string to extract the mode, range, and resolution.
        range_value_float: float = float(range_str)
    except (ValueError, IndexError) as e:
        raise InstrumentDataError(self.config.model, f"Failed to parse configuration string: '{config_str}'") from e

    # Determine human-friendly measurement mode and assign units based on mode
    measurement_mode_str: str = "" # Renamed
    unit_str: str = "" # Renamed
    mode_upper: str = mode_part.upper()
    if mode_upper.startswith("VOLT"):
        measurement_mode_str = "Voltage"
        unit_str = "V"
    elif mode_upper.startswith("CURR"):
        measurement_mode_str = "Current"
        unit_str = "A"
    elif "RES" in mode_upper: # Catches RES and FRES
        measurement_mode_str = "Resistance"
        unit_str = "Ohm"
    elif "FREQ" in mode_upper:
        measurement_mode_str = "Frequency"
        unit_str = "Hz"
    elif mode_upper.startswith("TEMP"):
        measurement_mode_str = "Temperature"
        unit_str = "°C"  # Default; could also be °F depending on settings
    else:
        measurement_mode_str = mode_part

    return MultimeterConfigResult(
        measurement_mode=measurement_mode_str,
        range_value=range_value_float,
        resolution=resolution_str.strip(),
        units=unit_str
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Multimeter.Multimeter.measure" class="doc doc-heading">
            <code class="highlight language-python">measure(function, range_val=None, resolution=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Performs a measurement and returns the result.</p>
<p>This is the primary method for acquiring data from the DMM. It configures
the measurement, triggers it, and reads the result. If measurement
accuracy specifications are provided in the instrument's configuration,
this method will calculate the uncertainty and return the value as a
<code>UFloat</code> object.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>function</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The measurement function to perform (e.g., DC Voltage).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="pytestlab.config.multimeter_config.DMMFunction">DMMFunction</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>range_val</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The measurement range (e.g., "1V", "AUTO"). If not provided,
       "AUTO" is used. The value is validated against the ranges
       defined in the instrument's configuration.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>resolution</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The desired resolution (e.g., "MIN", "MAX", "DEF"). If not
        provided, "DEF" (default) is used.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><a class="autorefs autorefs-internal" title="pytestlab.experiments.results.MeasurementResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs)" href="../experiments/#pytestlab.experiments.results.MeasurementResult">MeasurementResult</a></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>A <code>MeasurementResult</code> object containing the measured value (as a float</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><a class="autorefs autorefs-internal" title="pytestlab.experiments.results.MeasurementResult(values, instrument, units, measurement_type, timestamp=None, envelope=None, sampling_rate=None, **kwargs)" href="../experiments/#pytestlab.experiments.results.MeasurementResult">MeasurementResult</a></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>or <code>UFloat</code>), units, and other metadata.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If an unsupported <code>range_val</code> is provided.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Multimeter.py</code></summary>
              <pre class="highlight"><code class="language-python">async def measure(self, function: DMMFunction, range_val: Optional[str] = None, resolution: Optional[str] = None) -&gt; MeasurementResult:
    """Performs a measurement and returns the result.

    This is the primary method for acquiring data from the DMM. It configures
    the measurement, triggers it, and reads the result. If measurement
    accuracy specifications are provided in the instrument's configuration,
    this method will calculate the uncertainty and return the value as a
    `UFloat` object.

    Args:
        function: The measurement function to perform (e.g., DC Voltage).
        range_val: The measurement range (e.g., "1V", "AUTO"). If not provided,
                   "AUTO" is used. The value is validated against the ranges
                   defined in the instrument's configuration.
        resolution: The desired resolution (e.g., "MIN", "MAX", "DEF"). If not
                    provided, "DEF" (default) is used.

    Returns:
        A `MeasurementResult` object containing the measured value (as a float
        or `UFloat`), units, and other metadata.

    Raises:
        InstrumentParameterError: If an unsupported `range_val` is provided.
    """
    scpi_function_val = function.value
    is_autorange = range_val is None or range_val.upper() == "AUTO"

    # The MEASure command is a combination of CONFigure, INITiate, and FETCh.
    # This is convenient but makes querying the actual range used in autorange tricky.
    # For accurate uncertainty, we will use CONFigure separately when in autorange.
    if is_autorange:
        await self.set_measurement_function(function)
        await self._send_command(f"{function.value}:RANGe:AUTO ON")
        if resolution:
            await self._send_command(f"{function.value}:RESolution {resolution.upper()}")

        response_str = await self._query("READ?")
    else:
        # Use the combined MEASure? command for fixed range
        range_for_query = range_val.upper() if range_val is not None else "AUTO"
        resolution_for_query = resolution.upper() if resolution is not None else "DEF"
        query_command = f"MEASURE:{scpi_function_val}? {range_for_query},{resolution_for_query}"
        self._logger.debug(f"Executing DMM measure query: {query_command}")
        response_str = await self._query(query_command)

    try:
        reading = float(response_str)
    except ValueError:
        raise InstrumentDataError(self.config.instrument['model'], f"Could not parse measurement reading: '{response_str}'")

    value_to_return: Union[float, UFloat] = reading

    # --- Uncertainty Calculation ---
    function_spec = self._get_function_spec(function)
    if function_spec:
        try:
            # Determine the actual range used by the instrument to find the correct spec
            current_instrument_config = await self.get_config()
            actual_instrument_range = current_instrument_config.range_value

            # Find the matching range specification
            matching_range_spec = None
            # Find the smallest nominal range that is &gt;= the actual range used.
            # Assumes specs in YAML are sorted by nominal value, which is typical.
            for r_spec in sorted(function_spec.ranges, key=lambda r: r.nominal):
                if r_spec.nominal &gt;= actual_instrument_range:
                    matching_range_spec = r_spec
                    break

            # Fallback to the largest range if no suitable one is found (e.g. if actual &gt; largest nominal)
            if not matching_range_spec:
                matching_range_spec = max(function_spec.ranges, key=lambda r: r.nominal)

            if matching_range_spec:
                accuracy_spec = matching_range_spec.default_accuracy
                if accuracy_spec:
                    # Use the spec's nominal value for the '% of range' calculation
                    range_for_calc = matching_range_spec.nominal
                    std_dev = accuracy_spec.calculate_uncertainty(reading, range_for_calc)
                    if std_dev &gt; 0:
                        value_to_return = ufloat(reading, std_dev)
                        self._logger.debug(f"Applied accuracy spec for range {range_for_calc}, value: {value_to_return}")
                    else:
                         self._logger.debug(f"Calculated uncertainty is zero. Returning float.")
                else:
                    self._logger.warning(f"No applicable accuracy specification found for function '{function.name}' at range {actual_instrument_range}. Returning float.")
            else:
                self._logger.warning(f"Could not find a matching range specification for function '{function.name}' at range {actual_instrument_range}. Returning float.")

        except Exception as e:
            self._logger.error(f"Error during uncertainty calculation: {e}. Returning float.")
    else:
        self._logger.debug(f"No measurement function specification in config for '{function.name}'. Returning float.")

    units_val, measurement_name_val = self._get_measurement_unit_and_type(function)

    return MeasurementResult(
        values=value_to_return,
        instrument=self.config.model,
        units=units_val,
        measurement_type=measurement_name_val,
    )</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Multimeter.Multimeter.set_measurement_function" class="doc doc-heading">
            <code class="highlight language-python">set_measurement_function(function)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configures the primary measurement function of the DMM.</p>
<p>This method sets the DMM to measure a specific quantity, such as DC
Voltage, AC Current, or Resistance.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>function</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The desired measurement function, as defined by the
      <code>DMMFunction</code> enum.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="pytestlab.config.multimeter_config.DMMFunction">DMMFunction</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Multimeter.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_measurement_function(self, function: DMMFunction) -&gt; None:
    """Configures the primary measurement function of the DMM.

    This method sets the DMM to measure a specific quantity, such as DC
    Voltage, AC Current, or Resistance.

    Args:
        function: The desired measurement function, as defined by the
                  `DMMFunction` enum.
    """
    # Using the recommended SCPI command from the programming guide (page 145)
    await self._send_command(f'SENSe:FUNCtion "{function.value}"')
    self._logger.info(f"Set measurement function to {function.name} ({function.value})")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Multimeter.Multimeter.set_trigger_source" class="doc doc-heading">
            <code class="highlight language-python">set_trigger_source(source)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the trigger source for initiating a measurement.</p>
<p>The trigger source determines what event will cause the DMM to start
taking a reading.
- "IMM": Immediate, the DMM triggers as soon as it's ready.
- "EXT": External, a hardware signal on the rear panel triggers the DMM.
- "BUS": A software command (<code>*TRG</code>) triggers the DMM.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>source</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The desired trigger source.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Literal">Literal</span>[&#39;IMM&#39;, &#39;EXT&#39;, &#39;BUS&#39;]</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Multimeter.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_trigger_source(self, source: Literal["IMM", "EXT", "BUS"]) -&gt; None:
    """Sets the trigger source for initiating a measurement.

    The trigger source determines what event will cause the DMM to start
    taking a reading.
    - "IMM": Immediate, the DMM triggers as soon as it's ready.
    - "EXT": External, a hardware signal on the rear panel triggers the DMM.
    - "BUS": A software command (`*TRG`) triggers the DMM.

    Args:
        source: The desired trigger source.
    """
    await self._send_command(f"TRIG:SOUR {source.upper()}")
    self._logger.info(f"Set trigger source to {source}")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.Multimeter.MultimeterConfigResult" class="doc doc-heading">
              <code class="highlight language-python">MultimeterConfigResult(measurement_mode, range_value, resolution, units='')</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-dataclass"><code>dataclass</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">


        <p>Stores the current measurement configuration of the multimeter.</p>
<p>This data class holds the state of the multimeter's configuration at a
point in time, such as the measurement mode, range, and resolution. It is
typically returned by methods that query the instrument's status.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">ATTRIBUTE</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="measurement_mode

  
      instance-attribute
   (pytestlab.instruments.Multimeter.MultimeterConfigResult.measurement_mode)" href="#pytestlab.instruments.Multimeter.MultimeterConfigResult.measurement_mode">measurement_mode</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The type of measurement being made (e.g., "Voltage").</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="range_value

  
      instance-attribute
   (pytestlab.instruments.Multimeter.MultimeterConfigResult.range_value)" href="#pytestlab.instruments.Multimeter.MultimeterConfigResult.range_value">range_value</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The configured measurement range.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="resolution

  
      instance-attribute
   (pytestlab.instruments.Multimeter.MultimeterConfigResult.resolution)" href="#pytestlab.instruments.Multimeter.MultimeterConfigResult.resolution">resolution</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The configured resolution.</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="units = ''

  
      class-attribute
      instance-attribute
   (pytestlab.instruments.Multimeter.MultimeterConfigResult.units)" href="#pytestlab.instruments.Multimeter.MultimeterConfigResult.units">units</a></code></td>
            <td class="doc-attribute-details">
              <div class="doc-md-description">
                <p>The units for the measurement range (e.g., "V", "A").</p>
              </div>
              <p>
                  <span class="doc-attribute-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>










  <div class="doc doc-children">





<h5 id="pytestlab.instruments.Multimeter.MultimeterConfigResult-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Multimeter.MultimeterConfigResult.measurement_mode" class="doc doc-heading">
            <code class="highlight language-python">measurement_mode</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Multimeter.MultimeterConfigResult.range_value" class="doc doc-heading">
            <code class="highlight language-python">range_value</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Multimeter.MultimeterConfigResult.resolution" class="doc doc-heading">
            <code class="highlight language-python">resolution</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.Multimeter.MultimeterConfigResult.units" class="doc doc-heading">
            <code class="highlight language-python">units = ''</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.Multimeter.MultimeterConfigResult-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.Multimeter.MultimeterConfigResult.__str__" class="doc doc-heading">
            <code class="highlight language-python">__str__()</code>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/Multimeter.py</code></summary>
              <pre class="highlight"><code class="language-python">def __str__(self) -&gt; str:
    return (f"Measurement Mode: {self.measurement_mode}\n"
            f"Range: {self.range_value} {self.units}\n"
            f"Resolution: {self.resolution}")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>
<h3 id="pytestlab.instruments.Multimeter-functions">Functions</h3>



  </div>

    </div>

</div><h3 id="dc-active-load">DC Active Load</h3>


<div class="doc doc-object doc-module">



<h2 id="pytestlab.instruments.DCActiveLoad" class="doc doc-heading">
            <code>pytestlab.instruments.DCActiveLoad</code>


</h2>

    <div class="doc doc-contents first">









  <div class="doc doc-children">






<h3 id="pytestlab.instruments.DCActiveLoad-classes">Classes</h3>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad" class="doc doc-heading">
              <code class="highlight language-python">DCActiveLoad(config, backend, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a></code></p>


        <p>Drives a DC Electronic Load instrument, such as the Keysight EL30000 series.</p>
<p>This class provides a driver for controlling a DC Active Load, enabling
programmatic control over its operating modes and settings. It is designed
to work with SCPI-compliant instruments and leverages a detailed Pydantic
configuration model to provide uncertainty-aware measurements and feature-rich
control.</p>
<p>The driver supports the following primary operations:
- Setting the operating mode (Constant Current, Voltage, Power, Resistance).
- Programming the load value for the current mode.
- Enabling or disabling the load's input.
- Measuring voltage, current, and power with uncertainty.
- Configuring and controlling transient and battery test modes.</p>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, config: DCActiveLoadConfig, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None:
    super().__init__(config, backend, **kwargs)
    self.current_mode = None</code></pre>
                  </details>



  <div class="doc doc-children">





<h5 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.config" class="doc doc-heading">
            <code class="highlight language-python">config</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.current_mode" class="doc doc-heading">
            <code class="highlight language-python">current_mode = None</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.configure_transient_mode" class="doc doc-heading">
            <code class="highlight language-python">configure_transient_mode(mode, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the operating mode of the transient generator.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def configure_transient_mode(self, mode: Literal['CONTinuous', 'PULSe', 'TOGGle', 'LIST'], channel: int = 1) -&gt; None:
    """Sets the operating mode of the transient generator."""
    await self._send_command(f"TRANsient:MODE {mode.upper()}, (@{channel})")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.enable_battery_test" class="doc doc-heading">
            <code class="highlight language-python">enable_battery_test(state, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Enables or disables the battery test operation.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def enable_battery_test(self, state: bool, channel: int = 1) -&gt; None:
    """Enables or disables the battery test operation."""
    await self._send_command(f"BATTery:ENABle {'ON' if state else 'OFF'}, (@{channel})")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.enable_input" class="doc doc-heading">
            <code class="highlight language-python">enable_input(state, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Enables or disables the load's input.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>state</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>True to enable the input, False to disable.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="bool">bool</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel to control (default is 1).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>1</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def enable_input(self, state: bool, channel: int = 1) -&gt; None:
    """Enables or disables the load's input.

    Args:
        state: True to enable the input, False to disable.
        channel: The channel to control (default is 1).
    """
    await self._send_command(f"INPut:STATe {'ON' if state else 'OFF'}, (@{channel})")
    self._log(f"Input on channel {channel} turned {'ON' if state else 'OFF'}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.fetch_datalogger_data" class="doc doc-heading">
            <code class="highlight language-python">fetch_datalogger_data(num_points, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Fetches the specified number of logged data points.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def fetch_datalogger_data(self, num_points: int, channel: int = 1) -&gt; List[float]:
    """Fetches the specified number of logged data points."""
    response = await self._query(f"FETCh:SCALar:DLOG? {num_points}, (@{channel})")
    return [float(x) for x in response.split(',')]</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.fetch_scope_data" class="doc doc-heading">
            <code class="highlight language-python">fetch_scope_data(measurement, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Fetches the captured waveform (scope) data as a NumPy array.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def fetch_scope_data(self, measurement: Literal["current", "voltage", "power"], channel: int = 1) -&gt; np.ndarray:
    """Fetches the captured waveform (scope) data as a NumPy array."""
    scpi_map = {"current": "CURRent", "voltage": "VOLTage", "power": "POWer"}
    raw_data = await self._query_raw(f"FETCh:ARRay:{scpi_map[measurement]}? (@{channel})")
    # Assumes the backend handles binary block data parsing; if not, call self._read_to_np
    return np.frombuffer(raw_data, dtype=np.float32) # Assuming float data</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.from_config" class="doc doc-heading">
            <code class="highlight language-python">from_config(config, debug_mode=False, simulate=False)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Creates a DCActiveLoad instance from a configuration.</p>
<p>This factory method allows for the creation of a DCActiveLoad driver from
either a raw dictionary or a <code>DCActiveLoadConfig</code> object. It simplifies
the instantiation process by handling the configuration object creation
internally.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>config</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>A dictionary or a <code>DCActiveLoadConfig</code> object containing the
    instrument's settings.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Union">Union</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>], <a class="autorefs autorefs-internal" title="pytestlab.config.dc_active_load_config.DCActiveLoadConfig" href="../config/#pytestlab.config.dc_active_load_config.DCActiveLoadConfig">DCActiveLoadConfig</a>]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>debug_mode</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>If True, enables detailed logging for debugging purposes.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="bool">bool</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>False</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>simulate</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>If True, initializes the instrument in simulation mode.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="bool">bool</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>False</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><a class="autorefs autorefs-internal" title="DCActiveLoad(config, backend, **kwargs) (pytestlab.instruments.DCActiveLoad.DCActiveLoad)" href="#pytestlab.instruments.DCActiveLoad.DCActiveLoad">DCActiveLoad</a></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>An initialized DCActiveLoad object.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentConfigurationError(instrument=None, message='')" href="../errors/#pytestlab.errors.InstrumentConfigurationError">InstrumentConfigurationError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the provided config is not a dict or
                          a <code>DCActiveLoadConfig</code> instance.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">@classmethod
def from_config(
    cls: Type[DCActiveLoad],
    config: Union[Dict[str, Any], DCActiveLoadConfig],
    debug_mode: bool = False, simulate: bool = False
) -&gt; DCActiveLoad:
    """Creates a DCActiveLoad instance from a configuration.

    This factory method allows for the creation of a DCActiveLoad driver from
    either a raw dictionary or a `DCActiveLoadConfig` object. It simplifies
    the instantiation process by handling the configuration object creation
    internally.

    Args:
        config: A dictionary or a `DCActiveLoadConfig` object containing the
                instrument's settings.
        debug_mode: If True, enables detailed logging for debugging purposes.
        simulate: If True, initializes the instrument in simulation mode.

    Returns:
        An initialized DCActiveLoad object.

    Raises:
        InstrumentConfigurationError: If the provided config is not a dict or
                                      a `DCActiveLoadConfig` instance.
    """
    conf_obj: DCActiveLoadConfig
    if isinstance(config, dict):
        conf_obj = DCActiveLoadConfig(**config)
    elif isinstance(config, DCActiveLoadConfig):
        conf_obj = config
    else:
        raise InstrumentConfigurationError(
            "DCActiveLoad", "Configuration must be a dict or DCActiveLoadConfig instance."
        )
    return cls(config=conf_obj, debug_mode=debug_mode, simulate=simulate)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.get_battery_test_measurement" class="doc doc-heading">
            <code class="highlight language-python">get_battery_test_measurement(metric, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Queries a measurement from the ongoing battery test.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_battery_test_measurement(self, metric: Literal["capacity", "power", "time"], channel: int = 1) -&gt; float:
    """Queries a measurement from the ongoing battery test."""
    scpi_map = {"capacity": "CAPacity", "power": "POWer", "time": "TIMe"}
    response = await self._query(f"BATTery:MEASure:{scpi_map[metric]}? (@{channel})")
    return float(response)</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.is_input_enabled" class="doc doc-heading">
            <code class="highlight language-python">is_input_enabled(channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Queries the state of the load's input.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="bool">bool</span></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>True if the input is enabled, False otherwise.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def is_input_enabled(self, channel: int = 1) -&gt; bool:
    """Queries the state of the load's input.

    Returns:
        True if the input is enabled, False otherwise.
    """
    response = await self._query(f"INPut:STATe? (@{channel})")
    return response.strip() == '1'</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.measure_current" class="doc doc-heading">
            <code class="highlight language-python">measure_current()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Measures the sinking current, including uncertainty if available.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def measure_current(self) -&gt; MeasurementResult:
    """Measures the sinking current, including uncertainty if available."""
    return await self._measure_with_uncertainty("current")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.measure_power" class="doc doc-heading">
            <code class="highlight language-python">measure_power()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Measures the power being dissipated, including uncertainty if available.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def measure_power(self) -&gt; MeasurementResult:
    """Measures the power being dissipated, including uncertainty if available."""
    return await self._measure_with_uncertainty("power")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.measure_voltage" class="doc doc-heading">
            <code class="highlight language-python">measure_voltage()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Measures the voltage across the load, including uncertainty if available.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def measure_voltage(self) -&gt; MeasurementResult:
    """Measures the voltage across the load, including uncertainty if available."""
    return await self._measure_with_uncertainty("voltage")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_battery_cutoff_capacity" class="doc doc-heading">
            <code class="highlight language-python">set_battery_cutoff_capacity(capacity, state=True, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configures the capacity (Ah) cutoff condition for the battery test.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_battery_cutoff_capacity(self, capacity: float, state: bool = True, channel: int = 1) -&gt; None:
    """Configures the capacity (Ah) cutoff condition for the battery test."""
    await self._send_command(f"BATTery:CUTOff:CAPacity:STATe {'ON' if state else 'OFF'}, (@{channel})")
    if state:
        await self._send_command(f"BATTery:CUTOff:CAPacity {capacity}, (@{channel})")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_battery_cutoff_timer" class="doc doc-heading">
            <code class="highlight language-python">set_battery_cutoff_timer(time_s, state=True, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configures the timer (seconds) cutoff condition for the battery test.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_battery_cutoff_timer(self, time_s: float, state: bool = True, channel: int = 1) -&gt; None:
    """Configures the timer (seconds) cutoff condition for the battery test."""
    await self._send_command(f"BATTery:CUTOff:TIMer:STATe {'ON' if state else 'OFF'}, (@{channel})")
    if state:
        await self._send_command(f"BATTery:CUTOff:TIMer {time_s}, (@{channel})")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_battery_cutoff_voltage" class="doc doc-heading">
            <code class="highlight language-python">set_battery_cutoff_voltage(voltage, state=True, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configures the voltage cutoff condition for the battery test.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_battery_cutoff_voltage(self, voltage: float, state: bool = True, channel: int = 1) -&gt; None:
    """Configures the voltage cutoff condition for the battery test."""
    await self._send_command(f"BATTery:CUTOff:VOLTage:STATe {'ON' if state else 'OFF'}, (@{channel})")
    if state:
        await self._send_command(f"BATTery:CUTOff:VOLTage {voltage}, (@{channel})")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_load" class="doc doc-heading">
            <code class="highlight language-python">set_load(value)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Programs the load's setpoint for the current operating mode.</p>
<p>This method sets the target value that the load will maintain. The unit
of the <code>value</code> argument depends on the currently active mode:
- "CC" mode: <code>value</code> is in Amperes (A).
- "CV" mode: <code>value</code> is in Volts (V).
- "CP" mode: <code>value</code> is in Watts (W).
- "CR" mode: <code>value</code> is in Ohms (Ω).</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>value</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The target value for the load.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="float">float</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the operating mode has not been set first
                      by calling <code>set_mode()</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_load(self, value: float) -&gt; None:
    """Programs the load's setpoint for the current operating mode.

    This method sets the target value that the load will maintain. The unit
    of the `value` argument depends on the currently active mode:
    - "CC" mode: `value` is in Amperes (A).
    - "CV" mode: `value` is in Volts (V).
    - "CP" mode: `value` is in Watts (W).
    - "CR" mode: `value` is in Ohms (Ω).

    Args:
        value: The target value for the load.

    Raises:
        InstrumentParameterError: If the operating mode has not been set first
                                  by calling `set_mode()`.
    """
    if self.current_mode is None:
        raise InstrumentParameterError("Load mode has not been set. Call set_mode() first.")

    command_map = {"CC": "CURRent", "CV": "VOLTage", "CP": "POWer", "CR": "RESistance"}
    scpi_param = command_map.get(self.current_mode)

    if scpi_param:
        await self._send_command(f"{scpi_param}:LEVel:IMMediate:AMPLitude {value}")
        self._log(f"Load value set to {value} in mode {self.current_mode}.")
    else:
        raise InstrumentParameterError(f"Internal error: Unknown current_mode '{self.current_mode}'.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_mode" class="doc doc-heading">
            <code class="highlight language-python">set_mode(mode)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the operating mode of the electronic load.</p>
<p>This method configures the load to operate in one of the supported modes.
The mode determines what physical quantity the load will attempt to keep
constant.</p>
<p>The supported modes are:
- "CC": Constant Current
- "CV": Constant Voltage
- "CP": Constant Power
- "CR": Constant Resistance</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>mode</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The desired operating mode. The input is case-insensitive.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="str">str</span></code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RAISES</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
              <span class="doc-raises-annotation">
                  <code><a class="autorefs autorefs-internal" title="pytestlab.errors.InstrumentParameterError(parameter=None, value=None, valid_range=None, message='')" href="../errors/#pytestlab.errors.InstrumentParameterError">InstrumentParameterError</a></code>
              </span>
            </td>
            <td class="doc-raises-details">
              <div class="doc-md-description">
                <p>If the specified mode is not supported.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_mode(self, mode: str) -&gt; None:
    """Sets the operating mode of the electronic load.

    This method configures the load to operate in one of the supported modes.
    The mode determines what physical quantity the load will attempt to keep
    constant.

    The supported modes are:
    - "CC": Constant Current
    - "CV": Constant Voltage
    - "CP": Constant Power
    - "CR": Constant Resistance

    Args:
        mode: The desired operating mode. The input is case-insensitive.

    Raises:
        InstrumentParameterError: If the specified mode is not supported.
    """
    mode_upper = mode.upper()
    mode_map: Dict[str, str] = {
        "CC": "CURR",
        "CV": "VOLTage",
        "CP": "POWer",
        "CR": "RESistance"
    }
    if mode_upper not in mode_map:
        raise InstrumentParameterError(
            parameter="mode", value=mode, valid_range=list(mode_map.keys()),
            message=f"Unsupported mode '{mode}'. Valid modes are: {', '.join(mode_map.keys())}."
        )
    await self._send_command(f"FUNC {mode_map[mode_upper]}")
    self.current_mode = mode_upper
    self._log(f"Operating mode set to {mode_upper}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_range" class="doc doc-heading">
            <code class="highlight language-python">set_range(value, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the operating range for the current mode.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>value</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The maximum expected value to set the range. Can also be "MIN" or "MAX".</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Union">Union</span>[<span title="float">float</span>, <span title="str">str</span>]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel to configure (default is 1).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>1</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_range(self, value: Union[float, str], channel: int = 1) -&gt; None:
    """Sets the operating range for the current mode.

    Args:
        value: The maximum expected value to set the range. Can also be "MIN" or "MAX".
        channel: The channel to configure (default is 1).
    """
    if self.current_mode is None:
        raise InstrumentParameterError("Mode must be set before setting range.")
    command_map = {"CC": "CURRent", "CV": "VOLTage", "CP": "POWer", "CR": "RESistance"}
    scpi_param = command_map.get(self.current_mode)
    await self._send_command(f"{scpi_param}:RANGe {value}, (@{channel})")
    self._log(f"Range for mode {self.current_mode} on channel {channel} set for value {value}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_slew_rate" class="doc doc-heading">
            <code class="highlight language-python">set_slew_rate(rate, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the slew rate for the current operating mode.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>rate</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The desired slew rate. Units depend on the mode (A/s, V/s, etc.).
  Can also be "MIN", "MAX", or "INF".</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Union">Union</span>[<span title="float">float</span>, <span title="str">str</span>]</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel to configure (default is 1).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>1</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_slew_rate(self, rate: Union[float, str], channel: int = 1) -&gt; None:
    """Sets the slew rate for the current operating mode.

    Args:
        rate: The desired slew rate. Units depend on the mode (A/s, V/s, etc.).
              Can also be "MIN", "MAX", or "INF".
        channel: The channel to configure (default is 1).
    """
    if self.current_mode is None:
        raise InstrumentParameterError("Mode must be set before setting slew rate.")

    command_map = {"CC": "CURRent", "CV": "VOLTage", "CP": "POWer", "CR": "RESistance"}
    scpi_param = command_map.get(self.current_mode)
    await self._send_command(f"{scpi_param}:SLEW {rate}, (@{channel})")
    self._log(f"Slew rate for mode {self.current_mode} on channel {channel} set to {rate}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.set_transient_level" class="doc doc-heading">
            <code class="highlight language-python">set_transient_level(value, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Sets the secondary (transient) level for the current operating mode.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def set_transient_level(self, value: float, channel: int = 1) -&gt; None:
    """Sets the secondary (transient) level for the current operating mode."""
    if self.current_mode is None:
        raise InstrumentParameterError("Mode must be set before setting transient level.")
    command_map = {"CC": "CURRent", "CV": "VOLTage", "CP": "POWer", "CR": "RESistance"}
    scpi_param = command_map.get(self.current_mode)
    await self._send_command(f"{scpi_param}:TLEVel {value}, (@{channel})")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.short_input" class="doc doc-heading">
            <code class="highlight language-python">short_input(state, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Enables or disables a short circuit on the input.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>state</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>True to enable the short, False to disable.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="bool">bool</span></code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The channel to control (default is 1).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>1</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def short_input(self, state: bool, channel: int = 1) -&gt; None:
    """Enables or disables a short circuit on the input.

    Args:
        state: True to enable the short, False to disable.
        channel: The channel to control (default is 1).
    """
    await self._send_command(f"INPut:SHORt:STATe {'ON' if state else 'OFF'}, (@{channel})")
    self._log(f"Input short on channel {channel} turned {'ON' if state else 'OFF'}.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.start_transient" class="doc doc-heading">
            <code class="highlight language-python">start_transient(continuous=False, channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Initiates the transient trigger system.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def start_transient(self, continuous: bool = False, channel: int = 1) -&gt; None:
    """Initiates the transient trigger system."""
    await self._send_command(f"INITiate:CONTinuous:TRANsient {'ON' if continuous else 'OFF'}, (@{channel})")
    if not continuous:
        await self._send_command(f"INITiate:TRANsient (@{channel})")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.DCActiveLoad.DCActiveLoad.stop_transient" class="doc doc-heading">
            <code class="highlight language-python">stop_transient(channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Aborts any pending or in-progress transient operations.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def stop_transient(self, channel: int = 1) -&gt; None:
    """Aborts any pending or in-progress transient operations."""
    await self._send_command(f"ABORt:TRANsient (@{channel})")</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>
<h3 id="pytestlab.instruments.DCActiveLoad-functions">Functions</h3>

<div class="doc doc-object doc-function">


<h4 id="pytestlab.instruments.DCActiveLoad.health_check" class="doc doc-heading">
            <code class="highlight language-python">health_check(self)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h4>


    <div class="doc doc-contents ">

        <p>Performs a health check on the DC Electronic Load.</p>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/DCActiveLoad.py</code></summary>
              <pre class="highlight"><code class="language-python">async def health_check(self) -&gt; HealthReport:
        """Performs a health check on the DC Electronic Load."""
        report = HealthReport()
        try:
            report.instrument_idn = await self.id()
            errors = await self.get_all_errors()
            if errors:
                report.status = HealthStatus.WARNING
                report.warnings.extend([f"Stored Error: {code} - {msg}" for code, msg in errors])
            else:
                report.status = HealthStatus.OK
        except Exception as e:
            report.status = HealthStatus.ERROR
            report.errors.append(f"Health check failed: {e}")
        return report</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h3 id="spectrum-analyzer">Spectrum Analyzer</h3>


<div class="doc doc-object doc-module">



<h2 id="pytestlab.instruments.SpectrumAnalyser" class="doc doc-heading">
            <code>pytestlab.instruments.SpectrumAnalyser</code>


</h2>

    <div class="doc doc-contents first">









  <div class="doc doc-children">






<h3 id="pytestlab.instruments.SpectrumAnalyser-classes">Classes</h3>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult" class="doc doc-heading">
              <code class="highlight language-python">PlaceholderMeasurementResult(x, y, x_label='Frequency (Hz)', y_label='Amplitude (dBm)')</code>

</h4>


    <div class="doc doc-contents ">








                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/SpectrumAnalyser.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, x: List[float], y: List[float], x_label: str = "Frequency (Hz)", y_label: str = "Amplitude (dBm)"):
    self.x = x
    self.y = y
    self.x_label = x_label
    self.y_label = y_label</code></pre>
                  </details>



  <div class="doc doc-children">





<h5 id="pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult.x" class="doc doc-heading">
            <code class="highlight language-python">x = x</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult.x_label" class="doc doc-heading">
            <code class="highlight language-python">x_label = x_label</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult.y" class="doc doc-heading">
            <code class="highlight language-python">y = y</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult.y_label" class="doc doc-heading">
            <code class="highlight language-python">y_label = y_label</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.SpectrumAnalyser.PlaceholderMeasurementResult-functions">Functions</h5>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.SpectrumAnalyser.SpectrumAnalyser" class="doc doc-heading">
              <code class="highlight language-python">SpectrumAnalyser(config, backend, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a>[<a class="autorefs autorefs-internal" title="pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig" href="../config/#pytestlab.config.spectrum_analyzer_config.SpectrumAnalyzerConfig">SpectrumAnalyzerConfig</a>]</code></p>








                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO
    """
    Initialize the Instrument class.

    Args:
        config (ConfigType): Configuration for the instrument.
        backend (AsyncInstrumentIO): The communication backend instance.
        **kwargs: Additional keyword arguments.
    """
    if not isinstance(config, InstrumentConfig): # Check against the bound base
        raise InstrumentConfigurationError(
            self.__class__.__name__,
            f"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.",
        )

    self.config = config
    self._backend = backend # This will be an AsyncInstrumentIO instance
    self._command_log = []

    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__
    self._logger = get_logger(logger_name)

    self._logger.info(f"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.")</code></pre>
                  </details>



  <div class="doc doc-children">







<h5 id="pytestlab.instruments.SpectrumAnalyser.SpectrumAnalyser-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.SpectrumAnalyser.SpectrumAnalyser.configure_measurement" class="doc doc-heading">
            <code class="highlight language-python">configure_measurement(center_freq=None, span=None, rbw=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/SpectrumAnalyser.py</code></summary>
              <pre class="highlight"><code class="language-python">async def configure_measurement(
    self, 
    center_freq: Optional[float] = None, 
    span: Optional[float] = None, 
    rbw: Optional[float] = None
) -&gt; None:
    if center_freq is not None:
        await self._send_command(f"FREQ:CENT {center_freq}") # Use SCPI_MAP later
        self.config.frequency_center = center_freq # Update config
    if span is not None:
        await self._send_command(f"FREQ:SPAN {span}")
        self.config.frequency_span = span # Update config
    if rbw is not None:
        await self._send_command(f"BAND {rbw}") # RBW command
        self.config.resolution_bandwidth = rbw # Update config</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.SpectrumAnalyser.SpectrumAnalyser.get_trace" class="doc doc-heading">
            <code class="highlight language-python">get_trace(channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/SpectrumAnalyser.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_trace(self, channel: int = 1) -&gt; PlaceholderMeasurementResult: # Use actual MeasurementResult later
    # Example: Query trace data, parse it (often CSV or binary)
    # raw_data_str = await self._query(f"TRAC:DATA? TRACE{channel}") # Use SCPI_MAP
    # For simulation, SimBackend needs to be taught to respond to this
    # For now, return dummy data
    # freqs = [1e9, 2e9, 3e9] # Dummy frequencies
    # amps = [-20, -30, -25]  # Dummy amplitudes
    # return PlaceholderMeasurementResult(x=freqs, y=amps)
    self._logger.warning("get_trace for SpectrumAnalyser is a placeholder and returns dummy data.")
    # Simulating a basic trace for now
    sim_freqs = [self.config.frequency_center or 1e9 - (self.config.frequency_span or 100e6)/2 + i * ((self.config.frequency_span or 100e6)/10) for i in range(11)]
    sim_amps = [-20.0 - i*2 for i in range(11)] # Dummy amplitudes
    return PlaceholderMeasurementResult(x=sim_freqs, y=sim_amps)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="vector-network-analyzer-vna">Vector Network Analyzer (VNA)</h3>


<div class="doc doc-object doc-module">



<h2 id="pytestlab.instruments.VectorNetworkAnalyser" class="doc doc-heading">
            <code>pytestlab.instruments.VectorNetworkAnalyser</code>


</h2>

    <div class="doc doc-contents first">









  <div class="doc doc-children">






<h3 id="pytestlab.instruments.VectorNetworkAnalyser-classes">Classes</h3>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.VectorNetworkAnalyser.SParameterData" class="doc doc-heading">
              <code class="highlight language-python">SParameterData(frequencies, s_params, param_names)</code>

</h4>


    <div class="doc doc-contents ">








                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/VectorNetworkAnalyser.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, frequencies: List[float], s_params: List[List[complex]], param_names: List[str]):
    self.frequencies = frequencies # List of frequencies
    self.s_params = s_params       # List of lists, each inner list contains complex S-param values for a given S-parameter type
    self.param_names = param_names # List of S-parameter names, e.g., ["S11", "S21"]</code></pre>
                  </details>



  <div class="doc doc-children">





<h5 id="pytestlab.instruments.VectorNetworkAnalyser.SParameterData-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.VectorNetworkAnalyser.SParameterData.frequencies" class="doc doc-heading">
            <code class="highlight language-python">frequencies = frequencies</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.VectorNetworkAnalyser.SParameterData.param_names" class="doc doc-heading">
            <code class="highlight language-python">param_names = param_names</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.VectorNetworkAnalyser.SParameterData.s_params" class="doc doc-heading">
            <code class="highlight language-python">s_params = s_params</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.VectorNetworkAnalyser.SParameterData-functions">Functions</h5>



  </div>

    </div>

</div>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser" class="doc doc-heading">
              <code class="highlight language-python">VectorNetworkAnalyser(config, backend, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a>[<a class="autorefs autorefs-internal" title="pytestlab.config.vna_config.VNAConfig" href="../config/#pytestlab.config.vna_config.VNAConfig">VNAConfig</a>]</code></p>








                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO
    """
    Initialize the Instrument class.

    Args:
        config (ConfigType): Configuration for the instrument.
        backend (AsyncInstrumentIO): The communication backend instance.
        **kwargs: Additional keyword arguments.
    """
    if not isinstance(config, InstrumentConfig): # Check against the bound base
        raise InstrumentConfigurationError(
            self.__class__.__name__,
            f"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.",
        )

    self.config = config
    self._backend = backend # This will be an AsyncInstrumentIO instance
    self._command_log = []

    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__
    self._logger = get_logger(logger_name)

    self._logger.info(f"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.")</code></pre>
                  </details>



  <div class="doc doc-children">





<h5 id="pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser-attributes">Attributes</h5>

<div class="doc doc-object doc-attribute">



<h6 id="pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser.model_config" class="doc doc-heading">
            <code class="highlight language-python">model_config = {'arbitrary_types_allowed': True}</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-class-attribute"><code>class-attribute</code></small>
      <small class="doc doc-label doc-label-instance-attribute"><code>instance-attribute</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

    </div>

</div>

<h5 id="pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser.configure_s_parameter_sweep" class="doc doc-heading">
            <code class="highlight language-python">configure_s_parameter_sweep(s_params=None, start_freq=None, stop_freq=None, num_points=None, if_bandwidth=None, power_level=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/VectorNetworkAnalyser.py</code></summary>
              <pre class="highlight"><code class="language-python">async def configure_s_parameter_sweep(
    self, 
    s_params: Optional[List[str]] = None, # e.g. ["S11", "S21"]
    start_freq: Optional[float] = None, 
    stop_freq: Optional[float] = None, 
    num_points: Optional[int] = None,
    if_bandwidth: Optional[float] = None,
    power_level: Optional[float] = None
) -&gt; None:
    if s_params is not None:
        # SCPI command to select S-parameters might be like: CALC:PAR:DEF "S11"
        # This is highly instrument specific. For now, just update config.
        self.config.s_parameters = s_params
        self._logger.info(f"VNA S-parameters set to: {s_params}")
    if start_freq is not None:
        await self._send_command(f"SENS:FREQ:STAR {start_freq}") # Example SCPI
        self.config.start_frequency = start_freq
    if stop_freq is not None:
        await self._send_command(f"SENS:FREQ:STOP {stop_freq}") # Example SCPI
        self.config.stop_frequency = stop_freq
    if num_points is not None:
        await self._send_command(f"SENS:SWE:POIN {num_points}") # Example SCPI
        self.config.num_points = num_points
    if if_bandwidth is not None:
        await self._send_command(f"SENS:BWID {if_bandwidth}") # Example SCPI for IF bandwidth
        self.config.if_bandwidth = if_bandwidth
    if power_level is not None:
        await self._send_command(f"SOUR:POW {power_level}") # Example SCPI for power
        self.config.power_level = power_level
    self._logger.info("VNA measurement configured (simulated).")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.VectorNetworkAnalyser.VectorNetworkAnalyser.get_s_parameter_data" class="doc doc-heading">
            <code class="highlight language-python">get_s_parameter_data()</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/VectorNetworkAnalyser.py</code></summary>
              <pre class="highlight"><code class="language-python">async def get_s_parameter_data(self) -&gt; SParameterData:
    # Example: Query S-parameter data. This is often complex, involving selecting
    # the S-parameter, then querying data (e.g., in Real, Imaginary or LogMag, Phase format).
    # raw_data_str = await self._query(f"CALC:DATA? SDAT") # Example SCPI for S-parameter data
    # For simulation, SimBackend needs to be taught to respond.
    self._logger.warning("get_s_parameter_data for VNA is a placeholder and returns dummy data.")

    num_points = self.config.num_points or 101
    start_f = self.config.start_frequency or 1e9
    stop_f = self.config.stop_frequency or 2e9

    frequencies = [start_f + i * (stop_f - start_f) / (num_points -1 if num_points &gt; 1 else 1) for i in range(num_points)]

    s_params_to_measure = self.config.s_parameters or ["S11"]
    sim_s_params_data: List[List[complex]] = []

    for _ in s_params_to_measure:
        # Dummy data: e.g., S11 a simple reflection, S21 a simple transmission
        param_data = []
        for i in range(num_points):
            # Create some varying complex numbers
            real_part = -0.1 * i / num_points 
            imag_part = -0.05 * (1 - i / num_points)
            param_data.append(complex(real_part, imag_part))
        sim_s_params_data.append(param_data)

    return SParameterData(frequencies=frequencies, s_params=sim_s_params_data, param_names=s_params_to_measure)</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="power-meter">Power Meter</h3>


<div class="doc doc-object doc-module">



<h2 id="pytestlab.instruments.PowerMeter" class="doc doc-heading">
            <code>pytestlab.instruments.PowerMeter</code>


</h2>

    <div class="doc doc-contents first">









  <div class="doc doc-children">






<h3 id="pytestlab.instruments.PowerMeter-classes">Classes</h3>

<div class="doc doc-object doc-class">



<h4 id="pytestlab.instruments.PowerMeter.PowerMeter" class="doc doc-heading">
              <code class="highlight language-python">PowerMeter(config, backend, **kwargs)</code>

</h4>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="pytestlab.instruments.Instrument(config, backend, **kwargs) (pytestlab.instruments.instrument.Instrument)" href="#pytestlab.instruments.Instrument">Instrument</a>[<a class="autorefs autorefs-internal" title="pytestlab.config.power_meter_config.PowerMeterConfig" href="../config/#pytestlab.config.power_meter_config.PowerMeterConfig">PowerMeterConfig</a>]</code></p>


        <p>Drives a Power Meter instrument for power measurements.</p>
<p>This class provides a high-level interface for controlling a power meter,
building upon the base <code>Instrument</code> class. It includes methods for
configuring the power sensor and reading power values.</p>







                  <details class="quote">
                    <summary>Source code in <code>pytestlab/instruments/instrument.py</code></summary>
                    <pre class="highlight"><code class="language-python">def __init__(self, config: ConfigType, backend: AsyncInstrumentIO, **kwargs: Any) -&gt; None: # Changed to AsyncInstrumentIO
    """
    Initialize the Instrument class.

    Args:
        config (ConfigType): Configuration for the instrument.
        backend (AsyncInstrumentIO): The communication backend instance.
        **kwargs: Additional keyword arguments.
    """
    if not isinstance(config, InstrumentConfig): # Check against the bound base
        raise InstrumentConfigurationError(
            self.__class__.__name__,
            f"A valid InstrumentConfig-compatible object must be provided, but got {type(config).__name__}.",
        )

    self.config = config
    self._backend = backend # This will be an AsyncInstrumentIO instance
    self._command_log = []

    logger_name = self.config.model if hasattr(self.config, 'model') else self.__class__.__name__
    self._logger = get_logger(logger_name)

    self._logger.info(f"Instrument '{logger_name}': Initializing with backend '{type(backend).__name__}'.")</code></pre>
                  </details>



  <div class="doc doc-children">







<h5 id="pytestlab.instruments.PowerMeter.PowerMeter-functions">Functions</h5>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerMeter.PowerMeter.configure_sensor" class="doc doc-heading">
            <code class="highlight language-python">configure_sensor(channel=1, freq=None, averaging_count=None, units=None)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Configures the settings for a specific power sensor channel.</p>
<p>This method allows setting the frequency compensation, averaging count,
and power units for the measurement.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The sensor channel number to configure (default is 1).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>1</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>freq</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The frequency compensation value in Hz.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>averaging_count</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The number of measurements to average.</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>units</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The desired power units (e.g., "dBm", "W").</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>None</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerMeter.py</code></summary>
              <pre class="highlight"><code class="language-python">async def configure_sensor(
    self,
    channel: int = 1,
    freq: Optional[float] = None,
    averaging_count: Optional[int] = None,
    units: Optional[str] = None
) -&gt; None:
    """Configures the settings for a specific power sensor channel.

    This method allows setting the frequency compensation, averaging count,
    and power units for the measurement.

    Args:
        channel: The sensor channel number to configure (default is 1).
        freq: The frequency compensation value in Hz.
        averaging_count: The number of measurements to average.
        units: The desired power units (e.g., "dBm", "W").
    """
    # The specific SCPI commands can vary between power meter models.
    # The following are common examples.

    # Set the frequency compensation for the sensor.
    if freq is not None:
        await self._send_command(f"SENS{channel}:FREQ {freq}")
        self.config.frequency_compensation_value = freq  # Update local config state

    # Set the number of readings to average.
    if averaging_count is not None:
        await self._send_command(f"SENS{channel}:AVER:COUN {averaging_count}")
        self.config.averaging_count = averaging_count  # Update local config state

    # Set the units for the power measurement.
    if units is not None:
        # Validate that the requested units are supported by the config model.
        if units in PowerMeterConfig.model_fields['power_units'].annotation.__args__:
            await self._send_command(f"UNIT:POW {units.upper()}")
            self.config.power_units = units  # type: ignore
        else:
            self._logger.warning(f"Invalid power units '{units}' specified. Using config default '{self.config.power_units}'.")

    self._logger.info(f"Power meter sensor channel {channel} configured.")</code></pre>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="pytestlab.instruments.PowerMeter.PowerMeter.read_power" class="doc doc-heading">
            <code class="highlight language-python">read_power(channel=1)</code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-async"><code>async</code></small>
  </span>

</h6>


    <div class="doc doc-contents ">

        <p>Reads the power from a specified sensor channel.</p>
<p>This method queries the instrument for a power reading. Note that this
is a placeholder implementation and currently returns simulated data.</p>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">PARAMETER</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>channel</code>
            </td>
            <td class="doc-param-details">
              <div class="doc-md-description">
                <p>The sensor channel number to read from (default is 1).</p>
              </div>
              <p>
                  <span class="doc-param-annotation">
                    <b>TYPE:</b>
                      <code><span title="int">int</span></code>
                  </span>
                  <span class="doc-param-default">
                    <b>DEFAULT:</b>
                      <code>1</code>
                  </span>
              </p>
            </td>
          </tr>
      </tbody>
    </table>


<table>
      <thead>
        <tr>
          <th><span class="doc-section-title">RETURNS</span></th>
          <th><span>DESCRIPTION</span></th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="float">float</span></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>The measured power as a float. The units depend on the current</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <span class="doc-returns-annotation">
                    <code><span title="float">float</span></code>
                </span>
            </td>
            <td class="doc-returns-details">
              <div class="doc-md-description">
                <p>instrument configuration.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>pytestlab/instruments/PowerMeter.py</code></summary>
              <pre class="highlight"><code class="language-python">async def read_power(self, channel: int = 1) -&gt; float:
    """Reads the power from a specified sensor channel.

    This method queries the instrument for a power reading. Note that this
    is a placeholder implementation and currently returns simulated data.

    Args:
        channel: The sensor channel number to read from (default is 1).

    Returns:
        The measured power as a float. The units depend on the current
        instrument configuration.
    """
    # In a real implementation, you would query the instrument.
    # Example: raw_power_str = await self._query(f"FETC{channel}?")
    # The SimBackend would need to be configured to provide realistic responses.
    self._logger.warning(f"read_power for PowerMeter channel {channel} is a placeholder and returns dummy data.")

    # Simulate a power reading based on the configured units.
    sim_power = -10.0  # Default dummy power in dBm
    if self.config.power_units == "W":
        sim_power = 0.0001  # 100uW
    elif self.config.power_units == "mW":
        sim_power = 0.1  # 0.1mW
    elif self.config.power_units == "uW":
        sim_power = 100.0  # 100uW

    # For more realistic simulations, a small random variation could be added.
    # import random
    # sim_power *= (1 + random.uniform(-0.01, 0.01))

    return sim_power</code></pre>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><hr />
<h2 id="facade-pattern">Facade Pattern</h2>
<p>All instrument drivers expose "facade" objects for common operations, enabling a fluent, chainable API. For example, you can configure and enable a channel with:</p>
<pre class="highlight"><code class="language-python">await scope.channel(1).setup(scale=0.5, offset=0).enable()</code></pre>
<p>See the <a href="../../tutorials/10_minute_tour.ipynb">10-Minute Tour</a> for practical examples.</p>
<hr />
<h2 id="simulation-support">Simulation Support</h2>
<p>All drivers support simulation via the <code>simulate=True</code> flag or by using a simulated backend. See the <a href="../../user_guide/simulation/">Simulation Guide</a> for details.</p>
<hr />
<h2 id="extending-drivers">Extending Drivers</h2>
<p>To add support for a new instrument, create a profile YAML file and use <code>AutoInstrument.from_config()</code> or subclass <code>Instrument</code>. See <a href="../../profiles/creating/">Creating Profiles</a> for guidance.</p>
                            
                        </div>

                        <!-- Page Navigation (Previous/Next) -->
                        
                        <div class="page-nav">
                            
                                <a href="../../user_guide/cli/" class="prev-link">
                                    <span class="nav-label">Previous</span>
                                    <span class="nav-title">Command-Line Interface</span>
                                </a>
                            

                            
                                <a href="../measurements/" class="next-link">
                                    <span class="nav-label">Next</span>
                                    <span class="nav-title">Measurements</span>
                                </a>
                            
                        </div>
                        
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="site-footer">
            <div class="container">
                <div class="footer-content">
                    <div class="footer-copyright">
                        <p>&copy; 2025 LABIIUM. All rights reserved.</p>
                        <p>PyTestLab is an open-source project.</p>
                    </div>

                    <div class="footer-links">
                        
                            <a href="https://github.com/pytestlab/pytestlab" target="_blank">GitHub</a>
                        
                        
                        <a href="../../changelog/">Changelog</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <!-- JavaScript -->
    <script src="../../js/theme.js"></script>

    <!-- Search and Enhanced functionality -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Search Modal ---
            const searchButton = document.getElementById('searchButton');
            const searchModal = document.getElementById('searchModal');
            const searchClose = document.getElementById('searchClose');
            const searchInput = document.getElementById('searchInput');
            let searchIndex = null;

            // Load search index with better path resolution
            const searchPath = window.location.pathname.includes('/site/')
                ? '../search/search_index.json'
                : 'search/search_index.json';

            fetch(searchPath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Search index not found');
                    }
                    return response.json();
                })
                .then(data => {
                    searchIndex = data;
                    console.log('Search index loaded successfully');
                })
                .catch((error) => {
                    console.log('Search index not found, trying alternative paths');
                    // Try alternative paths
                    const altPaths = ['../search/search_index.json', './search/search_index.json', '/search/search_index.json'];

                    altPaths.reduce((promise, path) => {
                        return promise.catch(() => {
                            return fetch(path).then(response => {
                                if (!response.ok) throw new Error('Not found');
                                return response.json();
                            }).then(data => {
                                searchIndex = data;
                                console.log('Search index loaded from:', path);
                            });
                        });
                    }, Promise.reject()).catch(() => {
                        console.log('Search functionality disabled - no search index found');
                    });
                });

            if (searchButton && searchModal && searchClose) {
                searchButton.addEventListener('click', function() {
                    searchModal.classList.add('active');
                    setTimeout(() => {
                        searchInput.focus();
                    }, 100);
                });

                searchClose.addEventListener('click', function() {
                    searchModal.classList.remove('active');
                });

                // Close on escape key
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape' && searchModal.classList.contains('active')) {
                        searchModal.classList.remove('active');
                    }
                });
            }

            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    const query = this.value.trim().toLowerCase();
                    const searchResultsMeta = document.getElementById('searchResultsMeta');
                    const searchResults = document.getElementById('searchResults');

                    if (query.length > 1) {
                        searchResultsMeta.textContent = 'Searching...';
                        searchResults.innerHTML = '';

                        if (searchIndex) {
                            const results = performSearch(query, searchIndex);
                            displaySearchResults(results, searchResultsMeta, searchResults);
                        } else {
                            searchResultsMeta.textContent = 'Loading search index...';
                            searchResults.innerHTML = '<div class="search-result-item"><p style="color: var(--lab-aqua); padding: 1rem;">Search index is loading. If this persists, make sure the site has been built with <code>mkdocs build</code>.</p></div>';
                        }
                    } else {
                        searchResultsMeta.textContent = 'Type to start searching';
                        searchResults.innerHTML = '';
                    }
                });
            }

            function performSearch(query, index) {
                const results = [];
                // Handle different search index formats
                const docs = index.docs || index.articles || [];

                docs.forEach((doc, i) => {
                    const title = (doc.title || '').toLowerCase();
                    const text = (doc.text || doc.content || '').toLowerCase();
                    const location = doc.location || doc.url || '#';

                    if (title.includes(query) || text.includes(query)) {
                        const titleIndex = title.indexOf(query);
                        const textIndex = text.indexOf(query);
                        const score = (titleIndex >= 0 ? 10 : 0) + (textIndex >= 0 ? 1 : 0);

                        results.push({
                            title: doc.title || 'Untitled',
                            location: location,
                            text: text || 'No description available',
                            score: score
                        });
                    }
                });

                return results.sort((a, b) => b.score - a.score).slice(0, 10);
            }

            function displaySearchResults(results, metaElement, resultsElement) {
                if (results.length > 0) {
                    metaElement.textContent = `${results.length} result${results.length > 1 ? 's' : ''} found`;

                    resultsElement.innerHTML = results.map(result => `
                        <div class="search-result-item">
                            <a href="${result.location}" class="search-result-link">
                                <div class="search-result-title">${result.title}</div>
                                <div class="search-result-text">${result.text.substring(0, 150)}...</div>
                            </a>
                        </div>
                    `).join('');
                } else {
                    metaElement.textContent = 'No results found';
                    resultsElement.innerHTML = '';
                }
            }

            // --- Enhanced Code Block Copy functionality ---
            const codeBlocks = document.querySelectorAll('pre');
            codeBlocks.forEach(block => {
                // Add copy button
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path></svg>Copy';
                copyButton.setAttribute('aria-label', 'Copy code to clipboard');

                copyButton.addEventListener('click', () => {
                    const code = block.querySelector('code')?.textContent || block.textContent;

                    navigator.clipboard.writeText(code).then(() => {
                        copyButton.classList.add('copied');
                        copyButton.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 6L9 17l-5-5"></path></svg>Copied!';

                        setTimeout(() => {
                            copyButton.classList.remove('copied');
                            copyButton.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path></svg>Copy';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                    });
                });

                block.appendChild(copyButton);

                // Add language indicator
                const language = block.querySelector('code')?.className.match(/language-(\w+)/)?.[1];
                if (language) {
                    const langBadge = document.createElement('div');
                    langBadge.className = 'lang-badge';

                    // Format language name to be more readable
                    const langMap = {
                        'py': 'Python',
                        'js': 'JavaScript',
                        'ts': 'TypeScript',
                        'html': 'HTML',
                        'css': 'CSS',
                        'yaml': 'YAML',
                        'json': 'JSON',
                        'bash': 'Shell',
                        'sh': 'Shell',
                        'sql': 'SQL',
                        'cpp': 'C++'
                    };

                    const displayLang = langMap[language] || language.charAt(0).toUpperCase() + language.slice(1);
                    langBadge.textContent = displayLang;
                    block.appendChild(langBadge);
                }
            });
        });
    </script>

    

    <!-- Extra scripts from plugins -->
    

    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>