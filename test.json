{
    "errors.py": "class SCPIConnectionError(Exception):\n    \"\"\"For SCPI instrument connection errors.\"\"\"\n\n    def __init__(self, message=\"Failed to connect to the instrument.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass SCPICommunicationError(Exception):\n    \"\"\"For SCPI communication errors.\"\"\"\n\n    def __init__(self, message=\"Error in SCPI communication.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass SCPIValueError(ValueError):\n    \"\"\"For invalid SCPI values or settings.\"\"\"\n\n    def __init__(self, message=\"Invalid value for SCPI command.\"):\n        self.message = message\n        super().__init__(self.message)\n\nclass InstrumentNotFoundError(Exception):\n    \"\"\"For instrument not found errors.\"\"\"\n\n    def __init__(self, name):\n        super().__init__(f\"Instrument {name} not found in the manager's collection.\")\n\n\nclass IntrumentConfigurationError(Exception):\n    \"\"\"For instrument configuration errors.\"\"\"\n\n    def __init__(self, message=\"Invalid Instrument configuration.\"):\n        self.message = message\n        super().__init__(self.message)",
    "MeasurementDatabase.py": "import sqlite3\nimport time\nimport numpy as np\nfrom dataclasses import dataclass\n\n@dataclass\nclass Preamble:\n    \"\"\"A class to store the preamble data from the oscilloscope channel.\n\n    :param format: The format of the data\n    :param type: The type of the data\n    :param points: The number of points\n    :param xinc: The x increment\n    :param xorg: The x origin\n    :param xref: The x reference\n    :param yinc: The y increment\n    :param yorg: The y origin\n    :param yref: The y reference\n    \"\"\"\n\n    format: str\n    type: str\n    points: int\n    xinc: float\n    xorg: float\n    xref: float\n    yinc: float\n    yorg: float\n    yref: float\n\nclass MeasurementValue:\n    \"\"\"A class to represent a single measurement value and its timestamp.\n    \n    Attributes:\n        value (float): The measurement value.\n        timestamp (float): The timestamp when the measurement was taken.\n    \"\"\"\n    def __init__(self, value):\n        self.value = float(value)\n        self.timestamp = time.time()\n\n    def __str__(self):\n        return f\"{self.value}\"\n\nclass MeasurementResult:\n    \"\"\"A class to represent a collection of measurement values.\n    \n    Attributes:\n        values (list): A list of MeasurementValue objects.\n        unit (str): The unit of the measurements.\n        instrument (str): The name of the instrument used for the measurements.\n        measurement_type (str): The type of measurement.\n    \"\"\"\n    def __init__(self, instrument, units, measurement_type):\n        self.values = np.array([])\n        self.unit = units\n        self.instrument = instrument\n        self.timestamp = time.time()\n        self.measurement_type = measurement_type\n\n    def add(self, value):\n        \"\"\"Adds a new MeasurementValue to the collection.\"\"\"\n        ## append to numpy array\n        self.values = np.append(self.values, value)\n\n    def set_values(self, values):\n        \"\"\"Sets the MeasurementValues in the collection.\"\"\"\n        self.values = values\n\n    def get(self, index):\n        \"\"\"Gets the MeasurementValue at a specified index.\"\"\"\n        return self.values[index]\n\n    def get_all(self):\n        \"\"\"Returns all the MeasurementValues in the collection.\"\"\"\n        return self.values\n\n    def clear(self):\n        \"\"\"Clears all the MeasurementValues from the collection.\"\"\"\n        self.values.clear()\n\n    def __len__(self):\n        return len(self.values)\n\n    def __getitem__(self, index):\n        return self.values[index]\n\n    def __iter__(self):\n        return iter(self.values)\n\n    def __delitem__(self, index):\n        del self.values[index]\n\n    def __str__(self):\n        string = \"\"\n        for value in self.values:\n            string += f\"{value} {self.unit}\\n\"\n\n        # remove last newline\n        string = string[:-1]\n        return string\n\nclass MeasurementDatabase:\n    \"\"\"\n    A class for managing a SQLite database that stores measurement results.\n\n    Provides methods for storing and retrieving measurement data associated with instrument names.\n\n    Attributes:\n        db_path (str): The path to the SQLite database file.\n    \"\"\"\n\n    def __init__(self, db_path):\n        \"\"\"\n        Initializes the MeasurementDatabase instance.\n\n        Args:\n            db_path (str): The path to the SQLite database file.\n        \"\"\"\n        self.db_path = db_path\n        self._create_tables()\n\n    def _create_tables(self):\n        \"\"\"\n        Creates the 'measurements' table in the database if it does not already exist.\n        \"\"\"\n        with self._get_connection() as conn:\n            conn.execute('''\n                CREATE TABLE IF NOT EXISTS measurements (\n                    measurement_id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    timestamp TIMESTAMP NOT NULL,\n                    instrument_name TEXT NOT NULL,\n                    measurement_data TEXT NOT NULL\n                )\n            ''')\n\n    def _get_connection(self):\n        \"\"\"\n        Opens a new connection to the SQLite database.\n\n        Returns:\n            sqlite3.Connection: A SQLite database connection.\n        \"\"\"\n        return sqlite3.connect(self.db_path)\n\n    def store_measurement_result(self, instrument_name, measurement_data):\n        \"\"\"\n        Stores a measurement result in the database.\n\n        Args:\n            instrument_name (str): The name of the instrument.\n            measurement_data (str): The serialized measurement data.\n        \"\"\"\n        with self._get_connection() as conn:\n            conn.execute('''\n                INSERT INTO measurements (timestamp, instrument_name, measurement_data)\n                VALUES (DATETIME('now'), ?, ?)\n            ''', (instrument_name, measurement_data))\n\n    def store_measurement_result(self, measurement_data: MeasurementResult) -> None:\n        \"\"\"\n        Stores a MeasurementResult instance in the database.\n\n        Args:\n            measurement_data (MeasurementResult): A MeasurementResult object containing the measurement data and instrument name.\n\n        Note: \n            This method is an overload of the previous method, it expects a MeasurementResult instance.\n        \"\"\"\n        with self._get_connection() as conn:\n            conn.execute('''\n                INSERT INTO measurements (timestamp, instrument_name, measurement_data)\n                VALUES (DATETIME('now'), ?, ?)\n            ''', (measurement_data.instrument, str(measurement_data)))\n            \n    def retrieve_measurement_results(self, instrument_name):\n        \"\"\"\n        Retrieves all measurement results associated with a given instrument name.\n\n        Args:\n            instrument_name (str): The name of the instrument.\n\n        Returns:\n            list: A list of tuples where each tuple contains the timestamp and measurement data.\n        \"\"\"\n        with self._get_connection() as conn:\n            cursor = conn.execute('''\n                SELECT timestamp, measurement_data\n                FROM measurements\n                WHERE instrument_name = ?\n            ''', (instrument_name,))\n            return cursor.fetchall()\n",
    "utilities.py": "import time\nfrom pytestlab.errors import InstrumentNotFoundError, SCPIConnectionError, SCPICommunicationError, SCPIValueError\n\ndef delay(seconds):\n    \"\"\"Pauses the program for the given number of seconds.\n    \n    Args:\n        seconds (float): Time to pause in seconds.\n    \"\"\"\n    time.sleep(seconds)\n\ndef validate_visa_resource(visa_resource):\n    \"\"\"Validates the VISA resource string format.\n    \n    Args:\n        visa_resource (str): The VISA resource string.\n        \n    Raises:\n        ValueError: If the VISA resource string is in an invalid format.\n    \"\"\"\n    if not visa_resource.startswith(\"TCPIP0::\"):\n        raise ValueError(\"Invalid VISA resource format. Please use TCPIP0::<IP_ADDRESS>::INSTR format for LAN instruments.\")\n\ndef check_connection(instrument):\n    \"\"\"Checks if the instrument connection is active.\n    \n    Args:\n        instrument (object): The instrument object to check the connection for.\n        \n    Raises:\n        SCPIConnectionError: If unable to connect to the instrument.\n    \"\"\"\n    try:\n        response = instrument._query(\"*IDN?\")\n        if response:\n            print(\"Connection to the instrument is active.\")\n    except Exception as e:\n        raise SCPIConnectionError()\n\nclass InstrumentCollection:\n    \"\"\"A class to manage a collection of instruments.\n    \n    Attributes:\n        instruments (dict): A dictionary to store instrument objects by their names.\n    \"\"\"\n    def __init__(self):\n        self.instruments = {}\n\n    def add(self, name, instrument):\n        \"\"\"Adds an instrument to the collection.\"\"\"\n        self.instruments[name] = instrument\n\n    def get(self, name):\n        \"\"\"Gets an instrument by its name.\"\"\"\n        if name in self.instruments:\n            return self.instruments[name]\n        else:\n            raise InstrumentNotFoundError(name)\n\n    # ... (continue with the remaining methods in the same manner)\n",
    "__init__.py": "",
    "instruments\\AutoInstrument.py": "from pytestlab.instruments.Oscilloscope import Oscilloscope, DigitalOscilloscopeWithJitter\nfrom pytestlab.instruments.DigitalMultimeter import DigitalMultimeter\nfrom pytestlab.instruments.WaveformGenerator import WaveformGenerator\nfrom pytestlab.instruments.DigitalPowerSupply import DigitalPowerSupply\nfrom pytestlab.errors import InstrumentConfigurationError\n\ndef AutoInstrument(profile):\n    \"\"\"\n    Automatically instantiate and return an instrument object based on a given profile.\n\n    Args:\n        profile (dict): A dictionary profile containing information about the instrument to be created. \n                            The dictionary should contain a \"device_type\" key with a string value \n                            specifying the type of the device (\"oscilloscope\", \"digital_multimeter\", \n                            \"waveform_generator\", \"digital_power_supply\"). \n                            Additional will be required depending on the device type.\n                            \n    Returns:\n        Object: An instance of the corresponding instrument class, initialized based on the profile.\n\n    Raises:\n        InstrumentConfigurationError: If the device type is not recognized or missing in the profile.\n    \"\"\"\n    match profile[\"device_type\"]:\n        case \"oscilloscope\":\n            if profile[\"jitter_analysis\"]:\n                return DigitalOscilloscopeWithJitter(profile[\"visa_resource\"], profile)\n            else:\n                return Oscilloscope(profile[\"visa_resource\"], profile)\n        case \"digital_multimeter\":\n            return DigitalMultimeter(profile[\"visa_resource\"], profile)\n        case \"waveform_generator\":\n            return WaveformGenerator(profile[\"visa_resource\"], profile)\n        case \"digital_power_supply\":\n            return DigitalPowerSupply(profile[\"visa_resource\"], profile)\n        case _:\n            raise InstrumentConfigurationError()\n",
    "instruments\\DigitalMultimeter.py": "from pytestlab.instruments.instrument import SCPIInstrument, SCPIConnectionError, SCPICommunicationError\n\nclass DigitalMultimeter(SCPIInstrument):\n    \"\"\"\n    A class representing a Digital Multimeter that inherits from the SCPIInstrument class.\n\n    Provides methods for measuring voltage, current, resistance, frequency, and testing continuity.\n\n    Attributes:\n        visa_resource (str): The VISA address of the device.\n        description (dict): A dictionary containing additional information about the device, including supported channels.\n    \"\"\"\n\n    def __init__(self, visa_resource, description):\n        \"\"\"\n        Initializes a DigitalMultimeter instance.\n\n        Args:\n            visa_resource (str): The VISA address of the device.\n            description (dict): A dictionary containing additional information about the device.\n        \"\"\"\n        super().__init__(visa_resource)\n        self.description = description\n\n    def measure_voltage(self, channel=1):\n        \"\"\"\n        Measures the DC voltage on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            float: The measured voltage.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"voltage_channels\"]:\n            raise ValueError(f\"Invalid voltage channel {channel}. Supported voltage channels: {self.description['voltage_channels']}\")\n        voltage = self._query(f\"MEASURE:VOLTAGE:DC? (@{channel})\")\n        return float(voltage)\n\n    def measure_current(self, channel=1):\n        \"\"\"\n        Measures the DC current on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            float: The measured current.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"current_channels\"]:\n            raise ValueError(f\"Invalid current channel {channel}. Supported current channels: {self.description['current_channels']}\")\n        current = self._query(f\"MEASURE:CURRENT:DC? (@{channel})\")\n        return float(current)\n\n    def measure_resistance(self, channel=1):\n        \"\"\"\n        Measures the resistance on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            float: The measured resistance.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"resistance_channels\"]:\n            raise ValueError(f\"Invalid resistance channel {channel}. Supported resistance channels: {self.description['resistance_channels']}\")\n        resistance = self._query(f\"MEASURE:RESISTANCE? (@{channel})\")\n        return float(resistance)\n\n    def measure_frequency(self, channel=1):\n        \"\"\"\n        Measures the frequency on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            float: The measured frequency.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"frequency_channels\"]:\n            raise ValueError(f\"Invalid frequency channel {channel}. Supported frequency channels: {self.description['frequency_channels']}\")\n        frequency = self._query(f\"MEASURE:FREQUENCY? (@{channel})\")\n        return float(frequency)\n\n    def test_continuity(self, channel=1):\n        \"\"\"\n        Tests for electrical continuity on the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Returns:\n            bool: True if continuity is present, False otherwise.\n\n        Raises:\n            ValueError: If an invalid channel is specified.\n        \"\"\"\n        if channel not in self.description[\"continuity_channels\"]:\n            raise ValueError(f\"Invalid continuity channel {channel}. Supported continuity channels: {self.description['continuity_channels']}\")\n        continuity = self._query(f\"TEST:CONTINUITY? (@{channel})\")\n        return bool(int(continuity))  # Assuming continuity returns 1 for True and 0 for False\n",
    "instruments\\DigitalPowerSupply.py": "from pytestlab.instruments.instrument import SCPIInstrument\nfrom pytestlab.errors import SCPICommunicationError\n\nclass DigitalPowerSupply(SCPIInstrument):\n    \"\"\"\n    A class representing a Digital Power Supply that inherits from the SCPIInstrument class.\n\n    Provides methods for setting voltage and current, and for enabling or disabling the output.\n\n    Attributes:\n        visa_resource (str): The VISA address of the device.\n        description (dict): A dictionary containing additional information about the device.\n    \"\"\"\n\n    def __init__(self, visa_resource, description):\n        \"\"\"\n        Initializes a DigitalPowerSupply instance.\n\n        Args:\n            visa_resource (str): The VISA address of the device.\n            description (dict): A dictionary containing additional information about the device.\n        \"\"\"\n        super().__init__(visa_resource)\n        self.description = description\n\n    def set_voltage(self, voltage, channel=1):\n        \"\"\"\n        Sets the voltage for the specified channel.\n\n        Args:\n            voltage (float): The voltage value to set.\n            channel (int, optional): The channel number. Default is 1.\n\n        Raises:\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\n        \"\"\"\n        self._check_channel_range(channel, voltage, \"voltage\")\n        self._send_command(f\"VOLTAGE{channel} {voltage}\")\n\n    def set_current(self, current, channel=1):\n        \"\"\"\n        Sets the current for the specified channel.\n\n        Args:\n            current (float): The current value to set.\n            channel (int, optional): The channel number. Default is 1.\n\n        Raises:\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\n        \"\"\"\n        self._check_channel_range(channel, current, \"current\")\n        self._send_command(f\"CURRENT{channel} {current}\")\n\n    def enable_output(self, channel=1):\n        \"\"\"\n        Enables the output for the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Raises:\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\n        \"\"\"\n        self._send_command(f\"OUTPUT{channel} ON\")\n\n    def disable_output(self, channel=1):\n        \"\"\"\n        Disables the output for the specified channel.\n\n        Args:\n            channel (int, optional): The channel number. Default is 1.\n\n        Raises:\n            SCPICommunicationError: If there's a failure in sending the SCPI command.\n        \"\"\"\n        self._send_command(f\"OUTPUT{channel} OFF\")\n",
    "instruments\\instrument.py": "import numpy as np\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError\nfrom pyscpi import usbtmc\nimport time\n\nclass SCPIInstrument:\n    \"\"\"\n    A class representing an SCPI-compliant instrument.\n\n    Attributes:\n        visa_resource (str): The VISA resource string that identifies the instrument.\n    \"\"\"\n\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\n        \"\"\"\n        Initialize the SCPIInstrument class.\n\n        Args:\n            visa_resource (str): The VISA resource string to use for the connection.\n        \"\"\"\n        if visa_resource:\n            self.visa_resource = visa_resource\n            self._connect()\n        elif \"vendor_id\" in profile and \"product_id\" in profile:\n            self.instrument = usbtmc.Instrument(profile[\"vendor_id\"], profile[\"product_id\"])\n        else:\n            raise ValueError(\"Either a VISA resource string or a vendor and product ID must be provided.\")\n        self.profile = profile\n        self._command_log = []\n        self.debug_mode = debug_mode\n\n    def _connect(self):\n        \"\"\"Connect to the instrument using the VISA resource string.\"\"\"\n        try:\n            import pyvisa\n            self.instrument = pyvisa.ResourceManager().open_resource(self.visa_resource)\n        except Exception as e:\n            raise SCPIConnectionError(f\"Failed to connect to the instrument: {str(e)}\")\n\n    def _read_to_np(self) -> bytes:\n        chunk_size = 1024\n        data = self.instrument.read_raw(chunk_size)\n        np.frombuffer(data[10:], dtype=np.uint8)\n        header = data[2:10].decode('utf-8')\n        data = np.frombuffer(data[10:], dtype=np.uint8)\n        self._log(header)\n\n        hpoints = int(header)\n\n        while len(data) < hpoints:\n            data = np.append(data, np.frombuffer(\n                self.instrument.read_raw(chunk_size), dtype=np.uint8))\n\n        return data[:-1]\n\n    def _send_command(self, command):\n        \"\"\"\n        Send an SCPI command to the instrument.\n\n        Args:\n            command (str): The SCPI command to send.\n\n        Raises:\n            SCPICommunicationError: If sending the command fails.\n        \"\"\"\n        try:\n            self.instrument.write(command)\n            self._command_log.append({\"command\": command, \"success\": True, \"type\": \"write\", \"timestamp\":time.time})\n        except Exception as e:\n            raise SCPICommunicationError(f\"Failed to send command: {str(e)}\")\n\n    def _query(self, query):\n        \"\"\"\n        Query the instrument and return the response.\n\n        Args:\n            query (str): The SCPI query to send.\n\n        Returns:\n            str: The instrument's response to the query.\n\n        Raises:\n            SCPICommunicationError: If the query fails.\n        \"\"\"\n        try:\n            response =  self.instrument.query(query)\n            self._command_log.append({\"command\": query, \"success\": True, \"type\": \"query\", \"timestamp\":time.time})\n            self.instrument.query(\"*OPC?\")\n            return response\n        except Exception as e:\n            self._command_log.append({\"command\": query, \"success\": False, \"type\": \"query\", \"timestamp\":time.time})\n            raise SCPICommunicationError(f\"Failed to query instrument: {str(e)}\")\n    def _log(self, message):\n        \"\"\"\n        Log a message.\n\n        Args:\n            message (str): The message to log.\n        \"\"\"\n        if self.debug_mode:\n            print(message)\n\n    def _history(self):\n        \"\"\"\n        Prints history of executed commands\n        \"\"\"\n        for command in self._command_log:\n            print(command)\n    def id(self):\n        \"\"\"\n        Query the instrument for its identification.\n\n        Returns:\n            str: The identification string of the instrument.\n        \"\"\"\n        return self._query(\"*IDN?\")\n    \n    def _check_valid_channel(self, selected_channel):\n        valid_channels = self.profile[\"channels\"].keys()\n        min_limit = min(valid_channels)\n        max_limit = max(valid_channels)\n        if selected_channel < min_limit or selected_channel > max_limit:\n            raise ValueError(f\"Invalid Channel Selected: {selected_channel}. Available Channels: {min_limit} to {max_limit}\")\n\n    \n    def close(self):\n        \"\"\"Close the connection to the instrument.\"\"\"\n        self.instrument.close()\n\n    def reset(self):\n        \"\"\"Reset the instrument to its default settings.\"\"\"\n        self._send_command(\"*RST\")\n\n    def set_channel_voltage(self, channel, voltage):\n        \"\"\"\n        Set the voltage for a specific channel.\n\n        Args:\n            channel (int or str): The channel for which to set the voltage.\n            voltage (float): The voltage value to set.\n        \"\"\"\n        self._send_command(f\"CHAN{channel}:VOLT {voltage}\")\n\n    def get_channel_voltage(self, channel):\n        \"\"\"\n        Get the voltage for a specific channel.\n\n        Args:\n            channel (int or str): The channel for which to get the voltage.\n\n        Returns:\n            float: The voltage value for the channel.\n        \"\"\"\n        response = self._query(f\"CHAN{channel}:VOLT?\")\n        return float(response)\n\n    def measure_frequency(self, channel):\n        \"\"\"\n        Measure the frequency for a specific channel.\n\n        Args:\n            channel (int or str): The channel for which to measure the frequency.\n\n        Returns:\n            float: The measured frequency value for the channel.\n        \"\"\"\n        response = self._query(f\"MEAS:FREQ? CHAN{channel}\")\n        return float(response)\n",
    "instruments\\InstrumentManager.py": "import time\nfrom pytestlab import InstrumentCollection\n\nclass InstrumentManager:\n    def __init__(self):\n        self.instrument_collection = InstrumentCollection()\n\n    # Instrument management methods\n    def add_instrument(self, name, instrument):\n        # Add an instrument to the manager's collection\n        self.instrument[name] = instrument\n\n    def remove_instrument(self, name):\n        # Remove an instrument from the manager's collection\n        del self.instruments[name]\n\n    def get_instrument(self, name):\n        # Get an instrument from the manager's collection\n        return self.instruments[name]\n\n    def list_instruments(self):\n        # List all instruments currently added to the manager\n        print(self.instrument_collection)\n\n    def disconnect_all_instruments(self):\n        # Disconnect all instruments in the manager's collection\n        for i in self.instruments:\n            self.instruments[i].close()\n        pass\n\n    def is_all_instruments_connected(self):\n        # Check if all instruments are connected\n        pass\n\n    def is_instrument_connected(self, name):\n        # Check if a specific instrument is connected\n        pass\n    # Measurement methods\n    def measure_voltage(self, voltage, channel=1):\n        # Perform a voltage measurement\n        pass\n\n    def measure_current(self, current, channel=1):\n        # Perform a current measurement\n        pass\n\n    def measure_power(self, power, channel=1):\n        # Perform a power measurement\n        pass\n\n    def measure_eye_diagram(self, test_pattern, voltage=1.0, current=0.5, channel=1, eye_duration=0.1):\n        power_supply = self.instrument_collection[\"power_supply\"]\n        oscilloscope = self.instrument_collection[\"oscilloscope\"]\n        pattern_generator = self.instrument_collection[\"pattern_generator\"]\n\n        power_supply.set_voltage(voltage, channel)\n        power_supply.set_current(current, channel)\n        power_supply.enable_output(channel)\n\n        pattern_generator.load_pattern(test_pattern)\n        pattern_generator.enable_output()\n\n        oscilloscope.set_channel(channel)\n        oscilloscope.start_measurement()\n\n        # Wait for the test pattern to stabilize and the oscilloscope to capture data\n        time.sleep(eye_duration)\n\n        oscilloscope.stop_measurement()\n        data = oscilloscope.get_measurement_data()\n\n        power_supply.disable_output()\n        pattern_generator.disable_output()\n\n        #Data needs to be processed to generate Eye Diagram by frontend\n        # eye_diagram = process_eye_data(data)\n        return data\n        # return eye_diagram\n\n    def perform_s21_measurement(self, frequency, power_level, channel=1, measurement_time=0.1):\n        signal_generator = self.instrument_collection[\"signal_generator\"]\n        vna = self.instrument_collection[\"vna\"]\n\n        signal_generator.set_frequency(frequency)\n        signal_generator.set_power_level(power_level)\n        signal_generator.enable_output()\n\n        vna.set_channel(channel)\n        vna.set_frequency(frequency)\n        vna.set_power_level(power_level)\n        vna.set_s_parameter(\"S21\")\n        vna.start_measurement()\n\n        # Wait for the measurement to stabilize and complete\n        time.sleep(measurement_time)\n\n        s21_result = vna.get_measurement_data(\"S21\")\n\n        signal_generator.disable_output()\n        vna.stop_measurement()\n\n        return s21_result\n\n        \n    # Calibration methods\n    def calibrate_power_supply(self):\n        # Calibrate the power supply\n        pass\n\n    def calibrate_oscilloscope(self):\n        # Calibrate the oscilloscope\n        pass\n\n    def calibrate_vna(self):\n        # Calibrate the Vector Network Analyzer\n        pass\n\n    # Data handling methods\n    def save_measurement_data(self, data, file_name):\n        # Save measurement data to a file\n        pass\n\n    def load_measurement_data(self, file_name):\n        # Load measurement data from a file\n        pass\n\n    # Instrument configuration methods\n    def configure_power_supply(self, settings):\n        # Configure power supply settings (e.g., voltage limits, current limits)\n        pass\n\n    def configure_oscilloscope(self, settings):\n        # Configure oscilloscope settings (e.g., timebase, trigger settings)\n        pass\n\n    def configure_vna(self, settings):\n        # Configure Vector Network Analyzer settings (e.g., frequency range, calibration)\n        pass\n\n    # Additional utility methods as needed\n    def check_instrument_compatibility(self):\n        # Check if the connected instruments are compatible for the planned measurements\n        pass\n\n    def perform_full_system_check(self):\n        # Perform a comprehensive system check before starting measurements\n        pass\n\n    def report_system_status(self):\n        # Generate a report on the status of connected instruments and overall system health\n        pass\n",
    "instruments\\Oscilloscope.py": "import time\nfrom pytestlab.instruments.instrument import SCPIInstrument\nfrom pytestlab.MeasurementDatabase import MeasurementResult, Preamble\nfrom pytestlab.errors import SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\nimport numpy as np\nclass Oscilloscope(SCPIInstrument):\n    \"\"\"\n    Provides an interface for controlling and acquiring data from an oscilloscope using SCPI commands.\n\n    This class inherits from SCPIInstrument and implements specific methods to interact with \n    oscilloscope features such as voltage measurement and timebase scaling.\n\n    Attributes:\n    visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\n    profile (dict): Information about the instrument model.\n    \"\"\"\n    def __init__(self, visa_resource=None, profile=None, debug_mode=False):\n        \"\"\"\n        Initialize the Oscilloscope class with the given VISA resource and profile information.\n        \n        Args:\n        visa_resource (str): The VISA resource string used for identifying the connected oscilloscope.\n        profile (dict): Information about the instrument model.\n        \"\"\"\n        super().__init__(visa_resource=visa_resource, profile=profile, debug_mode=debug_mode)\n        if not self.profile:\n            raise ValueError(\"Oscilloscope profile not found.\")\n\n    def _read_preamble(self):\n        \"\"\"Reads the preamble from the oscilloscope.\n\n        :param inst: The instrument object from pyscpi or pyvisa\n        :param debug: Print debug messages\n        :return: A Preamble object\n\n        \"\"\"\n\n        peram = self._query(':WAVeform:PREamble?')\n        peram = peram.split(',')\n        self._log(peram)\n\n        pre = Preamble(peram[0], peram[1], int(peram[2]), float(peram[4]), float(\n            peram[5]), float(peram[6]), float(peram[7]), float(peram[8]), float(peram[9]))\n\n        return pre\n\n    def _read_wave_data(self, channel: int, points: int) -> np.ndarray:\n\n        self._query('*OPC?')\n        self._send_command(f':WAVeform:SOURce CHANnel{channel}')\n        self._query('*OPC?')\n        self._log('Reading channel ' + str(channel))\n\n        self._send_command(':WAVeform:FORMat BYTE')\n        self._send_command(':WAVeform:POINts:MODE MAXimum')\n\n        self._log('Reading points')\n\n        if points > 0:\n            self._send_command(f':WAVeform:POINts {points}')\n        else:\n            self._send_command(':WAVeform:POINts MAXimum')\n\n        self._query('*OPC?')\n\n        self._log('Reading data')\n\n        self._send_command(':WAVeform:DATA?')\n        data = self._read_to_np()\n\n        return data\n    def auto_scale(self):\n        \"\"\"\n        Auto scale the oscilloscope display.\n        \n        This method sends an SCPI command to the oscilloscope to auto scale the display.\n        \n        Example:\n        >>> auto_scale()\n        \"\"\"\n        self._send_command(\":AUToscale\")\n\n    def set_time_axis(self, scale: float, position: float) -> None:\n        \"\"\"\n        Sets the time axis of the Oscilloscope. (x-axis)\n\n        :param scale: scale The scale of the axis in seconds \n        :param position: The position of the time axis from the trigger in seconds\n        \"\"\"\n    \n        self._send_command(f':TIMebase:SCALe {scale}')\n        self._send_command(f':TIMebase:POSition {position}')\n        self._query('*OPC?')\n    \n    def set_channel_axis(self, channel: int, scale: float, offset: float) -> None:\n        \"\"\"\n        Sets the channel axis of the oscilloscope. (y-axis)\n\n        :param channel: The channel to set\n        :param scale: The scale of the channel axis in volts\n        :param offset: The offset of the channel in volts\n        \"\"\"\n        self._send_command(f':CHANnel{channel}:SCALe {scale}')\n        self._send_command(f':CHANnel{channel}:OFFSet {offset}')\n        self._query('*OPC?')\n        \n    def measure_voltage_peak_to_peak(self, channel):\n        \"\"\"\n        Measure the peak-to-peak voltage for a specified channel.\n        \n        This method sends an SCPI query to the oscilloscope to measure the peak-to-peak voltage \n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\n        \n        Args:\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\n        \n        Returns:\n        MeasurementResult: An object containing the peak-to-peak voltage measurement for the specified channel.\n        \n        Example:\n        >>> measure_voltage_peak_to_peak(\"CH1\")\n        <MeasurementResult object at 0x7f1ec2a4f510>\n        \"\"\"\n        self._check_valid_channel(channel)\n\n\n        measurement_result = MeasurementResult(self.profile[\"model\"], \"V\", \"peak to peak voltage\")\n\n        response = self._query(f\"MEAS:VPP? CHAN{channel}\")\n        measurement_result.add(response)\n        return measurement_result\n\n    def measure_rms_voltage(self, channel: int) -> MeasurementResult:\n        \"\"\"\n        Measure the root-mean-square (RMS) voltage for a specified channel.\n        \n        This method sends an SCPI query to the oscilloscope to measure the RMS voltage \n        of the given channel, then encapsulates the measurement result into a MeasurementResult object.\n        \n        Args:\n        channel (int/str): The channel identifier, which can be an integer or string depending on the oscilloscope model.\n        \n        Returns:\n        MeasurementResult: An object containing the RMS voltage measurement for the specified channel.\n        \n        Example:\n        >>> measure_rms_voltage(\"CH1\")\n        <MeasurementResult object at 0x7f1ec2a4f590>\n        \"\"\"\n        #Error Handling\n        self._check_valid_channel(channel)\n\n\n        measurement_result = MeasurementResult(self.profile[\"model\"], \"V\", \"rms voltage\")\n        response = self._query(f\"MEAS:VRMS? CHAN{channel}\")\n        measurement_result.add(response)\n        return measurement_result\n\n    def read_channels(self, channels, points=1, runAfter=True, time_interval=None):\n        if time_interval is not None:\n        # convert time interval to points\n            self._send_command(f\":TIMebase:MAIN:RANGe {time_interval}\")\n            self._send_command(f\"ACQuire:SRATe {1/time_interval}\")\n            points = int(time_interval * 1e9)\n        # check channels exist\n        self. _log(points)\n        self._log(\"starting\")\n        for channel in channels:\n            self._check_valid_channel(channel)\n        \n        command = \"\"\n        # set up channels\n        for channel in channels:\n            channel = command + f\"CHANnel{channel}, \"\n\n        command = command[:-2]\n\n        self._send_command(f\"DIGitize {command}\")\n        self._send_command(f':WAVeform:SOURce CHANnel{channels[0]}')\n\n        # set up points\n        pream = self._read_preamble()\n\n        all_data = np.empty([pream.points, len(channels)])\n\n        for i in range(len(channels)):\n            # _log(f'Reading channel {channels[i]}', debug)\n            data = self._read_wave_data(channels[i], points)\n            if len(data) != (pream.points):\n                print('ERROR: points mismatch, please investigate')\n            all_data[:, i] = data\n\n        voltCH = (all_data-pream.yref) * pream.yinc + pream.yorg\n\n        time = (np.arange(0, pream.points, 1)-pream.xref) * pream.xinc + pream.xorg\n\n        if runAfter:\n            self._send_command(\":RUN\")\n\n        # error = self.profile[\"channels\"][channels[0]][\"error\"]\n        return time, voltCH\n       \n    def set_timebase_scale(self, scale):\n        \"\"\"\n        Set the timebase scale of the oscilloscope.\n        \n        This method sends an SCPI command to adjust the timebase scale on the oscilloscope display.\n        \n        Args:\n        scale (float): The timebase scale in seconds per division.\n        \n        Example:\n        >>> set_timebase_scale(0.002)\n        \"\"\"\n        self._send_command(f\"TIM:SCAL {scale}\")\n\n    def get_timebase_scale(self):\n        \"\"\"\n        Retrieve the current timebase scale setting from the oscilloscope.\n        \n        This method sends an SCPI query to get the current timebase scale and encapsulates \n        the result into a MeasurementResult object.\n        \n        Returns:\n        MeasurementResult: An object containing the current timebase scale setting.\n        \n        Example:\n        >>> get_timebase_scale()\n        <MeasurementResult object at 0x7f1ec2a4f650>\n        \"\"\"\n        measurement_result = MeasurementResult(self.profile[\"model\"], \"s\", \"timebase scale\")\n        response = self._query(\"TIM:SCAL?\")\n\n        measurement_result.add(response)\n        return measurement_result\n\n    def set_acquisition_time(self, time):\n        \"\"\"\n        \n        \"\"\"\n        # Set the total time for acquisition\n        self._send_command(f\":TIMebase:MAIN:RANGe {time}\")\n\n    def set_sample_rate(self, rate):\n        \"\"\"\n        \n        \"\"\"\n        rate = rate.upper()\n        valid_values = [\"MAX\", \"AUTO\"]\n        if rate not in valid_values:\n            raise ValueError(f\"Invalid Valid: supported = {valid_values}\")\n        # Set the sample rate for acquisition\n        self._send_command(f\"ACQuire:SRATe {rate}\")\n\n    def set_bandwidth_limit(self, channel, bandwidth):\n        \"\"\"\n        \n        \"\"\"\n        self._check_valid_channel(channel)\n        # Limit the bandwidth to a specified frequency to reduce noise\n        self._send_command(f\"CHANnel{channel}:BANDwidth {bandwidth}\")\n\n    # def set_filtering(self, channel, filter_type, frequency):\n    #     self._check_valid_channel(channel)\n    #     # Configure a filter on the channel to isolate the desired frequency components\n    #     if self.profile[\"channels\"][channel][\"filtering\"] != \"available\":\n    #         raise ValueError(f\"Filtering is not available on Channel {channel}.\")\n        \n    #     if channel not in self.profile[\"channels\"]:\n    #         raise ValueError(f\"Invalid channel {channel}. Supported channels: {self.profile['channels']}\")\n\n    #     self._send_command(f\"CHANnel{channel}:FILTer:{filter_type} {frequency}\")\n\n    def set_trigger(self, channel, trigger_level):\n        \"\"\"\n        \n        \"\"\"\n        self._check_valid_channel(channel)\n        # Set the trigger level for the specified channel\n        self._send_command(f\"TRIGger:LEVel CHANnel{channel},{trigger_level}\")\n\n    # def set_trigger_mode(self, mode):\n    #     \"\"\"\n        \n    #     \"\"\"\n    #     if mode not in self.profile[\"trigger_modes\"]:\n    #         raise ValueError(f\"Invalid trigger mode {mode}. Supported trigger modes: {self.profile['trigger_modes']}\")\n    #     # Set the trigger mode to either edge or pulse\n    #     self._send_command(f\"TRIGger:MODE {mode}\")\n\n    def set_trigger_source(self, channel):\n        \"\"\"\n        \n        \"\"\"\n        self._check_valid_channel(channel)\n        # Set the trigger source to the specified channel\n        self._send_command(f\"TRIGger:SOURce CHANnel{channel}\")\n\n    # def set_trigger_edge_slope(self, slope):\n    #     \"\"\"\"\"\"\n    #     # Set the edge slope to either rising or falling\n    #     self._send_command(f\"TRIGger:EDGE:SLOPe {slope}\")\n\n    # def set_trigger_pulse_polarity(self, polarity):\n    #     # Set the pulse polarity to either positive or negative\n    #     self._send_command(f\"TRIGger:PULSe:POLarity {polarity}\")\n\n    # def set_trigger_pulse_width(self, width):\n    #     # Set the pulse width to the specified value\n    #     self._send_command(f\"TRIGger:PULSe:WIDth {width}\")\n\n    # def set_trigger_pulse_delay(self, delay):\n    #     # Set the pulse delay to the specified value\n    #     self._send_command(f\"TRIGger:PULSe:DELay {delay}\")\n\n    # def set_trigger_pulse_transition(self, transition):\n    #     # Set the pulse transition to either positive or negative\n    #     self._send_command(f\"TRIGger:PULSe:TRANsition {transition}\")\n\n    # def set_trigger_pulse_condition(self, condition):\n    #     # Set the pulse condition to either width or delay\n    #     self._send_command(f\"TRIGger:PULSe:CONdition {condition}\")\n\n    def wave_gen(self, state: bool):\n        \"\"\"\n        Enable or disable the waveform generator of the oscilloscope.\n\n        This method sends an SCPI command to enable or disable the function generator in the oscilloscope.\n        \n        Args:\n        state (str): The desired state ('ON' or 'OFF') for the waveform generator.\n        \n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\n        \n        Example:\n        >>> set_wave_gen('ON')\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        # if state not in self.profile[\"function_generator\"]:\n        #     raise ValueError(f\"Invalid state {state}. Supported states: {self.profile['function_generator']}\")\n        \n        self._send_command(f\"WGEN:OUTP {'ON' if state else 'OFF'}\")\n\n    def set_wave_gen_func(self, state):\n        \"\"\"\n        Set the waveform function for the oscilloscope's waveform generator.\n\n        This method sends an SCPI command to change the function (e.g., 'SINE', 'SQUARE') of the waveform generator.\n        \n        Args:\n        state (str): The desired function ('SINE', 'SQUARE', etc.) for the waveform generator.\n\n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the state is not supported.\n\n        Example:\n        >>> set_wave_gen_func('SINE')\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if state not in self.profile[\"function_generator\"][\"waveform_types\"]:\n            raise ValueError(f\"Invalid state {state}. Supported states: {self.profile['function_generator']['waveform_types']}\")\n        \n        self._send_command(f\"WGEN:FUNC {state}\")\n\n    def set_wave_gen_freq(self, freq):\n        \"\"\"\n        Set the frequency for the waveform generator.\n\n        This method sends an SCPI command to set the frequency of the waveform generator.\n        \n        Args:\n        freq (float): The desired frequency for the waveform generator in Hz.\n\n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the frequency is out of range.\n\n        Example:\n        >>> set_wave_gen_freq(1000.0)\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if freq < self.profile[\"function_generator\"][\"frequency\"][\"min\"] or freq > self.profile[\"function_generator\"][\"frequency\"][\"max\"]:\n            raise ValueError(f\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\")\n\n        self._send_command(f\"WGEN:FREQ {freq}\")\n\n    def set_wave_gen_amp(self, amp):\n        \"\"\"\n        Set the amplitude for the waveform generator.\n\n        This method sends an SCPI command to set the amplitude of the waveform generator.\n        \n        Args:\n        amp (float): The desired amplitude for the waveform generator in volts.\n\n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the amplitude is out of range.\n\n        Example:\n        >>> set_wave_gen_amp(1.0)\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if amp < self.profile[\"function_generator\"][\"amplitude\"][\"min\"] or amp > self.profile[\"function_generator\"][\"amplitude\"][\"max\"]:\n            raise ValueError(f\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\")\n\n        self._send_command(f\"WGEN:VOLT {amp}\")\n\n    def set_wave_gen_offset(self, offset):\n        \"\"\"\n        Set the voltage offset for the waveform generator.\n\n        This method sends an SCPI command to set the voltage offset of the waveform generator.\n        \n        Args:\n        offset (float): The desired voltage offset for the waveform generator in volts.\n\n        Raises:\n        ValueError: If the oscilloscope model does not have a waveform generator or if the offset is out of range.\n\n        Example:\n        >>> set_wave_gen_offset(0.1)\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if offset < self.profile[\"function_generator\"][\"offset\"][\"min\"] or offset > self.profile[\"function_generator\"][\"offset\"][\"max\"]:\n            raise ValueError(f\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\")\n        \n        self._send_command(f\"WGEN:VOLT:OFFSet {offset}\")\n\n    def set_wgen_sin(self, amp: float, offset: float, freq: float) -> None:\n        \"\"\"Sets the waveform generator to a sine wave. (Only available on specific models)\n\n        :param amp: The amplitude of the sine wave in volts\n        :param offset: The offset of the sine wave in volts\n        :param freq: The frequency of the sine wave in Hz. The frequency can be adjusted from 100 mHz to 20 MHz.\n        \"\"\"\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if offset < self.profile[\"function_generator\"][\"offset\"][\"min\"] or offset > self.profile[\"function_generator\"][\"offset\"][\"max\"]:\n            raise ValueError(f\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\")\n        if amp < self.profile[\"function_generator\"][\"amplitude\"][\"min\"] or amp > self.profile[\"function_generator\"][\"amplitude\"][\"max\"]:\n            raise ValueError(f\"Invalid amplitude {amp}. Supported amplitude range: {self.profile['function_generator']['amplitude']['min']} to {self.profile['function_generator']['amplitude']['max']}\")\n        if freq < self.profile[\"function_generator\"][\"frequency\"][\"min\"] or freq > self.profile[\"function_generator\"][\"frequency\"][\"max\"]:\n            raise ValueError(f\"Invalid frequency {freq}. Supported frequency range: {self.profile['function_generator']['frequency']['min']} to {self.profile['function_generator']['frequency']['max']}\")\n\n        self._send_command('WGEN:FUNCtion SINusoid')\n        self._send_command(f':WGEN:VOLTage {amp}')\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\n        self._send_command(f':WGEN:FREQuency {freq}')\n\n\n    def set_wgen_square(self, v0: float, v1: float, freq: float, dutyCycle: int) -> None:\n        \"\"\"Sets the waveform generator to a square wave. (Only available on specific models)\n\n        :param v0: The voltage of the low state in volts\n        :param v1: The voltage of the high state in volts\n        :param freq: The frequency of the square wave in Hz. The frequency can be adjusted from 100 mHz to 10 MHz.\n        :param dutyCycle: The duty cycle can be adjusted from 1% to 99% up to 500 kHz. At higher frequencies, the adjustment range narrows so as not to allow pulse widths less than 20 ns.\n        \"\"\"\n\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        \n        self._send_command('WGEN:FUNCtion SQUare')\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n        self._send_command(f':WGEN:FREQuency {freq}')\n        self._send_command(f':WGEN:FUNCtion:SQUare:DCYCle {dutyCycle}')\n\n\n    def set_wgen_ramp(self, v0: float, v1: float, freq: float, symmetry: int) -> None:\n        \"\"\"Sets the waveform generator to a ramp wave. (Only available on specific models)\n\n        :param v0: The voltage of the low state in volts\n        :param v1: The voltage of the high state in volts\n        :param freq: The frequency of the ramp wave in Hz. The frequency can be adjusted from 100 mHz to 100 kHz.\n        :param symmetry: Symmetry represents the amount of time per cycle that the ramp waveform is rising and can be adjusted from 0% to 100%.\n        \"\"\"\n\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        \n        self._send_command('WGEN:FUNCtion RAMP')\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n        self._send_command(f':WGEN:FREQuency {freq}')\n        self._send_command(f':WGEN:FUNCtion:RAMP:SYMMetry {symmetry}')\n\n\n    def set_wgen_pulse(self, v0: float, v1: float, period: float, pulseWidth: float) -> None:\n        \"\"\"Sets the waveform generator to a pulse wave. (Only available on specific models)\n\n        :param v0: The voltage of the low state in volts\n        :param v1: The voltage of the high state in volts\n        :param period: The period of the pulse wave in seconds. The period can be adjusted from 10 ns to 10 s.\n        :param pulseWidth: The pulse width can be adjusted from 20 ns to the period minus 20 ns.\n        \"\"\"\n\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n\n        self._send_command('WGEN:FUNCtion PULSe')\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n        self._send_command(f':WGEN:PERiod {period}')\n        self._send_command(f':WGEN:FUNCtion:PULSe:WIDTh {pulseWidth}')\n\n\n    def set_wgen_dc(self, offset: float) -> None:\n        \"\"\"Sets the waveform generator to a DC wave. (Only available on specific models)\n\n        :param offset: The offset of the DC wave in volts\n        \"\"\"\n\n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        if offset < self.profile[\"function_generator\"][\"offset\"][\"min\"] or offset > self.profile[\"function_generator\"][\"offset\"][\"max\"]:\n            raise ValueError(f\"Invalid offset {offset}. Supported offset range: {self.profile['function_generator']['offset']['min']} to {self.profile['function_generator']['offset']['max']}\")\n        \n        self._send_command('WGEN:FUNCtion DC')\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\n\n\n    def set_wgen_noise(self, v0: float, v1: float, offset: float) -> None:\n        \"\"\"Sets the waveform generator to a noise wave. (Only available on specific models)\n\n        :param v0: The voltage of the low state in volts\n        :param v1: The voltage of the high state in volts\n        :param offset: The offset of the noise wave in volts\n        \"\"\"\n        \n        if \"function_generator\" not in self.profile:\n            raise ValueError(f\"Waveform generator is not available on this oscilloscope.\")\n        \n        self._send_command('WGEN:FUNCtion NOISe')\n        self._send_command(f':WGEN:VOLTage:LOW {v0}')\n        self._send_command(f':WGEN:VOLTage:HIGH {v1}')\n        self._send_command(f':WGEN:VOLTage:OFFSet {offset}')\n\n\nclass DigitalOscilloscopeWithJitter(Oscilloscope):\n\n    def __init__(self, visa_resource, profile):\n        super().__init__(visa_resource, profile)\n\n    def _available_jitter_measurements(self, jitter_type):\n        if jitter_type not in self.profile[\"jitter_analysis\"][\"available_types\"]:\n            raise ValueError(f\"Invalid jitter type {jitter_type}. Supported jitter types: {self.profile['jitter_analysis']}\")\n\n    def setup_rms_jitter_measurement(self, channel):\n        self._available_jitter_measurements(\"rms\")\n        # Implement SCPI commands to set up the oscilloscope for jitter measurement\n        self._send_command(f\"MEASure:JITTer:SOURce CHANnel{channel}\")\n        self._send_command(\"MEASure:JITTer:MODE RMS\")\n\n    def setup_peak_to_peak_jitter_measurement(self, channel):\n        self._available_jitter_measurements(\"peak_to_peak\")\n        # Implement SCPI commands to set up the oscilloscope for jitter measurement\n        self._send_command(f\"MEASure:JITTer:SOURce CHANnel{channel}\")\n        self._send_command(\"MEASure:JITTer:MODE PK2PK\")\n\n    def setup_period_jitter_measurement(self, channel):\n        self._available_jitter_measurements(\"period\")\n        # Implement SCPI commands to set up the oscilloscope for jitter measurement\n        self._send_command(f\"MEASure:JITTer:SOURce CHANnel{channel}\")\n        self._send_command(\"MEASure:JITTer:MODE PERiod\")\n\n    def setup_cycle_to_cycle_jitter_measurement(self, channel):\n        self._available_jitter_measurements(\"cycle_to_cycle\")\n        # Implement SCPI commands to set up the oscilloscope for jitter measurement\n        self._send_command(f\"MEASure:JITTer:SOURce CHANnel{channel}\")\n        self._send_command(\"MEASure:JITTer:MODE CCYCle\")\n\n    def configure_trigger(self, trigger_source, trigger_level):\n        # Implement SCPI commands to configure trigger settings for jitter measurement\n        self._send_command(f\"TRIGger:SOURce CHANnel{trigger_source}\")\n        self._send_command(f\"TRIGger:LEVel CHANnel{trigger_source},{trigger_level}\")\n\n    def acquire_jitter_data(self):\n        # Implement SCPI commands to acquire jitter data from the oscilloscope\n        self._send_command(\"ACQuire:STATE RUN\")\n\n    def analyze_jitter_data(self):\n        measurement_result = MeasurementResult(self.profile[\"model\"], \"s\", \"jitter\")\n        jitter_value = self._query_command(\"MEASure:JITTer?\")\n        measurement_result.add_measurement(jitter_value)\n        return measurement_result\n    \n    def perform_rms_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\n        self.setup_rms_jitter_measurement(channel)\n        self.configure_trigger(trigger_source, trigger_level)\n        self.acquire_jitter_data()\n        return self.analyze_jitter_data()\n    \n    def perform_peak_to_peak_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\n        \"\"\"\n        Perform a peak-to-peak jitter measurement on a specified channel with given trigger settings.\n        \n        This method sets up the measurement, configures the trigger, acquires the jitter data and \n        then analyzes the data to return a MeasurementResult object containing the results of \n        the jitter measurement.\n        \n        Args:\n        channel (str/int): The identifier for the channel on which the measurement is to be performed.\n                        This could be an integer representing the channel number or a string representing\n                        the channel name, depending on the implementation.\n        trigger_source (str/int): The identifier for the trigger source. This could be an integer or a \n                                string representing the source depending on the implementation.\n        trigger_level (float): The trigger level for the measurement in volts. This value sets the voltage \n                            level at which the trigger event occurs.\n        \n        Returns:\n        MeasurementResult: An object containing the results of the peak-to-peak jitter measurement.\n        \n        Raises:\n        NotImplementedError: If any of the method calls within this function (e.g., setup_peak_to_peak_jitter_measurement, \n                            configure_trigger, acquire_jitter_data, analyze_jitter_data) are not implemented.\n        MeasurementError: If there is an error during the measurement process.\n        \n        Example:\n        >>> perform_peak_to_peak_jitter_measurement(\"CH1\", \"External\", 0.5)\n        <MeasurementResult object at 0x7f9bd8134f50>\n        \"\"\"\n        self.setup_peak_to_peak_jitter_measurement(channel)\n        self.configure_trigger(trigger_source, trigger_level)\n        self.acquire_jitter_data()\n        return self.analyze_jitter_data()\n\n        \n    def perform_period_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\n        self.setup_period_jitter_measurement(channel)\n        self.configure_trigger(trigger_source, trigger_level)\n        self.acquire_jitter_data()\n        return self.analyze_jitter_data()\n\n    def perform_cycle_to_cycle_jitter_measurement(self, channel, trigger_source, trigger_level) -> MeasurementResult:\n        self.setup_cycle_to_cycle_jitter_measurement(channel)\n        self.configure_trigger(trigger_source, trigger_level)\n        self.acquire_jitter_data()\n        return self.analyze_jitter_data()\n        ",
    "instruments\\WaveformGenerator.py": "from pytestlab.instruments.instrument import SCPIInstrument\nfrom pytestlab.errors import SCPIConnectionError, SCPICommunicationError, SCPIValueError, InstrumentNotFoundError, IntrumentConfigurationError\n\nclass WaveformGenerator(SCPIInstrument):\n    def __init__(self, profile):\n        \"\"\"\n        Initialize a WaveformGenerator instance with a device profile.\n\n        Args:\n            profile (dict): A dictionary containing device profile information.\n\n        \"\"\"\n        super().__init__()\n        self.profile = profile\n\n    def _validate_waveform(self, waveform_type):\n        \"\"\"\n        Validate if the waveform type is supported by the device.\n\n        Args:\n            waveform_type (str): The type of waveform to validate.\n\n        Raises:\n            ValueError: If the waveform type is not supported.\n\n        \"\"\"\n        standard_waveforms = [w.upper() for w in self.profile.get('waveforms', {}).get('standard', [])]\n        if waveform_type.upper() not in standard_waveforms:\n            raise ValueError(f\"Invalid waveform type: {waveform_type}. Supported types: {standard_waveforms}\")\n\n    def _validate_frequency(self, frequency):\n        \"\"\"\n        Validate if the frequency is within the device's supported range.\n\n        Args:\n            frequency (float): The frequency to validate.\n\n        Raises:\n            ValueError: If the frequency is out of range.\n\n        \"\"\"\n        max_frequency = self.profile.get('max_frequency')\n        if frequency > max_frequency:\n            raise ValueError(f\"Frequency out of range. Max supported frequency: {max_frequency}\")\n\n    def _validate_amplitude(self, amplitude):\n        \"\"\"\n        Validate if the amplitude is within the device's supported range.\n\n        Args:\n            amplitude (float): The amplitude to validate.\n\n        Raises:\n            ValueError: If the amplitude is out of range.\n\n        \"\"\"\n        min_amplitude = self.profile.get('amplitude', {}).get('min', 0)\n        max_amplitude = self.profile.get('amplitude', {}).get('max', float('inf'))\n        if not min_amplitude <= amplitude <= max_amplitude:\n            raise ValueError(f\"Amplitude out of range. Supported range: {min_amplitude} to {max_amplitude}\")\n\n    def _validate_offset(self, offset):\n        \"\"\"\n        Validate if the offset is within the device's supported range.\n\n        Args:\n            offset (float): The offset to validate.\n\n        Raises:\n            ValueError: If the offset is out of range.\n\n        \"\"\"\n        min_offset = self.profile.get('dc_offset', {}).get('min', float('-inf'))\n        max_offset = self.profile.get('dc_offset', {}).get('max', float('inf'))\n        if not min_offset <= offset <= max_offset:\n            raise ValueError(f\"Offset out of range. Supported range: {min_offset} to {max_offset}\")\n\n    def set_waveform(self, channel, waveform_type):\n        \"\"\"\n        Sets the waveform type for the specified channel after validation.\n\n        Args:\n            channel (int or str): The channel for which to set the waveform.\n            waveform_type (str): The type of waveform to set.\n\n        \"\"\"\n        self._validate_waveform(waveform_type)\n        self._send_command(f\"SOUR{channel}:FUNC {waveform_type.upper()}\")\n\n    def set_frequency(self, channel, frequency):\n        \"\"\"\n        Sets the frequency for the specified channel after validation.\n\n        Args:\n            channel (int or str): The channel for which to set the frequency.\n            frequency (float): The frequency to set.\n\n        \"\"\"\n        self._validate_frequency(frequency)\n        self._send_command(f\"SOUR{channel}:FREQ {frequency}\")\n\n    def set_amplitude(self, channel, amplitude):\n        \"\"\"\n        Sets the amplitude for the specified channel after validation.\n\n        Args:\n            channel (int or str): The channel for which to set the amplitude.\n            amplitude (float): The amplitude to set.\n\n        \"\"\"\n        self._validate_amplitude(amplitude)\n        self._send_command(f\"SOUR{channel}:AMPL {amplitude}\")\n\n    def set_offset(self, channel, offset):\n        \"\"\"\n        Sets the offset for the specified channel after validation.\n\n        Args:\n            channel (int or str): The channel for which to set the offset.\n            offset (float): The offset to set.\n\n        \"\"\"\n        self._validate_offset(offset)\n        self._send_command(f\"SOUR{channel}:OFFS {offset}\")\n\n# Similar approach can be taken for PatternGenerator\nclass PatternGenerator(SCPIInstrument):\n    def __init__(self, profile):\n        \"\"\"\n        Initialize a PatternGenerator instance with a device profile.\n\n        Args:\n            profile (dict): A dictionary containing device profile information.\n\n        \"\"\"\n        super().__init__()\n        self.profile = profile\n\n    def _validate_pattern(self, pattern):\n        \"\"\"\n        Validate if the pattern is supported by the device.\n\n        Args:\n            pattern (str): The type of pattern to validate.\n\n        Raises:\n            ValueError: If the pattern is not supported.\n\n        \"\"\"\n        standard_patterns = [p.upper() for p in self.profile.get('waveforms', {}).get('standard', [])]\n        if pattern.upper() not in standard_patterns:\n            raise ValueError(f\"Invalid pattern: {pattern}. Supported types: {standard_patterns}\")\n\n    def set_pattern(self, channel, pattern):\n        \"\"\"\n        Sets the pattern for the specified channel after validation.\n\n        Args:\n            channel (int or str): The channel for which to set the pattern.\n            pattern (str): The type of pattern to set.\n\n        \"\"\"\n        self._validate_pattern(pattern)\n        self._send_command(f\"SOUR{channel}:FUNC {pattern.upper()}\")\n",
    "profiles\\__init__.py": "",
    "profiles\\keysight\\infiniium.py": "\noscilloscope_profile = {\n    \"MXR054A\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"MXR054A\", \n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"bandwidth\": \"500 MHz\",\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n    },\n    \"MXR058A\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"MXR058A\", \n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n      1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      2: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },  \n      3: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      4: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      5: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      6: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }, \n      7: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n      8: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"bandwidth\": \"500 MHz\",  \n    \"analog_channels\": 8,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n    \"MXR104A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR104A\",\n    \"bandwidth\": \"1 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR108A\": {\n    # Same as MXR058A except: \n    \"model\": \"MXR108A\",\n    \"bandwidth\": \"1 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR204A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR204A\",\n    \"bandwidth\": \"2 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR208A\": {\n    # Same as MXR058A except:\n    \"model\": \"MXR208A\",\n    \"bandwidth\": \"2 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR254A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR254A\",\n    \"bandwidth\": \"2.5 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n  \n  \"MXR258A\": {\n    # Same as MXR058A except:\n    \"model\": \"MXR258A\",\n    \"bandwidth\": \"2.5 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR404A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR404A\", \n    \"bandwidth\": \"4 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR408A\": {\n    # Same as MXR058A except:\n    \"model\": \"MXR408A\",\n    \"bandwidth\": \"4 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR604A\": {\n    # Same as MXR054A except:\n    \"model\": \"MXR604A\",\n    \"bandwidth\": \"6 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  },\n\n  \"MXR608A\": {\n    # Same as MXR058A except:\n    \"model\": \"MXR608A\",\n    \"bandwidth\": \"6 GHz\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Input Channel 1\",\n        \"min\": -5.0,               \n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],   \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        2: {\n        \"description\": \"Input Channel 2\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,  \n        \"probe_attenuation\": [1, 10, 100]\n        },\n        3: {\n        \"description\": \"Input Channel 3\",\n        \"min\": -5.0,\n        \"max\": 5.0,\n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        },\n        4: {\n        \"description\": \"Input Channel 4\",\n        \"min\": -5.0,\n        \"max\": 5.0, \n        \"input_coupling\": [\"AC\", \"DC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10, 100]\n        }\n    },\n    \"timebase\": {\n        \"min_scale\": 5e-12,\n        \"max_scale\": 200,\n        \"time_units\": [\"s\", \"ms\", \"us\", \"ns\"]\n    },\n    \"trigger\": {\n        \"available_modes\": [\"EDGE\", \"PULSE\", \"TIMEOUT\", \"WINDOW\"],\n        \"slope\": [\"RISING\", \"FALLING\", \"EITHER\"],\n        \"external_trigger_input\": [\"AUX\"] \n    },\n    \"analog_channels\": 4,\n    \"sampling_rate\": \"16 GSa/s\",\n    \"standard_memory\": \"200 Mpts/ch\",\n    \"waveform_update_rate\": \"> 200,000 wfms/sec\",\n    \"jitter_analysis\": {\n        \"available_types\": [\"RMS\"],\n        \"jitter_sources\": [\"Time Interval Error\"],\n        \"analysis_depth\": 1e6,\n        \"histogram_bins\": 256, \n        \"modulation_analysis\": False,\n        \"real_time_analysis\": False,\n        \"min_jitter_measurement\": 1e-12,\n        \"max_jitter_measurement\": 1e-3\n    }\n  }\n}",
    "profiles\\keysight\\smartbench.py": "oscilloscope_profile = {\n    \"DSOX1204A\":{\n    \"manufacturer\": \"Keysight\",\n    \"vendor_id\": 0x2A8D,\n    \"product_id\": 0x0396,\n    \"model\": \"DSOX1204A\",\n    \"device_type\": \"oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Analog Channel 1\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"], \n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        2: {\n        \"description\": \"Analog Channel 2\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        3: {\n        \"description\": \"Analog Channel 3\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        4: {\n        \"description\": \"Analog Channel 4\",\n        \"min\": -5,\n        \"max\": 5, \n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        }\n    },\n    \"bandwidth\": 70e6,\n    \"sampling_rate\": 2e9,\n    \"memory\": 2e6,\n    \"waveform_update_rate\": 2e5,\n    \"trigger_modes\": [\"Edge\", \"Pulse Width\", \"Video\", \"I2C\", \"SPI\", \"UART/RS232\", \"CAN\", \"LIN\"],\n    \"timebase\": {  \n        \"min\": 5e-9,\n        \"max\": 50\n    }\n    },\n    \"DSOX1204G\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"DSOX1204G\",\n    \"vendor_id\": 0x2A8D,\n    \"product_id\": 0x0396,\n    \"device_type\": \"Oscilloscope\",\n    \"channels\": {\n        1: {\n        \"description\": \"Analog Channel 1\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10],\n        \"timebase\": {\n            \"range\": {\n            \"min\": 5e-9,\n            \"max\": 50\n            },\n            \"horizontal_resolution\": 1e-12\n        }\n        },\n        2: {\n        \"description\": \"Analog Channel 2\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        3: {\n        \"description\": \"Analog Channel 3\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        },\n        4: {\n        \"description\": \"Analog Channel 4\",\n        \"min\": -5,\n        \"max\": 5,\n        \"input_coupling\": [\"DC\", \"AC\"],\n        \"input_impedance\": 1e6,\n        \"probe_attenuation\": [1, 10]\n        }\n    },\n    \"bandwidth\": 70e6,\n    \"sampling_rate\": 2e9,\n    \"memory\": 2e6,\n    \"waveform_update_rate\": 2e5,\n    \"trigger_modes\": [\"EDGE\", \"PULSe\", \"VIDEo\", \"I2C\", \"SPI\", \"UART\", \"RS232\", \"CAN\", \"LIN\"],\n    \"timebase\": {\n        \"min\": 5e-9,\n        \"max\": 50\n    },\n    \"function_generator\": {\n        \"waveform_types\": [\"SINusoid\", \"SQUare\", \"RAMp\", \"PULse\", \"NOISe\", \"DC\"],\n        \"supported_states\": [\"ON\", \"OFF\"],\n        \"offset\": { \n        \"min\": -5,\n        \"max\": 5\n        },\n        \"frequency\": {\n        \"min\": 0.1,\n        \"max\": 20e6\n        },\n        \"amplitude\": {\n        \"min\": 2e-3,\n        \"max\": 20    \n        }\n    }\n    }\n}\n\npower_supply_profile = {\n  \"EDU36311A\": {\n    \"manufacturer\": \"Keysight\",\n    \"vendor_id\": 0x2a8d,\n    \"product_id\": 0x8f01,\n    \"model\": \"EDU36311A\",\n    \"device_type\": \"powersupply\",\n    \n    \"outputs\": {\n      1: {\n        \"voltage\": {\n          \"min\": 0,\n          \"max\": 6\n        },\n        \"current\": {\n          \"min\": 0, \n          \"max\": 5\n        }\n      },\n      2: {\n        \"voltage\": {\n          \"min\": 0,\n          \"max\": 30\n        },\n        \"current\": {\n          \"min\": 0,\n          \"max\": 1\n        }\n      },\n      3: {\n        \"voltage\": {\n          \"min\": 0,\n          \"max\": 30\n        },\n        \"current\": {\n          \"min\": 0,\n          \"max\": 1  \n        }\n      }\n    },\n    \n    \"total_power\": 90, \n    \"line_regulation\": 0.01, \n    \"load_regulation\": 0.2,\n    \"programming_accuracy\": {\n      \"voltage\": 0.05,\n      \"current\": 0.2  \n    },\n    \n    \"readback_accuracy\": {\n      \"voltage\": 0.05,\n      \"current\": 0.2\n    },\n    \n    \"interfaces\": [\"USB\", \"LAN\"],\n    \"remote_control\": [\"SCPI\", \"IVI\", \"Web Browser\"]\n  }\n}\n\nawg_profile = {\n  \"EDU33211A\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"EDU33211A\", \n    \"vendor_id\": 0x2a8d,\n    \"product_id\": 0x8d01,\n    \"device_type\": \"Arbitrary Waveform Generator\",\n    \n    \"channels\": 1,\n    \"max_frequency\": 20e6, \n    \n    \"waveforms\": {\n      \"standard\": [\"sine\", \"square\", \"ramp\", \"pulse\", \"triangle\", \"noise\", \"PRBS\", \"DC\"],\n      \"built-in\": [\"cardiac\", \"exponential_fall\", \"exponential_rise\", \"gaussian_pulse\", \n                  \"haversine\", \"lorentz\", \"dlorentz\", \"negative_ramp\", \"sinc\"],\n      \"arbitrary\": {\n        \"memory\": 8e6, \n        \"max_length\": 1e6,\n        \"sampling_rate\": {\n          \"min\": 1e-6,\n          \"max\": 250e6\n        },\n        \"resolution\": 16\n      }\n    },\n    \n    \"modulation_types\": [\"AM\", \"FM\", \"PM\", \"FSK\", \"BPSK\", \"PWM\"],\n    \n    \"amplitude\": {\n      \"min\": 1e-3,\n      \"max\": 10\n    },\n    \n    \"dc_offset\": {\n      \"min\": -5,\n      \"max\": 5  \n    },\n\n    \"accuracy\": {\n      \"amplitude\": 0.02, \n      \"frequency\": 1e-6\n    },\n    \n    \"interfaces\": [\"USB\", \"LAN\"], \n    \"remote_control\": [\"SCPI\", \"IVI\", \"Web Browser\"]\n  }\n}\n\nmultimeter_profile = {\n    \"EDU34450A\": {\n    \"manufacturer\": \"Keysight\",\n    \"model\": \"EDU34450A\",\n    \"vendor_id\": 0x2a8d,\n    \"product_id\": 0x8e01,\n    \"device_type\": \"multimeter\",\n\n    \"channels\": 1,\n    \"resolution\": 5.5,\n    \"max_voltage\": 1000,\n    \"max_current\": 10,\n    \"max_resistance\": 100e6,\n    \"max_capacitance\": 10e-6,\n    \"max_frequency\": 1e6,\n    }\n  }"
}